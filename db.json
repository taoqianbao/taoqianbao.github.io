{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-1.gif","path":"imgs/ooj-1.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-2.gif","path":"imgs/ooj-2.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-4.gif","path":"imgs/ooj-4.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-3.gif","path":"imgs/ooj-3.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/zmlmf.jpeg","path":"imgs/zmlmf.jpeg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1514280699000},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1514377595000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1514280699000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1514280699000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1514280699000},{"_id":"themes/landscape/_config.yml","hash":"1a66cb563283bef13dd7eeeda8f1d988b3401049","modified":1514986249000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1514280699000},{"_id":"source/_drafts/hello-page.md","hash":"69e2b3b9a445faefaa62e4a45415df044ef6e0a5","modified":1514280699000},{"_id":"source/about/index.md","hash":"4e177a2f4c1654a20ad80fa7eaa4cc6aae479776","modified":1514372409000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1514280699000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1514280699000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1514280699000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1514280699000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1514280699000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1514280699000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1514280699000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1514280699000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1514280699000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1514280699000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1514280699000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1514280699000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1514280699000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1514280699000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1514280699000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1514280699000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514280699000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514280699000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1514280699000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1514280699000},{"_id":"themes/landscape/source/.DS_Store","hash":"1c3b46d4c8df355621f61d4ed7a326c410c4607e","modified":1514376639000},{"_id":"source/_posts/itpmp/lesson1.md","hash":"bf7790450f10bab092afb32d46863c441a60db7a","modified":1515058659000},{"_id":"source/_posts/git/how-to-use-git.md","hash":"68d134b60ffc307feed7175a0e09797d0eedb62c","modified":1514383995000},{"_id":"source/_posts/csharp/hello-csharp.md","hash":"84ae7e7aabdde37e53638d7e13890edd59f1d42d","modified":1514280815000},{"_id":"source/_posts/javascript/OOJ-THREE.md","hash":"71c6f76b9066a7d9346a5e0b4b35e1e7f645cb91","modified":1514354807000},{"_id":"source/_posts/javascript/OOJ-ONE.md","hash":"48baf5449633b2e4eeadf04e80d4e8da375f8dbf","modified":1514355537000},{"_id":"source/_posts/javascript/OOJ-TWO.md","hash":"817dcec17c7d8d516f99192b6ae1bc8566077d9e","modified":1514354828000},{"_id":"source/_posts/javascript/modules-one.md","hash":"4c7a556ab10393c54cc5a95f2614e3ed8341199b","modified":1514378324000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"7fd1ae013aab56a0a5212f91565797cfd8b843ac","modified":1514989543000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"af08a6a4957ad88e8eea457b3f54812085bd4608","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/baidu-analytics.ejs","hash":"3ac40e649c5ea940f635db5d8ef00d1b571dfacc","modified":1514986406000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"8fb74bcb688a269dc7ec0800996c5f09cf66181d","modified":1514986288000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"3074fd732dc9ed69a95ecb97dd04a908e0faa18b","modified":1514374909000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1514280699000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1514280699000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"0a8de18e3749cb488f24ac50b68bb112f75032d6","modified":1514355828000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1514280699000},{"_id":"themes/landscape/source/imgs/ooj-1.gif","hash":"ca81d82ec8823f7ffefaf37d71227482221643e4","modified":1514355296000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1514280699000},{"_id":"themes/landscape/source/imgs/ooj-2.gif","hash":"31a3530c12a79b718664e3c233b94478af760a56","modified":1514355292000},{"_id":"themes/landscape/source/imgs/ooj-4.gif","hash":"24cfb25c0f15bd26c3bf077bb10bd47a47fc3d3a","modified":1514355292000},{"_id":"themes/landscape/source/imgs/ooj-3.gif","hash":"6e94fe132149b30f9c9dc372755a69152af1e7d4","modified":1514355292000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"b8980492dda75654c033ad7b1e16fa8acc059a98","modified":1514382306000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1514280699000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1514280699000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1514280699000},{"_id":"themes/landscape/source/imgs/zmlmf.jpeg","hash":"6c2115b7e9d9f52dfca9e8b46c4e6ad4d9847456","modified":1514372206000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1514280699000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1514280699000}],"Category":[{"name":"C#","_id":"cjc0atcpa0007a4e381fsuie5"},{"name":"Javascript","_id":"cjc0atcpf000da4e3nyqw1jfg"}],"Data":[],"Page":[{"title":"我的介绍","date":"2017-12-27T10:42:41.000Z","_content":"\n![珠穆朗玛峰](/imgs/zmlmf.jpeg)\n\n#### 本人\n\nIT农民工一名。\n\n#### 领域\n\n- H5 / JavaScript / Node.js\n- ASP.NET / C#\n- 以及其他 Web domain相关，无论前端还是后端\n- 架构\n\n#### 联系方式\n\n- GitHub：[taoqianbao](https://github.com/taoqianbao)\n- 邮箱：taoqianbao#gmail.com\n","source":"about/index.md","raw":"---\ntitle: 我的介绍\ndate: 2017-12-27 18:42:41\n---\n\n![珠穆朗玛峰](/imgs/zmlmf.jpeg)\n\n#### 本人\n\nIT农民工一名。\n\n#### 领域\n\n- H5 / JavaScript / Node.js\n- ASP.NET / C#\n- 以及其他 Web domain相关，无论前端还是后端\n- 架构\n\n#### 联系方式\n\n- GitHub：[taoqianbao](https://github.com/taoqianbao)\n- 邮箱：taoqianbao#gmail.com\n","updated":"2017-12-27T11:00:09.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjc0atco70001a4e3ct38ytrk","content":"<p><img src=\"/imgs/zmlmf.jpeg\" alt=\"珠穆朗玛峰\"></p>\n<h4 id=\"本人\"><a href=\"#本人\" class=\"headerlink\" title=\"本人\"></a>本人</h4><p>IT农民工一名。</p>\n<h4 id=\"领域\"><a href=\"#领域\" class=\"headerlink\" title=\"领域\"></a>领域</h4><ul>\n<li>H5 / JavaScript / Node.js</li>\n<li>ASP.NET / C#</li>\n<li>以及其他 Web domain相关，无论前端还是后端</li>\n<li>架构</li>\n</ul>\n<h4 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h4><ul>\n<li>GitHub：<a href=\"https://github.com/taoqianbao\" target=\"_blank\" rel=\"noopener\">taoqianbao</a></li>\n<li>邮箱：taoqianbao#gmail.com</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/imgs/zmlmf.jpeg\" alt=\"珠穆朗玛峰\"></p>\n<h4 id=\"本人\"><a href=\"#本人\" class=\"headerlink\" title=\"本人\"></a>本人</h4><p>IT农民工一名。</p>\n<h4 id=\"领域\"><a href=\"#领域\" class=\"headerlink\" title=\"领域\"></a>领域</h4><ul>\n<li>H5 / JavaScript / Node.js</li>\n<li>ASP.NET / C#</li>\n<li>以及其他 Web domain相关，无论前端还是后端</li>\n<li>架构</li>\n</ul>\n<h4 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h4><ul>\n<li>GitHub：<a href=\"https://github.com/taoqianbao\" target=\"_blank\" rel=\"noopener\">taoqianbao</a></li>\n<li>邮箱：taoqianbao#gmail.com</li>\n</ul>\n"}],"Post":[{"title":"hello-page","_content":"","source":"_drafts/hello-page.md","raw":"---\ntitle: hello-page\ntags:\n---\n","slug":"hello-page","published":0,"date":"2017-12-26T09:31:39.000Z","updated":"2017-12-26T09:31:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atco10000a4e3o8fozl3x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"系统集成项目管理工程师 - System integrated project management engineer","p":"itpmp/lesson1","date":"2018-01-04T09:35:09.000Z","description":"Information Technology Project Management Professional","_content":"\n** 背景\n\n很多朋友需要两个月时间拿下软考中“系统集成项目管理工程师”的考试，笔者通过两个月每天五小时的复习，顺利通过了考试，相信你也可以。这两个月需要对自己狠一点，丝毫不要放松。\n\n** 一、弄清重点\n\n计算题\n------\n计算题是下午的必考试题，分值约在15-20分，保证计算题不丢分，下午过关不会有问题。计算题主要集中在进度和成本2个方面，详细的介绍请看本公众号文章“一起复习系统集成项目管理工程师考试——计算题1”，另发送“中项”可获取笔者准备的相关复习资料。\n\n必考题\n------\n必考知识点主要包括：软件集成的特点、监理的职责、资质管理、楼宇布线工程、软件开发技术、计算机及网络基础知识、机房工程知识、计算机术语的英文等。\n\n重要知识点\n------\n变更管理的基本过程、典型的信息系统项目的生命周期模型（瀑布、V、原型化、螺旋、迭代）、项目进度管理关键路径（前导图法PDM、箭线图法ADM、活动时间期望值=(乐观+4个正常+悲观/6)）、项目成本管理（CV,SV,CPI,SPI,EAC,ETC,成本超支时采取什么措施？进度落后时采取什么措施？）\n\n** 二、心法\n       时间紧，所以大部头的教程无法逐页细看了。我在做题时，遇到无法理解的地方，就去教程相应章节找找答案，看看定义和公式，仅此而已。更详细的心法请看本公众号文章“通过系统集成项目管理工程师考试——我是这样做到的 ”，以下为建议的复习计划，供大家参考：\n建立解题思路\n有清晰解题思路的朋友可以跳过此小点。如果对解题思路没有把握的，建议看看“真题解析”相关教程，主要是学习正规的解题思路。我当时看了2套真题解析就建立了解题思路，并对考点有了基本的了解，做到了“分清主次”“见题不慌”。此阶段估计会耗时半个月时间。\n练习历年真题\n找出2009年以来的10套真题，扎扎实实做一遍，重点部分一定要理解，不懂就主动翻看教程。对于易错的题目，作好标记，用于第二遍复习，一看就会做的题目下次不必再看。对于自己不熟悉易忘的知识点，可以总结成文档，打印出来，没事就拿出来看。此阶段估计耗时一个月，最难熬，笔者有时会做题到凌晨2点。\n查漏补缺\n通过前2个阶段的扎实准备，此时相信你对这个考试的框架比较熟悉，更重要的是你对自己的弱项在哪里做到了然于胸了。剩下的半个月着重看自己做错的题目，看自己记录的重要知识点，将经典计算题再做一遍，看看那些公式。笔者当时连公交车、WC时间、吃饭时间都用来看打印的小抄。\n轻装上阵\n靠前一两天就放松一下，认认考场路线，准备考试用具，备好身份证、准考证。考前一晚早些休息，次日轻装上阵迎接考试。考试过程中把握“先易后难”，遇难莫慌，慌了就深呼吸，英语差的朋友对于最后五道英语题可以采取“4A1B”这样的答案……\n\n** 三、分数分布\n    1.专业英语5分\n    2.项目管理知识37分\n    3.法律法规及相关标准11分\n    4.信息系统工程监理5分\n    5.软件工程知识5分\n    6.计算机技术知识与网络知识7分\n    7.信息系统建设5分\n\n** 四、关于中项考试\n考试时间软考考试分为上半年和下半年,每年5月份和11月份。科目单次时间为2小时。\n考试题型考试分为上午和下午,上午75道选择题,下午5个问答题,各75分,同时通过45分者为合格。\n考试时,考前一周打印准考证,注意,该准考证只能在规定的时间内打印,防止当天丢掉,最好将准考证电子档存在邮箱里,以防丢失时,及时打印。特别注意,考试通过后,去领取证书的时候,需携带准考证、身份证领取方可领取。","source":"_posts/itpmp/lesson1.md","raw":"---\ntitle: 系统集成项目管理工程师 - System integrated project management engineer\np: itpmp/lesson1\ndate: 2018-01-04 17:35:09\ntags: ITPMP\ndescription: Information Technology Project Management Professional\n---\n\n** 背景\n\n很多朋友需要两个月时间拿下软考中“系统集成项目管理工程师”的考试，笔者通过两个月每天五小时的复习，顺利通过了考试，相信你也可以。这两个月需要对自己狠一点，丝毫不要放松。\n\n** 一、弄清重点\n\n计算题\n------\n计算题是下午的必考试题，分值约在15-20分，保证计算题不丢分，下午过关不会有问题。计算题主要集中在进度和成本2个方面，详细的介绍请看本公众号文章“一起复习系统集成项目管理工程师考试——计算题1”，另发送“中项”可获取笔者准备的相关复习资料。\n\n必考题\n------\n必考知识点主要包括：软件集成的特点、监理的职责、资质管理、楼宇布线工程、软件开发技术、计算机及网络基础知识、机房工程知识、计算机术语的英文等。\n\n重要知识点\n------\n变更管理的基本过程、典型的信息系统项目的生命周期模型（瀑布、V、原型化、螺旋、迭代）、项目进度管理关键路径（前导图法PDM、箭线图法ADM、活动时间期望值=(乐观+4个正常+悲观/6)）、项目成本管理（CV,SV,CPI,SPI,EAC,ETC,成本超支时采取什么措施？进度落后时采取什么措施？）\n\n** 二、心法\n       时间紧，所以大部头的教程无法逐页细看了。我在做题时，遇到无法理解的地方，就去教程相应章节找找答案，看看定义和公式，仅此而已。更详细的心法请看本公众号文章“通过系统集成项目管理工程师考试——我是这样做到的 ”，以下为建议的复习计划，供大家参考：\n建立解题思路\n有清晰解题思路的朋友可以跳过此小点。如果对解题思路没有把握的，建议看看“真题解析”相关教程，主要是学习正规的解题思路。我当时看了2套真题解析就建立了解题思路，并对考点有了基本的了解，做到了“分清主次”“见题不慌”。此阶段估计会耗时半个月时间。\n练习历年真题\n找出2009年以来的10套真题，扎扎实实做一遍，重点部分一定要理解，不懂就主动翻看教程。对于易错的题目，作好标记，用于第二遍复习，一看就会做的题目下次不必再看。对于自己不熟悉易忘的知识点，可以总结成文档，打印出来，没事就拿出来看。此阶段估计耗时一个月，最难熬，笔者有时会做题到凌晨2点。\n查漏补缺\n通过前2个阶段的扎实准备，此时相信你对这个考试的框架比较熟悉，更重要的是你对自己的弱项在哪里做到了然于胸了。剩下的半个月着重看自己做错的题目，看自己记录的重要知识点，将经典计算题再做一遍，看看那些公式。笔者当时连公交车、WC时间、吃饭时间都用来看打印的小抄。\n轻装上阵\n靠前一两天就放松一下，认认考场路线，准备考试用具，备好身份证、准考证。考前一晚早些休息，次日轻装上阵迎接考试。考试过程中把握“先易后难”，遇难莫慌，慌了就深呼吸，英语差的朋友对于最后五道英语题可以采取“4A1B”这样的答案……\n\n** 三、分数分布\n    1.专业英语5分\n    2.项目管理知识37分\n    3.法律法规及相关标准11分\n    4.信息系统工程监理5分\n    5.软件工程知识5分\n    6.计算机技术知识与网络知识7分\n    7.信息系统建设5分\n\n** 四、关于中项考试\n考试时间软考考试分为上半年和下半年,每年5月份和11月份。科目单次时间为2小时。\n考试题型考试分为上午和下午,上午75道选择题,下午5个问答题,各75分,同时通过45分者为合格。\n考试时,考前一周打印准考证,注意,该准考证只能在规定的时间内打印,防止当天丢掉,最好将准考证电子档存在邮箱里,以防丢失时,及时打印。特别注意,考试通过后,去领取证书的时候,需携带准考证、身份证领取方可领取。","slug":"itpmp/lesson1","published":1,"updated":"2018-01-04T09:37:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcoy0002a4e395bnyybg","content":"<p>** 背景</p>\n<p>很多朋友需要两个月时间拿下软考中“系统集成项目管理工程师”的考试，笔者通过两个月每天五小时的复习，顺利通过了考试，相信你也可以。这两个月需要对自己狠一点，丝毫不要放松。</p>\n<p>** 一、弄清重点</p>\n<h2 id=\"计算题\"><a href=\"#计算题\" class=\"headerlink\" title=\"计算题\"></a>计算题</h2><p>计算题是下午的必考试题，分值约在15-20分，保证计算题不丢分，下午过关不会有问题。计算题主要集中在进度和成本2个方面，详细的介绍请看本公众号文章“一起复习系统集成项目管理工程师考试——计算题1”，另发送“中项”可获取笔者准备的相关复习资料。</p>\n<h2 id=\"必考题\"><a href=\"#必考题\" class=\"headerlink\" title=\"必考题\"></a>必考题</h2><p>必考知识点主要包括：软件集成的特点、监理的职责、资质管理、楼宇布线工程、软件开发技术、计算机及网络基础知识、机房工程知识、计算机术语的英文等。</p>\n<h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>变更管理的基本过程、典型的信息系统项目的生命周期模型（瀑布、V、原型化、螺旋、迭代）、项目进度管理关键路径（前导图法PDM、箭线图法ADM、活动时间期望值=(乐观+4个正常+悲观/6)）、项目成本管理（CV,SV,CPI,SPI,EAC,ETC,成本超支时采取什么措施？进度落后时采取什么措施？）</p>\n<p>** 二、心法<br>       时间紧，所以大部头的教程无法逐页细看了。我在做题时，遇到无法理解的地方，就去教程相应章节找找答案，看看定义和公式，仅此而已。更详细的心法请看本公众号文章“通过系统集成项目管理工程师考试——我是这样做到的 ”，以下为建议的复习计划，供大家参考：<br>建立解题思路<br>有清晰解题思路的朋友可以跳过此小点。如果对解题思路没有把握的，建议看看“真题解析”相关教程，主要是学习正规的解题思路。我当时看了2套真题解析就建立了解题思路，并对考点有了基本的了解，做到了“分清主次”“见题不慌”。此阶段估计会耗时半个月时间。<br>练习历年真题<br>找出2009年以来的10套真题，扎扎实实做一遍，重点部分一定要理解，不懂就主动翻看教程。对于易错的题目，作好标记，用于第二遍复习，一看就会做的题目下次不必再看。对于自己不熟悉易忘的知识点，可以总结成文档，打印出来，没事就拿出来看。此阶段估计耗时一个月，最难熬，笔者有时会做题到凌晨2点。<br>查漏补缺<br>通过前2个阶段的扎实准备，此时相信你对这个考试的框架比较熟悉，更重要的是你对自己的弱项在哪里做到了然于胸了。剩下的半个月着重看自己做错的题目，看自己记录的重要知识点，将经典计算题再做一遍，看看那些公式。笔者当时连公交车、WC时间、吃饭时间都用来看打印的小抄。<br>轻装上阵<br>靠前一两天就放松一下，认认考场路线，准备考试用具，备好身份证、准考证。考前一晚早些休息，次日轻装上阵迎接考试。考试过程中把握“先易后难”，遇难莫慌，慌了就深呼吸，英语差的朋友对于最后五道英语题可以采取“4A1B”这样的答案……</p>\n<p>** 三、分数分布<br>    1.专业英语5分<br>    2.项目管理知识37分<br>    3.法律法规及相关标准11分<br>    4.信息系统工程监理5分<br>    5.软件工程知识5分<br>    6.计算机技术知识与网络知识7分<br>    7.信息系统建设5分</p>\n<p>** 四、关于中项考试<br>考试时间软考考试分为上半年和下半年,每年5月份和11月份。科目单次时间为2小时。<br>考试题型考试分为上午和下午,上午75道选择题,下午5个问答题,各75分,同时通过45分者为合格。<br>考试时,考前一周打印准考证,注意,该准考证只能在规定的时间内打印,防止当天丢掉,最好将准考证电子档存在邮箱里,以防丢失时,及时打印。特别注意,考试通过后,去领取证书的时候,需携带准考证、身份证领取方可领取。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>** 背景</p>\n<p>很多朋友需要两个月时间拿下软考中“系统集成项目管理工程师”的考试，笔者通过两个月每天五小时的复习，顺利通过了考试，相信你也可以。这两个月需要对自己狠一点，丝毫不要放松。</p>\n<p>** 一、弄清重点</p>\n<h2 id=\"计算题\"><a href=\"#计算题\" class=\"headerlink\" title=\"计算题\"></a>计算题</h2><p>计算题是下午的必考试题，分值约在15-20分，保证计算题不丢分，下午过关不会有问题。计算题主要集中在进度和成本2个方面，详细的介绍请看本公众号文章“一起复习系统集成项目管理工程师考试——计算题1”，另发送“中项”可获取笔者准备的相关复习资料。</p>\n<h2 id=\"必考题\"><a href=\"#必考题\" class=\"headerlink\" title=\"必考题\"></a>必考题</h2><p>必考知识点主要包括：软件集成的特点、监理的职责、资质管理、楼宇布线工程、软件开发技术、计算机及网络基础知识、机房工程知识、计算机术语的英文等。</p>\n<h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>变更管理的基本过程、典型的信息系统项目的生命周期模型（瀑布、V、原型化、螺旋、迭代）、项目进度管理关键路径（前导图法PDM、箭线图法ADM、活动时间期望值=(乐观+4个正常+悲观/6)）、项目成本管理（CV,SV,CPI,SPI,EAC,ETC,成本超支时采取什么措施？进度落后时采取什么措施？）</p>\n<p>** 二、心法<br>       时间紧，所以大部头的教程无法逐页细看了。我在做题时，遇到无法理解的地方，就去教程相应章节找找答案，看看定义和公式，仅此而已。更详细的心法请看本公众号文章“通过系统集成项目管理工程师考试——我是这样做到的 ”，以下为建议的复习计划，供大家参考：<br>建立解题思路<br>有清晰解题思路的朋友可以跳过此小点。如果对解题思路没有把握的，建议看看“真题解析”相关教程，主要是学习正规的解题思路。我当时看了2套真题解析就建立了解题思路，并对考点有了基本的了解，做到了“分清主次”“见题不慌”。此阶段估计会耗时半个月时间。<br>练习历年真题<br>找出2009年以来的10套真题，扎扎实实做一遍，重点部分一定要理解，不懂就主动翻看教程。对于易错的题目，作好标记，用于第二遍复习，一看就会做的题目下次不必再看。对于自己不熟悉易忘的知识点，可以总结成文档，打印出来，没事就拿出来看。此阶段估计耗时一个月，最难熬，笔者有时会做题到凌晨2点。<br>查漏补缺<br>通过前2个阶段的扎实准备，此时相信你对这个考试的框架比较熟悉，更重要的是你对自己的弱项在哪里做到了然于胸了。剩下的半个月着重看自己做错的题目，看自己记录的重要知识点，将经典计算题再做一遍，看看那些公式。笔者当时连公交车、WC时间、吃饭时间都用来看打印的小抄。<br>轻装上阵<br>靠前一两天就放松一下，认认考场路线，准备考试用具，备好身份证、准考证。考前一晚早些休息，次日轻装上阵迎接考试。考试过程中把握“先易后难”，遇难莫慌，慌了就深呼吸，英语差的朋友对于最后五道英语题可以采取“4A1B”这样的答案……</p>\n<p>** 三、分数分布<br>    1.专业英语5分<br>    2.项目管理知识37分<br>    3.法律法规及相关标准11分<br>    4.信息系统工程监理5分<br>    5.软件工程知识5分<br>    6.计算机技术知识与网络知识7分<br>    7.信息系统建设5分</p>\n<p>** 四、关于中项考试<br>考试时间软考考试分为上半年和下半年,每年5月份和11月份。科目单次时间为2小时。<br>考试题型考试分为上午和下午,上午75道选择题,下午5个问答题,各75分,同时通过45分者为合格。<br>考试时,考前一周打印准考证,注意,该准考证只能在规定的时间内打印,防止当天丢掉,最好将准考证电子档存在邮箱里,以防丢失时,及时打印。特别注意,考试通过后,去领取证书的时候,需携带准考证、身份证领取方可领取。</p>\n"},{"title":"Git使用基础教程","p":"git/how-to-use-git","date":"2017-12-27T12:45:44.000Z","_content":"\n## 目录\n\n一：Git是什么?\n二：SVN与Git的最主要的区别?\n三：在windows上如何安装Git?\n四：如何操作？\n五：远程仓库\n六：创建与合并分支\n七：bug分支\n八：多人协作\n\n### 一：Git是什么？\nGit是目前世界上最先进的分布式版本控制系统。\n工作原理 / 流程：\n\n![](http://img.mukewang.com/59c31e4400013bc911720340.png)\n\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n### 二：SVN与Git的最主要的区别？\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。\n\nGit是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n### 三、在windows上如何安装Git？\n\nmsysgit是 windows版的Git,如下：\n\n![](http://img.mukewang.com/59c1cfa400019aee02460029.jpg)\n\n需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 \"Git --> Git Bash\",如下：\n\n![](http://img.mukewang.com/59c1cfd20001c2d602530073.jpg)\n\n会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：\n\n![](http://img.mukewang.com/59c1cfe70001462e06680380.jpg)\n\n安装完成后，还需要最后一步设置，在命令行输入如下：\n\n![](http://img.mukewang.com/59c1d041000110d906460213.jpg)\n\n因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。\n\n注意：git config --global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。\n\n### 四：如何操作？\n\n#### 一：创建版本库。\n\n什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。\n\n所以创建一个版本库也非常简单，如下我是D盘 –> www下 目录下新建一个testgit版本库。\n\n![](http://img.mukewang.com/59c1d1060001909005780268.png)\n\npwd 命令是用于显示当前的目录。\n\n通过命令 git init 把这个目录变成git可以管理的仓库，如下：\n\n![](http://img.mukewang.com/59c1d12b0001b08305270077.png)\n\n这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：\n\n![](http://img.mukewang.com/59c1d143000112df06120173.png)\n\n把文件添加到版本库中。\n\n首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。\n\n下面先看下demo如下演示：\n---\n我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111\n\n第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：\n\n![](http://img.mukewang.com/59c1d2080001e4bb04490080.png)\n\n如果和上面一样，没有任何提示，说明已经添加成功了。\n\n第二步：用命令 git commit告诉Git，把文件提交到仓库。\n\n![](http://img.mukewang.com/59c1d2200001f05b04930121.png)\n\n现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：\n\n![](http://img.mukewang.com/59c1d2340001a87904690107.png)\n\n说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：\n\n![](http://img.mukewang.com/59c1d2500001634606170171.png)\n\n上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。\n接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：\ngit diff readme.txt 如下：\n\n![](http://img.mukewang.com/59c1d2cb00010a0304960202.png)\n\n如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。\n\n知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。\n\n如下：\n![](http://img.mukewang.com/59c1d2ff00015a9606180342.png)\n\n### 二：版本回退：\n\n如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行\n\n内容为33333333333333.继续执行命令如下：\n\n![](http://img.mukewang.com/59c1d32b00012ba604570139.png)\n\n现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：\n\n![](http://img.mukewang.com/59c1d34e0001a1ac06050304.png)\n\ngit log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：\n\n![](http://img.mukewang.com/59c1d3fc00013ad206040097.png)\n\n现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。未回退之前的readme.txt内容如下：\n\n![](http://img.mukewang.com/59c1d4140001a0c404490165.png)\n\n如果想回退到上一个版本的命令如下操作：\n\n![](http://img.mukewang.com/59c1d429000199fc04610105.png)\n\n再来查看下 readme.txt内容如下：通过命令cat readme.txt查看\n\n![](http://img.mukewang.com/59c1d4470001fcdc04360085.png)\n\n可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：\n\n![](http://img.mukewang.com/59c1d45300012d9604800219.png)\n\n我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：\ngit reset --hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：\n\n![](http://img.mukewang.com/59c1d51a0001d5fc05100122.png)\n\n通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令\ngit reset --hard 6fcfc89来恢复了。演示如下：\n\n![](http://img.mukewang.com/59c1d53a0001b8b305050153.png)\n\n可以看到 目前已经是最新的版本了。\n\n### 三：理解工作区与暂存区的区别？\n\n工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。\n\n版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。\n\n我们前面说过使用Git提交文件到版本库有两步：\n\n第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。\n\n第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。\n\n我们继续使用demo来演示下：\n\n我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：\n\n![](http://img.mukewang.com/59c1d55a0001a3c306430241.png)\n\n现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：\n\n![](http://img.mukewang.com/59c1d56a0001a28704700241.png)\n\n接着我们可以使用git commit一次性提交到分支上，如下：\n\n![](http://img.mukewang.com/59c1d57b0001b4fe06190166.png)\n\n### 四：Git撤销修改和删除文件操作。\n\n#### 一：撤销修改：\n\n比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：\n\n![](http://img.mukewang.com/59c1d5e40001806803930139.png)\n\n在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：\n\n第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。\n\n第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset --hard HEAD^\n\n但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：\n\n![](http://img.mukewang.com/59c1d5fa0001b07806400168.png)\n\n可以发现，Git会告诉你，git checkout -- file 可以丢弃工作区的修改，如下命令：\ngit checkout -- readme.txt,如下所示：\n\n![](http://img.mukewang.com/59c1d6390001419705210140.png)\n\n命令 git checkout --readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：\n\n1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。\n\n2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。\n\n对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：\n\n![](http://img.mukewang.com/59c1d6ca0001782f06160482.png)\n\n注意：命令git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。\n\n#### 二：删除文件。\n\n假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：\n\n![](http://img.mukewang.com/59c1d6de0001a31606390392.png)\n\n如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，\n\n![](http://img.mukewang.com/59c1d78200017e8f07030192.png)\n\n只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？\n可以使用如下命令 git checkout -- b.txt，如下所示：\n\n![](http://img.mukewang.com/59c1d7980001368e05570244.png)\n\n再来看看我们testgit目录，添加了3个文件了。如下所示：\n\n![](http://img.mukewang.com/59c1d7b70001308907550258.png)\n\n### 五：远程仓库。\n\n在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：\n\n第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：\n\nssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：\n\n![](http://img.mukewang.com/59c1d7d7000120d107530169.png)\n\nid_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。\n\n![](http://img.mukewang.com/59c1d7ef0001c75411330860.png)\n\n点击 Add Key，你就应该可以看到已经添加的key。\n\n![](http://img.mukewang.com/59c1d8540001eb3707620373.png)\n\n如何添加远程库？\n\n现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。\n\n首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：\n\n![](http://img.mukewang.com/59c1d86a0001044b10840605.png)\n\n在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![](http://img.mukewang.com/59c1d8850001b5ea10260661.png)\n\n目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：\n``` \ngit remote add origin https://github.com/tugenhua0707/testgit.git\n```\n\n所有的如下：\n\n![](http://img.mukewang.com/59c1d8a70001c86206320252.png)\n\n把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：\n\n![](http://img.mukewang.com/59c1d8bb00019ff310480655.png)\n\n从现在起，只要本地作了提交，就可以通过如下命令：\n\n    git push origin master\n\n把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。\n\n\n#### 如何从远程库克隆？\n上面我们了解了先有本地库，后有远程库时候，如何关联远程库。\n现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？\n首先，登录github，创建一个新的仓库，名字叫testgit2.如下：\n\n![](http://img.mukewang.com/59c1d95e0001f0fc10450604.png)\n\n如下，我们看到：\n\n![](http://img.mukewang.com/59c1d97400014d4e10360484.png)\n\n现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：\n\n![](http://img.mukewang.com/59c1d9860001e0d806370127.png)\n\n接着在我本地目录下 生成testgit2目录了，如下所示：\n\n![](http://img.mukewang.com/59c1d99500016a2e07130197.png)\n\n### 六：创建与合并分支。\n在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n首先，我们来创建dev分支，然后切换到dev分支上。如下操作：\n\n![](http://img.mukewang.com/59c1d9aa0001c15604080167.png)\n\ngit checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令\ngit branch dev\ngit checkout dev\ngit branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777\n首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：\n\n![](http://img.mukewang.com/59c1da3f0001b5b703890392.png)\n\n现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：\n\n![](http://img.mukewang.com/59c1da520001d44c06340206.png)\n\n现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：\n\n![](http://img.mukewang.com/59c1da69000145ca05320255.png)\n\ngit merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n合并完成后，我们可以接着删除dev分支了，操作如下：\n\n![](http://img.mukewang.com/59c1da91000120cd06430139.png)\n\n总结创建与合并分支命令如下：\n查看分支：git branch\n创建分支：git branch name\n切换分支：git checkout name\n创建+切换分支：git checkout –b name\n合并某分支到当前分支：git merge name\n删除分支：git branch –d name\n如何解决冲突？\n下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：\n\n![](http://img.mukewang.com/59c1db410001036105690462.png)\n\n同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：\n\n![](http://img.mukewang.com/59c1daaf0001133205840500.png)\n\n现在我们需要在master分支上来合并fenzhi1，如下操作：\n\n![](http://img.mukewang.com/59c1daff000106eb06340589.png)\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<<HEAD是指主分支修改的内容，>>>>>fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：\n\n![](http://img.mukewang.com/59c1dbaf00015f2205770266.png)\n\n如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：\n\n![](http://img.mukewang.com/59c1dbc50001076c04970869.png)\n\n## 3.分支管理策略。 \n\n通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：\n\n创建一个dev分支。\n修改readme.txt内容。\n添加到暂存区。\n切换回主分支(master)。\n合并dev分支，使用命令 git merge –no-ff -m “注释” dev\n查看历史记录\n截图如下：\n\n![](http://img.mukewang.com/59c1dbdc0001836d06030780.png)\n\n分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。\n\n#### 七：bug分支：\n\n在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。\n\n比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：\n\n![](http://img.mukewang.com/59c1dc4e000141b306260166.png)\n\n并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：\n\n![](http://img.mukewang.com/59c1dc63000121ff06510188.png)\n\n所以现在我可以通过创建issue-404分支来修复bug了。\n首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：\n\n![](http://img.mukewang.com/59c1dc7000010f8506010533.png)\n\n修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：\n\n![](http://img.mukewang.com/59c1dce00001c1ed06120441.png)\n\n现在，我们回到dev分支上干活了。\n\n![](http://img.mukewang.com/59c1dcfa00019c8104220136.png)\n\n工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：\n\n![](http://img.mukewang.com/59c1dd07000152b404340093.png)\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：\n\n1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。\n\n2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。\n\n演示如下\n![](http://img.mukewang.com/59c1dd1f000174d406380466.png)\n\n### 八：多人协作。\n当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。\n要查看远程库的信息 使用 git remote\n要查看远程库的详细信息 使用 git remote –v\n\n如下演示：\n\n![](http://img.mukewang.com/59c1dd7d000136fd06190169.png)\n\n### 一：推送分支：\n\n推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n使用命令 git push origin master\n\n比如我现在的github上的readme.txt代码如下：\n\n![](http://img.mukewang.com/59c1dd90000164a508280459.png)\n\n本地的readme.txt代码如下：\n\n![](http://img.mukewang.com/59c1dda60001771804210205.png)\n\n现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：\n\n![](http://img.mukewang.com/59c1ddbf0001271e05410203.png)\n\n我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：\n\n![](http://img.mukewang.com/59c1ddcf0001771f08100484.png)\n\n可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev\n那么一般情况下，那些分支要推送呢？\nmaster分支是主分支，因此要时刻与远程同步。\n一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。\n\n二：抓取分支：\n多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2\n但是我首先要把dev分支也要推送到远程去，如下\n\n![](http://img.mukewang.com/59c1ded800014adf05030151.jpg)\n\n接着进入testgit2目录，进行克隆远程的库到本地来，如下：\n\n![](http://img.mukewang.com/59c1deb70001ec7605080170.png)\n\n现在目录下生成有如下所示：\n\n![](http://img.mukewang.com/59c1defe0001942707180256.png)\n\n现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev\n\n现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。\n\n如下：\n\n![](http://img.mukewang.com/59c1df160001ef1e06020730.png)\n\n小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：\n\n![](http://img.mukewang.com/59c1df340001209306470759.png)\n\n由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。\n\n![](http://img.mukewang.com/59c1dfa60001473e05940282.png)\n\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：\n\n![](http://img.mukewang.com/59c1dfc8000159c106460199.png)\n\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：\n我们可以先来看看readme.txt内容了。\n\n![](http://img.mukewang.com/59c1dff70001a87605190277.png)\n\n现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：\n\n![](http://img.mukewang.com/59c1e0130001843906050480.png)\n\n因此：多人协作工作模式一般是这样的：\n首先，可以试图用git push origin branch-name推送自己的修改.\n如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。\n如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。\n","source":"_posts/git/how-to-use-git.md","raw":"---\ntitle: Git使用基础教程\np: git/how-to-use-git\ndate: 2017-12-27 20:45:44\ntags: [git]\n---\n\n## 目录\n\n一：Git是什么?\n二：SVN与Git的最主要的区别?\n三：在windows上如何安装Git?\n四：如何操作？\n五：远程仓库\n六：创建与合并分支\n七：bug分支\n八：多人协作\n\n### 一：Git是什么？\nGit是目前世界上最先进的分布式版本控制系统。\n工作原理 / 流程：\n\n![](http://img.mukewang.com/59c31e4400013bc911720340.png)\n\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n### 二：SVN与Git的最主要的区别？\n\nSVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。\n\nGit是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。\n\n### 三、在windows上如何安装Git？\n\nmsysgit是 windows版的Git,如下：\n\n![](http://img.mukewang.com/59c1cfa400019aee02460029.jpg)\n\n需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 \"Git --> Git Bash\",如下：\n\n![](http://img.mukewang.com/59c1cfd20001c2d602530073.jpg)\n\n会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：\n\n![](http://img.mukewang.com/59c1cfe70001462e06680380.jpg)\n\n安装完成后，还需要最后一步设置，在命令行输入如下：\n\n![](http://img.mukewang.com/59c1d041000110d906460213.jpg)\n\n因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。\n\n注意：git config --global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。\n\n### 四：如何操作？\n\n#### 一：创建版本库。\n\n什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。\n\n所以创建一个版本库也非常简单，如下我是D盘 –> www下 目录下新建一个testgit版本库。\n\n![](http://img.mukewang.com/59c1d1060001909005780268.png)\n\npwd 命令是用于显示当前的目录。\n\n通过命令 git init 把这个目录变成git可以管理的仓库，如下：\n\n![](http://img.mukewang.com/59c1d12b0001b08305270077.png)\n\n这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：\n\n![](http://img.mukewang.com/59c1d143000112df06120173.png)\n\n把文件添加到版本库中。\n\n首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。\n\n下面先看下demo如下演示：\n---\n我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111\n\n第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：\n\n![](http://img.mukewang.com/59c1d2080001e4bb04490080.png)\n\n如果和上面一样，没有任何提示，说明已经添加成功了。\n\n第二步：用命令 git commit告诉Git，把文件提交到仓库。\n\n![](http://img.mukewang.com/59c1d2200001f05b04930121.png)\n\n现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：\n\n![](http://img.mukewang.com/59c1d2340001a87904690107.png)\n\n说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：\n\n![](http://img.mukewang.com/59c1d2500001634606170171.png)\n\n上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。\n接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：\ngit diff readme.txt 如下：\n\n![](http://img.mukewang.com/59c1d2cb00010a0304960202.png)\n\n如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。\n\n知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。\n\n如下：\n![](http://img.mukewang.com/59c1d2ff00015a9606180342.png)\n\n### 二：版本回退：\n\n如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行\n\n内容为33333333333333.继续执行命令如下：\n\n![](http://img.mukewang.com/59c1d32b00012ba604570139.png)\n\n现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：\n\n![](http://img.mukewang.com/59c1d34e0001a1ac06050304.png)\n\ngit log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：\n\n![](http://img.mukewang.com/59c1d3fc00013ad206040097.png)\n\n现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset --hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset --hard HEAD~100 即可。未回退之前的readme.txt内容如下：\n\n![](http://img.mukewang.com/59c1d4140001a0c404490165.png)\n\n如果想回退到上一个版本的命令如下操作：\n\n![](http://img.mukewang.com/59c1d429000199fc04610105.png)\n\n再来查看下 readme.txt内容如下：通过命令cat readme.txt查看\n\n![](http://img.mukewang.com/59c1d4470001fcdc04360085.png)\n\n可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：\n\n![](http://img.mukewang.com/59c1d45300012d9604800219.png)\n\n我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：\ngit reset --hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：\n\n![](http://img.mukewang.com/59c1d51a0001d5fc05100122.png)\n\n通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令\ngit reset --hard 6fcfc89来恢复了。演示如下：\n\n![](http://img.mukewang.com/59c1d53a0001b8b305050153.png)\n\n可以看到 目前已经是最新的版本了。\n\n### 三：理解工作区与暂存区的区别？\n\n工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。\n\n版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。\n\n我们前面说过使用Git提交文件到版本库有两步：\n\n第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。\n\n第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。\n\n我们继续使用demo来演示下：\n\n我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：\n\n![](http://img.mukewang.com/59c1d55a0001a3c306430241.png)\n\n现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：\n\n![](http://img.mukewang.com/59c1d56a0001a28704700241.png)\n\n接着我们可以使用git commit一次性提交到分支上，如下：\n\n![](http://img.mukewang.com/59c1d57b0001b4fe06190166.png)\n\n### 四：Git撤销修改和删除文件操作。\n\n#### 一：撤销修改：\n\n比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：\n\n![](http://img.mukewang.com/59c1d5e40001806803930139.png)\n\n在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：\n\n第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。\n\n第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset --hard HEAD^\n\n但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：\n\n![](http://img.mukewang.com/59c1d5fa0001b07806400168.png)\n\n可以发现，Git会告诉你，git checkout -- file 可以丢弃工作区的修改，如下命令：\ngit checkout -- readme.txt,如下所示：\n\n![](http://img.mukewang.com/59c1d6390001419705210140.png)\n\n命令 git checkout --readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：\n\n1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。\n\n2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。\n\n对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：\n\n![](http://img.mukewang.com/59c1d6ca0001782f06160482.png)\n\n注意：命令git checkout -- readme.txt 中的 -- 很重要，如果没有 -- 的话，那么命令变成创建分支了。\n\n#### 二：删除文件。\n\n假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：\n\n![](http://img.mukewang.com/59c1d6de0001a31606390392.png)\n\n如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，\n\n![](http://img.mukewang.com/59c1d78200017e8f07030192.png)\n\n只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？\n可以使用如下命令 git checkout -- b.txt，如下所示：\n\n![](http://img.mukewang.com/59c1d7980001368e05570244.png)\n\n再来看看我们testgit目录，添加了3个文件了。如下所示：\n\n![](http://img.mukewang.com/59c1d7b70001308907550258.png)\n\n### 五：远程仓库。\n\n在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：\n\n第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：\n\nssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：\n\n![](http://img.mukewang.com/59c1d7d7000120d107530169.png)\n\nid_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n\n第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。\n\n![](http://img.mukewang.com/59c1d7ef0001c75411330860.png)\n\n点击 Add Key，你就应该可以看到已经添加的key。\n\n![](http://img.mukewang.com/59c1d8540001eb3707620373.png)\n\n如何添加远程库？\n\n现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。\n\n首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：\n\n![](http://img.mukewang.com/59c1d86a0001044b10840605.png)\n\n在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n![](http://img.mukewang.com/59c1d8850001b5ea10260661.png)\n\n目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。\n\n现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：\n``` \ngit remote add origin https://github.com/tugenhua0707/testgit.git\n```\n\n所有的如下：\n\n![](http://img.mukewang.com/59c1d8a70001c86206320252.png)\n\n把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。\n\n由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：\n\n![](http://img.mukewang.com/59c1d8bb00019ff310480655.png)\n\n从现在起，只要本地作了提交，就可以通过如下命令：\n\n    git push origin master\n\n把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。\n\n\n#### 如何从远程库克隆？\n上面我们了解了先有本地库，后有远程库时候，如何关联远程库。\n现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？\n首先，登录github，创建一个新的仓库，名字叫testgit2.如下：\n\n![](http://img.mukewang.com/59c1d95e0001f0fc10450604.png)\n\n如下，我们看到：\n\n![](http://img.mukewang.com/59c1d97400014d4e10360484.png)\n\n现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：\n\n![](http://img.mukewang.com/59c1d9860001e0d806370127.png)\n\n接着在我本地目录下 生成testgit2目录了，如下所示：\n\n![](http://img.mukewang.com/59c1d99500016a2e07130197.png)\n\n### 六：创建与合并分支。\n在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。\n\n首先，我们来创建dev分支，然后切换到dev分支上。如下操作：\n\n![](http://img.mukewang.com/59c1d9aa0001c15604080167.png)\n\ngit checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令\ngit branch dev\ngit checkout dev\ngit branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777\n首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：\n\n![](http://img.mukewang.com/59c1da3f0001b5b703890392.png)\n\n现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：\n\n![](http://img.mukewang.com/59c1da520001d44c06340206.png)\n\n现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：\n\n![](http://img.mukewang.com/59c1da69000145ca05320255.png)\n\ngit merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。\n注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。\n合并完成后，我们可以接着删除dev分支了，操作如下：\n\n![](http://img.mukewang.com/59c1da91000120cd06430139.png)\n\n总结创建与合并分支命令如下：\n查看分支：git branch\n创建分支：git branch name\n切换分支：git checkout name\n创建+切换分支：git checkout –b name\n合并某分支到当前分支：git merge name\n删除分支：git branch –d name\n如何解决冲突？\n下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：\n\n![](http://img.mukewang.com/59c1db410001036105690462.png)\n\n同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：\n\n![](http://img.mukewang.com/59c1daaf0001133205840500.png)\n\n现在我们需要在master分支上来合并fenzhi1，如下操作：\n\n![](http://img.mukewang.com/59c1daff000106eb06340589.png)\n\nGit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，其中<<<HEAD是指主分支修改的内容，>>>>>fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：\n\n![](http://img.mukewang.com/59c1dbaf00015f2205770266.png)\n\n如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：\n\n![](http://img.mukewang.com/59c1dbc50001076c04970869.png)\n\n## 3.分支管理策略。 \n\n通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：\n\n创建一个dev分支。\n修改readme.txt内容。\n添加到暂存区。\n切换回主分支(master)。\n合并dev分支，使用命令 git merge –no-ff -m “注释” dev\n查看历史记录\n截图如下：\n\n![](http://img.mukewang.com/59c1dbdc0001836d06030780.png)\n\n分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。\n\n#### 七：bug分支：\n\n在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。\n\n比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：\n\n![](http://img.mukewang.com/59c1dc4e000141b306260166.png)\n\n并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：\n\n![](http://img.mukewang.com/59c1dc63000121ff06510188.png)\n\n所以现在我可以通过创建issue-404分支来修复bug了。\n首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：\n\n![](http://img.mukewang.com/59c1dc7000010f8506010533.png)\n\n修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：\n\n![](http://img.mukewang.com/59c1dce00001c1ed06120441.png)\n\n现在，我们回到dev分支上干活了。\n\n![](http://img.mukewang.com/59c1dcfa00019c8104220136.png)\n\n工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：\n\n![](http://img.mukewang.com/59c1dd07000152b404340093.png)\n\n工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：\n\n1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。\n\n2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。\n\n演示如下\n![](http://img.mukewang.com/59c1dd1f000174d406380466.png)\n\n### 八：多人协作。\n当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。\n要查看远程库的信息 使用 git remote\n要查看远程库的详细信息 使用 git remote –v\n\n如下演示：\n\n![](http://img.mukewang.com/59c1dd7d000136fd06190169.png)\n\n### 一：推送分支：\n\n推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n使用命令 git push origin master\n\n比如我现在的github上的readme.txt代码如下：\n\n![](http://img.mukewang.com/59c1dd90000164a508280459.png)\n\n本地的readme.txt代码如下：\n\n![](http://img.mukewang.com/59c1dda60001771804210205.png)\n\n现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：\n\n![](http://img.mukewang.com/59c1ddbf0001271e05410203.png)\n\n我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：\n\n![](http://img.mukewang.com/59c1ddcf0001771f08100484.png)\n\n可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev\n那么一般情况下，那些分支要推送呢？\nmaster分支是主分支，因此要时刻与远程同步。\n一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。\n\n二：抓取分支：\n多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2\n但是我首先要把dev分支也要推送到远程去，如下\n\n![](http://img.mukewang.com/59c1ded800014adf05030151.jpg)\n\n接着进入testgit2目录，进行克隆远程的库到本地来，如下：\n\n![](http://img.mukewang.com/59c1deb70001ec7605080170.png)\n\n现在目录下生成有如下所示：\n\n![](http://img.mukewang.com/59c1defe0001942707180256.png)\n\n现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev\n\n现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。\n\n如下：\n\n![](http://img.mukewang.com/59c1df160001ef1e06020730.png)\n\n小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：\n\n![](http://img.mukewang.com/59c1df340001209306470759.png)\n\n由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。\n\n![](http://img.mukewang.com/59c1dfa60001473e05940282.png)\n\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：\n\n![](http://img.mukewang.com/59c1dfc8000159c106460199.png)\n\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：\n我们可以先来看看readme.txt内容了。\n\n![](http://img.mukewang.com/59c1dff70001a87605190277.png)\n\n现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：\n\n![](http://img.mukewang.com/59c1e0130001843906050480.png)\n\n因此：多人协作工作模式一般是这样的：\n首先，可以试图用git push origin branch-name推送自己的修改.\n如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。\n如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。\n","slug":"git/how-to-use-git","published":1,"updated":"2017-12-27T14:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcoz0003a4e332qb290x","content":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>一：Git是什么?<br>二：SVN与Git的最主要的区别?<br>三：在windows上如何安装Git?<br>四：如何操作？<br>五：远程仓库<br>六：创建与合并分支<br>七：bug分支<br>八：多人协作</p>\n<h3 id=\"一：Git是什么？\"><a href=\"#一：Git是什么？\" class=\"headerlink\" title=\"一：Git是什么？\"></a>一：Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。<br>工作原理 / 流程：</p>\n<p><img src=\"http://img.mukewang.com/59c31e4400013bc911720340.png\" alt=\"\"></p>\n<p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>\n<h3 id=\"二：SVN与Git的最主要的区别？\"><a href=\"#二：SVN与Git的最主要的区别？\" class=\"headerlink\" title=\"二：SVN与Git的最主要的区别？\"></a>二：SVN与Git的最主要的区别？</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>\n<p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>\n<h3 id=\"三、在windows上如何安装Git？\"><a href=\"#三、在windows上如何安装Git？\" class=\"headerlink\" title=\"三、在windows上如何安装Git？\"></a>三、在windows上如何安装Git？</h3><p>msysgit是 windows版的Git,如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfa400019aee02460029.jpg\" alt=\"\"></p>\n<p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfd20001c2d602530073.jpg\" alt=\"\"></p>\n<p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfe70001462e06680380.jpg\" alt=\"\"></p>\n<p>安装完成后，还需要最后一步设置，在命令行输入如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d041000110d906460213.jpg\" alt=\"\"></p>\n<p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>\n<p>注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>\n<h3 id=\"四：如何操作？\"><a href=\"#四：如何操作？\" class=\"headerlink\" title=\"四：如何操作？\"></a>四：如何操作？</h3><h4 id=\"一：创建版本库。\"><a href=\"#一：创建版本库。\" class=\"headerlink\" title=\"一：创建版本库。\"></a>一：创建版本库。</h4><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p>\n<p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p>\n<p><img src=\"http://img.mukewang.com/59c1d1060001909005780268.png\" alt=\"\"></p>\n<p>pwd 命令是用于显示当前的目录。</p>\n<p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d12b0001b08305270077.png\" alt=\"\"></p>\n<p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d143000112df06120173.png\" alt=\"\"></p>\n<p>把文件添加到版本库中。</p>\n<p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p>\n<h2 id=\"下面先看下demo如下演示：\"><a href=\"#下面先看下demo如下演示：\" class=\"headerlink\" title=\"下面先看下demo如下演示：\"></a>下面先看下demo如下演示：</h2><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p>\n<p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2080001e4bb04490080.png\" alt=\"\"></p>\n<p>如果和上面一样，没有任何提示，说明已经添加成功了。</p>\n<p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p>\n<p><img src=\"http://img.mukewang.com/59c1d2200001f05b04930121.png\" alt=\"\"></p>\n<p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2340001a87904690107.png\" alt=\"\"></p>\n<p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2500001634606170171.png\" alt=\"\"></p>\n<p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。<br>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：<br>git diff readme.txt 如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2cb00010a0304960202.png\" alt=\"\"></p>\n<p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p>\n<p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p>\n<p>如下：<br><img src=\"http://img.mukewang.com/59c1d2ff00015a9606180342.png\" alt=\"\"></p>\n<h3 id=\"二：版本回退：\"><a href=\"#二：版本回退：\" class=\"headerlink\" title=\"二：版本回退：\"></a>二：版本回退：</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p>\n<p>内容为33333333333333.继续执行命令如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d32b00012ba604570139.png\" alt=\"\"></p>\n<p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d34e0001a1ac06050304.png\" alt=\"\"></p>\n<p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d3fc00013ad206040097.png\" alt=\"\"></p>\n<p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d4140001a0c404490165.png\" alt=\"\"></p>\n<p>如果想回退到上一个版本的命令如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1d429000199fc04610105.png\" alt=\"\"></p>\n<p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p>\n<p><img src=\"http://img.mukewang.com/59c1d4470001fcdc04360085.png\" alt=\"\"></p>\n<p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d45300012d9604800219.png\" alt=\"\"></p>\n<p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：<br>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d51a0001d5fc05100122.png\" alt=\"\"></p>\n<p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令<br>git reset –hard 6fcfc89来恢复了。演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d53a0001b8b305050153.png\" alt=\"\"></p>\n<p>可以看到 目前已经是最新的版本了。</p>\n<h3 id=\"三：理解工作区与暂存区的区别？\"><a href=\"#三：理解工作区与暂存区的区别？\" class=\"headerlink\" title=\"三：理解工作区与暂存区的区别？\"></a>三：理解工作区与暂存区的区别？</h3><p>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p>\n<p>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p>\n<p>我们前面说过使用Git提交文件到版本库有两步：</p>\n<p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p>\n<p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p>\n<p>我们继续使用demo来演示下：</p>\n<p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d55a0001a3c306430241.png\" alt=\"\"></p>\n<p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d56a0001a28704700241.png\" alt=\"\"></p>\n<p>接着我们可以使用git commit一次性提交到分支上，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d57b0001b4fe06190166.png\" alt=\"\"></p>\n<h3 id=\"四：Git撤销修改和删除文件操作。\"><a href=\"#四：Git撤销修改和删除文件操作。\" class=\"headerlink\" title=\"四：Git撤销修改和删除文件操作。\"></a>四：Git撤销修改和删除文件操作。</h3><h4 id=\"一：撤销修改：\"><a href=\"#一：撤销修改：\" class=\"headerlink\" title=\"一：撤销修改：\"></a>一：撤销修改：</h4><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d5e40001806803930139.png\" alt=\"\"></p>\n<p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>\n<p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p>\n<p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p>\n<p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d5fa0001b07806400168.png\" alt=\"\"></p>\n<p>可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令：<br>git checkout – readme.txt,如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6390001419705210140.png\" alt=\"\"></p>\n<p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p>\n<p>1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</p>\n<p>2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</p>\n<p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6ca0001782f06160482.png\" alt=\"\"></p>\n<p>注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p>\n<h4 id=\"二：删除文件。\"><a href=\"#二：删除文件。\" class=\"headerlink\" title=\"二：删除文件。\"></a>二：删除文件。</h4><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6de0001a31606390392.png\" alt=\"\"></p>\n<p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p>\n<p><img src=\"http://img.mukewang.com/59c1d78200017e8f07030192.png\" alt=\"\"></p>\n<p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？<br>可以使用如下命令 git checkout – b.txt，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7980001368e05570244.png\" alt=\"\"></p>\n<p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7b70001308907550258.png\" alt=\"\"></p>\n<h3 id=\"五：远程仓库。\"><a href=\"#五：远程仓库。\" class=\"headerlink\" title=\"五：远程仓库。\"></a>五：远程仓库。</h3><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p>\n<p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p>\n<p>ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7d7000120d107530169.png\" alt=\"\"></p>\n<p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p>\n<p><img src=\"http://img.mukewang.com/59c1d7ef0001c75411330860.png\" alt=\"\"></p>\n<p>点击 Add Key，你就应该可以看到已经添加的key。</p>\n<p><img src=\"http://img.mukewang.com/59c1d8540001eb3707620373.png\" alt=\"\"></p>\n<p>如何添加远程库？</p>\n<p>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p>\n<p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d86a0001044b10840605.png\" alt=\"\"></p>\n<p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8850001b5ea10260661.png\" alt=\"\"></p>\n<p>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/tugenhua0707/testgit.git</span><br></pre></td></tr></table></figure></p>\n<p>所有的如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8a70001c86206320252.png\" alt=\"\"></p>\n<p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8bb00019ff310480655.png\" alt=\"\"></p>\n<p>从现在起，只要本地作了提交，就可以通过如下命令：</p>\n<pre><code>git push origin master\n</code></pre><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p>\n<h4 id=\"如何从远程库克隆？\"><a href=\"#如何从远程库克隆？\" class=\"headerlink\" title=\"如何从远程库克隆？\"></a>如何从远程库克隆？</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。<br>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？<br>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d95e0001f0fc10450604.png\" alt=\"\"></p>\n<p>如下，我们看到：</p>\n<p><img src=\"http://img.mukewang.com/59c1d97400014d4e10360484.png\" alt=\"\"></p>\n<p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d9860001e0d806370127.png\" alt=\"\"></p>\n<p>接着在我本地目录下 生成testgit2目录了，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d99500016a2e07130197.png\" alt=\"\"></p>\n<h3 id=\"六：创建与合并分支。\"><a href=\"#六：创建与合并分支。\" class=\"headerlink\" title=\"六：创建与合并分支。\"></a>六：创建与合并分支。</h3><p>在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>\n<p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1d9aa0001c15604080167.png\" alt=\"\"></p>\n<p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令<br>git branch dev<br>git checkout dev<br>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777<br>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da3f0001b5b703890392.png\" alt=\"\"></p>\n<p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da520001d44c06340206.png\" alt=\"\"></p>\n<p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1da69000145ca05320255.png\" alt=\"\"></p>\n<p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。<br>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。<br>合并完成后，我们可以接着删除dev分支了，操作如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da91000120cd06430139.png\" alt=\"\"></p>\n<p>总结创建与合并分支命令如下：<br>查看分支：git branch<br>创建分支：git branch name<br>切换分支：git checkout name<br>创建+切换分支：git checkout –b name<br>合并某分支到当前分支：git merge name<br>删除分支：git branch –d name<br>如何解决冲突？<br>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1db410001036105690462.png\" alt=\"\"></p>\n<p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1daaf0001133205840500.png\" alt=\"\"></p>\n<p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1daff000106eb06340589.png\" alt=\"\"></p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;<head是指主分支修改的内容，>&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</head是指主分支修改的内容，></p>\n<p><img src=\"http://img.mukewang.com/59c1dbaf00015f2205770266.png\" alt=\"\"></p>\n<p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dbc50001076c04970869.png\" alt=\"\"></p>\n<h2 id=\"3-分支管理策略。\"><a href=\"#3-分支管理策略。\" class=\"headerlink\" title=\"3.分支管理策略。\"></a>3.分支管理策略。</h2><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p>\n<p>创建一个dev分支。<br>修改readme.txt内容。<br>添加到暂存区。<br>切换回主分支(master)。<br>合并dev分支，使用命令 git merge –no-ff -m “注释” dev<br>查看历史记录<br>截图如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dbdc0001836d06030780.png\" alt=\"\"></p>\n<p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>\n<h4 id=\"七：bug分支：\"><a href=\"#七：bug分支：\" class=\"headerlink\" title=\"七：bug分支：\"></a>七：bug分支：</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc4e000141b306260166.png\" alt=\"\"></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc63000121ff06510188.png\" alt=\"\"></p>\n<p>所以现在我可以通过创建issue-404分支来修复bug了。<br>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc7000010f8506010533.png\" alt=\"\"></p>\n<p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dce00001c1ed06120441.png\" alt=\"\"></p>\n<p>现在，我们回到dev分支上干活了。</p>\n<p><img src=\"http://img.mukewang.com/59c1dcfa00019c8104220136.png\" alt=\"\"></p>\n<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd07000152b404340093.png\" alt=\"\"></p>\n<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p>\n<p>1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</p>\n<p>2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</p>\n<p>演示如下<br><img src=\"http://img.mukewang.com/59c1dd1f000174d406380466.png\" alt=\"\"></p>\n<h3 id=\"八：多人协作。\"><a href=\"#八：多人协作。\" class=\"headerlink\" title=\"八：多人协作。\"></a>八：多人协作。</h3><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。<br>要查看远程库的信息 使用 git remote<br>要查看远程库的详细信息 使用 git remote –v</p>\n<p>如下演示：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd7d000136fd06190169.png\" alt=\"\"></p>\n<h3 id=\"一：推送分支：\"><a href=\"#一：推送分支：\" class=\"headerlink\" title=\"一：推送分支：\"></a>一：推送分支：</h3><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br>使用命令 git push origin master</p>\n<p>比如我现在的github上的readme.txt代码如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd90000164a508280459.png\" alt=\"\"></p>\n<p>本地的readme.txt代码如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dda60001771804210205.png\" alt=\"\"></p>\n<p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1ddbf0001271e05410203.png\" alt=\"\"></p>\n<p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1ddcf0001771f08100484.png\" alt=\"\"></p>\n<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev<br>那么一般情况下，那些分支要推送呢？<br>master分支是主分支，因此要时刻与远程同步。<br>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p>\n<p>二：抓取分支：<br>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2<br>但是我首先要把dev分支也要推送到远程去，如下</p>\n<p><img src=\"http://img.mukewang.com/59c1ded800014adf05030151.jpg\" alt=\"\"></p>\n<p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1deb70001ec7605080170.png\" alt=\"\"></p>\n<p>现在目录下生成有如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1defe0001942707180256.png\" alt=\"\"></p>\n<p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev</p>\n<p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p>\n<p>如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1df160001ef1e06020730.png\" alt=\"\"></p>\n<p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1df340001209306470759.png\" alt=\"\"></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>\n<p><img src=\"http://img.mukewang.com/59c1dfa60001473e05940282.png\" alt=\"\"></p>\n<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dfc8000159c106460199.png\" alt=\"\"></p>\n<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：<br>我们可以先来看看readme.txt内容了。</p>\n<p><img src=\"http://img.mukewang.com/59c1dff70001a87605190277.png\" alt=\"\"></p>\n<p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1e0130001843906050480.png\" alt=\"\"></p>\n<p>因此：多人协作工作模式一般是这样的：<br>首先，可以试图用git push origin branch-name推送自己的修改.<br>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。<br>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>一：Git是什么?<br>二：SVN与Git的最主要的区别?<br>三：在windows上如何安装Git?<br>四：如何操作？<br>五：远程仓库<br>六：创建与合并分支<br>七：bug分支<br>八：多人协作</p>\n<h3 id=\"一：Git是什么？\"><a href=\"#一：Git是什么？\" class=\"headerlink\" title=\"一：Git是什么？\"></a>一：Git是什么？</h3><p>Git是目前世界上最先进的分布式版本控制系统。<br>工作原理 / 流程：</p>\n<p><img src=\"http://img.mukewang.com/59c31e4400013bc911720340.png\" alt=\"\"></p>\n<p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>\n<h3 id=\"二：SVN与Git的最主要的区别？\"><a href=\"#二：SVN与Git的最主要的区别？\" class=\"headerlink\" title=\"二：SVN与Git的最主要的区别？\"></a>二：SVN与Git的最主要的区别？</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>\n<p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>\n<h3 id=\"三、在windows上如何安装Git？\"><a href=\"#三、在windows上如何安装Git？\" class=\"headerlink\" title=\"三、在windows上如何安装Git？\"></a>三、在windows上如何安装Git？</h3><p>msysgit是 windows版的Git,如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfa400019aee02460029.jpg\" alt=\"\"></p>\n<p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git –&gt; Git Bash”,如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfd20001c2d602530073.jpg\" alt=\"\"></p>\n<p>会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1cfe70001462e06680380.jpg\" alt=\"\"></p>\n<p>安装完成后，还需要最后一步设置，在命令行输入如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d041000110d906460213.jpg\" alt=\"\"></p>\n<p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>\n<p>注意：git config –global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>\n<h3 id=\"四：如何操作？\"><a href=\"#四：如何操作？\" class=\"headerlink\" title=\"四：如何操作？\"></a>四：如何操作？</h3><h4 id=\"一：创建版本库。\"><a href=\"#一：创建版本库。\" class=\"headerlink\" title=\"一：创建版本库。\"></a>一：创建版本库。</h4><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p>\n<p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p>\n<p><img src=\"http://img.mukewang.com/59c1d1060001909005780268.png\" alt=\"\"></p>\n<p>pwd 命令是用于显示当前的目录。</p>\n<p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d12b0001b08305270077.png\" alt=\"\"></p>\n<p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d143000112df06120173.png\" alt=\"\"></p>\n<p>把文件添加到版本库中。</p>\n<p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p>\n<h2 id=\"下面先看下demo如下演示：\"><a href=\"#下面先看下demo如下演示：\" class=\"headerlink\" title=\"下面先看下demo如下演示：\"></a>下面先看下demo如下演示：</h2><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p>\n<p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2080001e4bb04490080.png\" alt=\"\"></p>\n<p>如果和上面一样，没有任何提示，说明已经添加成功了。</p>\n<p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p>\n<p><img src=\"http://img.mukewang.com/59c1d2200001f05b04930121.png\" alt=\"\"></p>\n<p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2340001a87904690107.png\" alt=\"\"></p>\n<p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2500001634606170171.png\" alt=\"\"></p>\n<p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。<br>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：<br>git diff readme.txt 如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d2cb00010a0304960202.png\" alt=\"\"></p>\n<p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p>\n<p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p>\n<p>如下：<br><img src=\"http://img.mukewang.com/59c1d2ff00015a9606180342.png\" alt=\"\"></p>\n<h3 id=\"二：版本回退：\"><a href=\"#二：版本回退：\" class=\"headerlink\" title=\"二：版本回退：\"></a>二：版本回退：</h3><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行</p>\n<p>内容为33333333333333.继续执行命令如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d32b00012ba604570139.png\" alt=\"\"></p>\n<p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d34e0001a1ac06050304.png\" alt=\"\"></p>\n<p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d3fc00013ad206040097.png\" alt=\"\"></p>\n<p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset –hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d4140001a0c404490165.png\" alt=\"\"></p>\n<p>如果想回退到上一个版本的命令如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1d429000199fc04610105.png\" alt=\"\"></p>\n<p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p>\n<p><img src=\"http://img.mukewang.com/59c1d4470001fcdc04360085.png\" alt=\"\"></p>\n<p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d45300012d9604800219.png\" alt=\"\"></p>\n<p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：<br>git reset –hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d51a0001d5fc05100122.png\" alt=\"\"></p>\n<p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令<br>git reset –hard 6fcfc89来恢复了。演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d53a0001b8b305050153.png\" alt=\"\"></p>\n<p>可以看到 目前已经是最新的版本了。</p>\n<h3 id=\"三：理解工作区与暂存区的区别？\"><a href=\"#三：理解工作区与暂存区的区别？\" class=\"headerlink\" title=\"三：理解工作区与暂存区的区别？\"></a>三：理解工作区与暂存区的区别？</h3><p>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</p>\n<p>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</p>\n<p>我们前面说过使用Git提交文件到版本库有两步：</p>\n<p>第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</p>\n<p>第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</p>\n<p>我们继续使用demo来演示下：</p>\n<p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d55a0001a3c306430241.png\" alt=\"\"></p>\n<p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d56a0001a28704700241.png\" alt=\"\"></p>\n<p>接着我们可以使用git commit一次性提交到分支上，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d57b0001b4fe06190166.png\" alt=\"\"></p>\n<h3 id=\"四：Git撤销修改和删除文件操作。\"><a href=\"#四：Git撤销修改和删除文件操作。\" class=\"headerlink\" title=\"四：Git撤销修改和删除文件操作。\"></a>四：Git撤销修改和删除文件操作。</h3><h4 id=\"一：撤销修改：\"><a href=\"#一：撤销修改：\" class=\"headerlink\" title=\"一：撤销修改：\"></a>一：撤销修改：</h4><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d5e40001806803930139.png\" alt=\"\"></p>\n<p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>\n<p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</p>\n<p>第二：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^</p>\n<p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d5fa0001b07806400168.png\" alt=\"\"></p>\n<p>可以发现，Git会告诉你，git checkout – file 可以丢弃工作区的修改，如下命令：<br>git checkout – readme.txt,如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6390001419705210140.png\" alt=\"\"></p>\n<p>命令 git checkout –readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p>\n<p>1.readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</p>\n<p>2.另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</p>\n<p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6ca0001782f06160482.png\" alt=\"\"></p>\n<p>注意：命令git checkout – readme.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。</p>\n<h4 id=\"二：删除文件。\"><a href=\"#二：删除文件。\" class=\"headerlink\" title=\"二：删除文件。\"></a>二：删除文件。</h4><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d6de0001a31606390392.png\" alt=\"\"></p>\n<p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p>\n<p><img src=\"http://img.mukewang.com/59c1d78200017e8f07030192.png\" alt=\"\"></p>\n<p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？<br>可以使用如下命令 git checkout – b.txt，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7980001368e05570244.png\" alt=\"\"></p>\n<p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7b70001308907550258.png\" alt=\"\"></p>\n<h3 id=\"五：远程仓库。\"><a href=\"#五：远程仓库。\" class=\"headerlink\" title=\"五：远程仓库。\"></a>五：远程仓库。</h3><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p>\n<p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p>\n<p>ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d7d7000120d107530169.png\" alt=\"\"></p>\n<p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>\n<p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p>\n<p><img src=\"http://img.mukewang.com/59c1d7ef0001c75411330860.png\" alt=\"\"></p>\n<p>点击 Add Key，你就应该可以看到已经添加的key。</p>\n<p><img src=\"http://img.mukewang.com/59c1d8540001eb3707620373.png\" alt=\"\"></p>\n<p>如何添加远程库？</p>\n<p>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p>\n<p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d86a0001044b10840605.png\" alt=\"\"></p>\n<p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8850001b5ea10260661.png\" alt=\"\"></p>\n<p>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>\n<p>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin https://github.com/tugenhua0707/testgit.git</span><br></pre></td></tr></table></figure></p>\n<p>所有的如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8a70001c86206320252.png\" alt=\"\"></p>\n<p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p>\n<p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d8bb00019ff310480655.png\" alt=\"\"></p>\n<p>从现在起，只要本地作了提交，就可以通过如下命令：</p>\n<pre><code>git push origin master\n</code></pre><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p>\n<h4 id=\"如何从远程库克隆？\"><a href=\"#如何从远程库克隆？\" class=\"headerlink\" title=\"如何从远程库克隆？\"></a>如何从远程库克隆？</h4><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。<br>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？<br>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1d95e0001f0fc10450604.png\" alt=\"\"></p>\n<p>如下，我们看到：</p>\n<p><img src=\"http://img.mukewang.com/59c1d97400014d4e10360484.png\" alt=\"\"></p>\n<p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d9860001e0d806370127.png\" alt=\"\"></p>\n<p>接着在我本地目录下 生成testgit2目录了，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1d99500016a2e07130197.png\" alt=\"\"></p>\n<h3 id=\"六：创建与合并分支。\"><a href=\"#六：创建与合并分支。\" class=\"headerlink\" title=\"六：创建与合并分支。\"></a>六：创建与合并分支。</h3><p>在版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>\n<p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1d9aa0001c15604080167.png\" alt=\"\"></p>\n<p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令<br>git branch dev<br>git checkout dev<br>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777<br>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da3f0001b5b703890392.png\" alt=\"\"></p>\n<p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da520001d44c06340206.png\" alt=\"\"></p>\n<p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1da69000145ca05320255.png\" alt=\"\"></p>\n<p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。<br>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。<br>合并完成后，我们可以接着删除dev分支了，操作如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1da91000120cd06430139.png\" alt=\"\"></p>\n<p>总结创建与合并分支命令如下：<br>查看分支：git branch<br>创建分支：git branch name<br>切换分支：git checkout name<br>创建+切换分支：git checkout –b name<br>合并某分支到当前分支：git merge name<br>删除分支：git branch –d name<br>如何解决冲突？<br>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1db410001036105690462.png\" alt=\"\"></p>\n<p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1daaf0001133205840500.png\" alt=\"\"></p>\n<p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p>\n<p><img src=\"http://img.mukewang.com/59c1daff000106eb06340589.png\" alt=\"\"></p>\n<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;<head是指主分支修改的内容，>&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</head是指主分支修改的内容，></p>\n<p><img src=\"http://img.mukewang.com/59c1dbaf00015f2205770266.png\" alt=\"\"></p>\n<p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dbc50001076c04970869.png\" alt=\"\"></p>\n<h2 id=\"3-分支管理策略。\"><a href=\"#3-分支管理策略。\" class=\"headerlink\" title=\"3.分支管理策略。\"></a>3.分支管理策略。</h2><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p>\n<p>创建一个dev分支。<br>修改readme.txt内容。<br>添加到暂存区。<br>切换回主分支(master)。<br>合并dev分支，使用命令 git merge –no-ff -m “注释” dev<br>查看历史记录<br>截图如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dbdc0001836d06030780.png\" alt=\"\"></p>\n<p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>\n<h4 id=\"七：bug分支：\"><a href=\"#七：bug分支：\" class=\"headerlink\" title=\"七：bug分支：\"></a>七：bug分支：</h4><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>\n<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc4e000141b306260166.png\" alt=\"\"></p>\n<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc63000121ff06510188.png\" alt=\"\"></p>\n<p>所以现在我可以通过创建issue-404分支来修复bug了。<br>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dc7000010f8506010533.png\" alt=\"\"></p>\n<p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dce00001c1ed06120441.png\" alt=\"\"></p>\n<p>现在，我们回到dev分支上干活了。</p>\n<p><img src=\"http://img.mukewang.com/59c1dcfa00019c8104220136.png\" alt=\"\"></p>\n<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd07000152b404340093.png\" alt=\"\"></p>\n<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p>\n<p>1.git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</p>\n<p>2.另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</p>\n<p>演示如下<br><img src=\"http://img.mukewang.com/59c1dd1f000174d406380466.png\" alt=\"\"></p>\n<h3 id=\"八：多人协作。\"><a href=\"#八：多人协作。\" class=\"headerlink\" title=\"八：多人协作。\"></a>八：多人协作。</h3><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。<br>要查看远程库的信息 使用 git remote<br>要查看远程库的详细信息 使用 git remote –v</p>\n<p>如下演示：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd7d000136fd06190169.png\" alt=\"\"></p>\n<h3 id=\"一：推送分支：\"><a href=\"#一：推送分支：\" class=\"headerlink\" title=\"一：推送分支：\"></a>一：推送分支：</h3><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br>使用命令 git push origin master</p>\n<p>比如我现在的github上的readme.txt代码如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dd90000164a508280459.png\" alt=\"\"></p>\n<p>本地的readme.txt代码如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dda60001771804210205.png\" alt=\"\"></p>\n<p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1ddbf0001271e05410203.png\" alt=\"\"></p>\n<p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1ddcf0001771f08100484.png\" alt=\"\"></p>\n<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev<br>那么一般情况下，那些分支要推送呢？<br>master分支是主分支，因此要时刻与远程同步。<br>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p>\n<p>二：抓取分支：<br>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2<br>但是我首先要把dev分支也要推送到远程去，如下</p>\n<p><img src=\"http://img.mukewang.com/59c1ded800014adf05030151.jpg\" alt=\"\"></p>\n<p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1deb70001ec7605080170.png\" alt=\"\"></p>\n<p>现在目录下生成有如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1defe0001942707180256.png\" alt=\"\"></p>\n<p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：git checkout –b dev origin/dev</p>\n<p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p>\n<p>如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1df160001ef1e06020730.png\" alt=\"\"></p>\n<p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1df340001209306470759.png\" alt=\"\"></p>\n<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>\n<p><img src=\"http://img.mukewang.com/59c1dfa60001473e05940282.png\" alt=\"\"></p>\n<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p>\n<p><img src=\"http://img.mukewang.com/59c1dfc8000159c106460199.png\" alt=\"\"></p>\n<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：<br>我们可以先来看看readme.txt内容了。</p>\n<p><img src=\"http://img.mukewang.com/59c1dff70001a87605190277.png\" alt=\"\"></p>\n<p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p>\n<p><img src=\"http://img.mukewang.com/59c1e0130001843906050480.png\" alt=\"\"></p>\n<p>因此：多人协作工作模式一般是这样的：<br>首先，可以试图用git push origin branch-name推送自己的修改.<br>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。<br>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p>\n"},{"title":"Hello C#","p":"csharp/hello-csharp","date":"2006-12-26T08:49:10.000Z","_content":"","source":"_posts/csharp/hello-csharp.md","raw":"---\ntitle: Hello C#\np: csharp/hello-csharp\ndate: 2006-12-26 16:49:10\ntags:\ncategories: C#\n---\n","slug":"csharp/hello-csharp","published":1,"updated":"2017-12-26T09:33:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcp50005a4e3el7n1p3h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OOJ-面向对象编程的三大特点-封装，继承，多态分析与实例","p":"javascript/OOJ-THREE","date":"2010-06-01T02:19:05.000Z","_content":"\n今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。\n\njavascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。\n\n### 首先：封装\n\n在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。\n\n今天我们重新温习加强理解下实现的要点与注意事项：\n\njavascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：\n\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function myInfo(){\n    var name =\"Hello\",age =27;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"years old\";\n    function showInfo(){\n      alert(myInfo);\n    }\n    return showInfo;\n  }\n  var oldFish = myInfo();\n  oldFish();\n// ]]>\n</script>\n```\n\n上面的代码段其实就是一个简单的闭包应用。 \n简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。 \n总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ \n\n如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：\n\n``` JS\n\n  var ioldFish = function(name,age){\n    var name = name,age = age;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"\">years old\";\n    return {\n      showInfo: function(){\n        alert(myInfo);  \n      } \n    }\n  }\n  ioldFish(\"Hello\",27).showInfo();\n```\n上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！ \n上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！ \n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n    var ioldFish = function(name,age){\n      return ioldFish.func.init(name,age);  \n    };\n    ioldFish.func = ioldFish.prototype ={\n        init:function(name,age){\n            this.name = name;\n            this.age = age;\n            return this;\n        },\n        showInfo:function(){\n            var info = \"my name is\" + this.name +\"i am \" +this.age+\"years old\";\n            alert(info);\n        }\n    };\n    ioldFish.func.init.prototype = ioldFish.func;\n    ioldFish(\"Hello\",27).showInfo();\n    //var oldFish = new ioldFish(\"Hello\",27);\n    //alert(oldFish.name);\n// ]]>\n</script>\n```\n两种模式各有特点，大家看情况随机使用。\n\n## 其次：继承\n\n与闭包封装有点冲突，闭包封装不利于子类派生。\n\n在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 \n\n*A.类式继承*：这个是现在主流框架中常用的继承方式，看下例：\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  var Name = function(name){\n    this.name = name;\n  };\n  Name.prototype.getName = function(){\n    alert(this.name);\n  };\n  var Fish = function(name,age){\n    Name.call(this,name);\n    this.age = age;\n  };\n  Fish.prototype = new Name();\n  Fish.prototype.constructor = Fish;\n  Fish.prototype.showInfo = function(){\n   alert(this.age);\n  }\n  var ioldFish = new Fish(\"Hello\",27);\n  ioldFish.getName();\n// ]]>\n</script>\n```\n\n上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 \n\n*B.原型继承*，从内存性能上看优于类式继承。\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function clone(object){\n    var F = function(){};\n    F.prototype = object;\n    return new F();\n  };\n  var Name = {\n    name:\"who's name\",\n    showInfo:function(){\n      alert(this.name);\n    }\n  };\n  var Fish = clone(Name);\n  //Fish.name = \"Hello\";\n  Fish.showInfo();\n// ]]>\n</script>\n```\n\n很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.\n\n*C.掺元类*：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 \n\n``` JS\n  function agument(receveClass,giveClass){\n    if(arguments[2]){\n      var len = arguments.length;\n      for(i=2;i<len;i++){\n        receveClass.prototype[arguments[i]] = giveClass.prototype[arguments[i]];\n      }\n    }\n    else{\n      for(method in giveClass.prototype){\n        if(!receveClass.prototype[method]){\n          receveClass.prototype[method] = giveClass.prototype[method];\n        }\n      }\n    }\n  };\n  var Name = function(){};\n  Name.prototype ={\n    sayLike:function(){\n      alert(\"i like oldfish\");\n    },\n    sayLove:function(){\n      alert(\"i love oldfish\");\n    }\n  }\n  var Fish = function(){};\n  var ioldFish = new Fish();\n  agument(Fish,Name,\"sayLove\");\n  ioldFish.sayLove();\n  ioldFish.sayLike();\n\n```\n\n多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。\n\n重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。\n\n覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！\n\n最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：\n``` JS\n\n var Name = function(name) {\n    this.name = name;\n    this.getName = function () {\n        alert(this.name);\n    }\n };\n   var ioldFish = new Name(\"Hello\"),\n   btn = document.getElementById('btn');\n   btn.onclick = ioldFish.getName;\n   //btn.onclick = function(){ioldFish.getName.call(ioldFish)};\n```\n上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。\n\n当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……\n\n``` JS\nFunction.prototype.bind = function(obj) {\n    var method = this,\n    temp = function() {\n        return method.apply(obj, arguments);\n    };\n}\n```\n循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。\n\n\n感谢老鱼的文章：本文引自：http://ued.alipay.com/2009/03/javascript-orient-object/  ","source":"_posts/javascript/OOJ-THREE.md","raw":"---\ntitle: OOJ-面向对象编程的三大特点-封装，继承，多态分析与实例\np: javascript/OOJ-THREE\ndate: 2010-06-01 10:19:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。\n\njavascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。\n\n### 首先：封装\n\n在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。\n\n今天我们重新温习加强理解下实现的要点与注意事项：\n\njavascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：\n\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function myInfo(){\n    var name =\"Hello\",age =27;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"years old\";\n    function showInfo(){\n      alert(myInfo);\n    }\n    return showInfo;\n  }\n  var oldFish = myInfo();\n  oldFish();\n// ]]>\n</script>\n```\n\n上面的代码段其实就是一个简单的闭包应用。 \n简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。 \n总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ \n\n如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：\n\n``` JS\n\n  var ioldFish = function(name,age){\n    var name = name,age = age;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"\">years old\";\n    return {\n      showInfo: function(){\n        alert(myInfo);  \n      } \n    }\n  }\n  ioldFish(\"Hello\",27).showInfo();\n```\n上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！ \n上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！ \n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n    var ioldFish = function(name,age){\n      return ioldFish.func.init(name,age);  \n    };\n    ioldFish.func = ioldFish.prototype ={\n        init:function(name,age){\n            this.name = name;\n            this.age = age;\n            return this;\n        },\n        showInfo:function(){\n            var info = \"my name is\" + this.name +\"i am \" +this.age+\"years old\";\n            alert(info);\n        }\n    };\n    ioldFish.func.init.prototype = ioldFish.func;\n    ioldFish(\"Hello\",27).showInfo();\n    //var oldFish = new ioldFish(\"Hello\",27);\n    //alert(oldFish.name);\n// ]]>\n</script>\n```\n两种模式各有特点，大家看情况随机使用。\n\n## 其次：继承\n\n与闭包封装有点冲突，闭包封装不利于子类派生。\n\n在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 \n\n*A.类式继承*：这个是现在主流框架中常用的继承方式，看下例：\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  var Name = function(name){\n    this.name = name;\n  };\n  Name.prototype.getName = function(){\n    alert(this.name);\n  };\n  var Fish = function(name,age){\n    Name.call(this,name);\n    this.age = age;\n  };\n  Fish.prototype = new Name();\n  Fish.prototype.constructor = Fish;\n  Fish.prototype.showInfo = function(){\n   alert(this.age);\n  }\n  var ioldFish = new Fish(\"Hello\",27);\n  ioldFish.getName();\n// ]]>\n</script>\n```\n\n上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 \n\n*B.原型继承*，从内存性能上看优于类式继承。\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function clone(object){\n    var F = function(){};\n    F.prototype = object;\n    return new F();\n  };\n  var Name = {\n    name:\"who's name\",\n    showInfo:function(){\n      alert(this.name);\n    }\n  };\n  var Fish = clone(Name);\n  //Fish.name = \"Hello\";\n  Fish.showInfo();\n// ]]>\n</script>\n```\n\n很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.\n\n*C.掺元类*：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 \n\n``` JS\n  function agument(receveClass,giveClass){\n    if(arguments[2]){\n      var len = arguments.length;\n      for(i=2;i<len;i++){\n        receveClass.prototype[arguments[i]] = giveClass.prototype[arguments[i]];\n      }\n    }\n    else{\n      for(method in giveClass.prototype){\n        if(!receveClass.prototype[method]){\n          receveClass.prototype[method] = giveClass.prototype[method];\n        }\n      }\n    }\n  };\n  var Name = function(){};\n  Name.prototype ={\n    sayLike:function(){\n      alert(\"i like oldfish\");\n    },\n    sayLove:function(){\n      alert(\"i love oldfish\");\n    }\n  }\n  var Fish = function(){};\n  var ioldFish = new Fish();\n  agument(Fish,Name,\"sayLove\");\n  ioldFish.sayLove();\n  ioldFish.sayLike();\n\n```\n\n多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。\n\n重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。\n\n覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！\n\n最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：\n``` JS\n\n var Name = function(name) {\n    this.name = name;\n    this.getName = function () {\n        alert(this.name);\n    }\n };\n   var ioldFish = new Name(\"Hello\"),\n   btn = document.getElementById('btn');\n   btn.onclick = ioldFish.getName;\n   //btn.onclick = function(){ioldFish.getName.call(ioldFish)};\n```\n上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。\n\n当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……\n\n``` JS\nFunction.prototype.bind = function(obj) {\n    var method = this,\n    temp = function() {\n        return method.apply(obj, arguments);\n    };\n}\n```\n循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。\n\n\n感谢老鱼的文章：本文引自：http://ued.alipay.com/2009/03/javascript-orient-object/  ","slug":"javascript/OOJ-THREE","published":1,"updated":"2017-12-27T06:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcp70006a4e3v7cpy65b","content":"<p>今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。</p>\n<p>javascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。</p>\n<h3 id=\"首先：封装\"><a href=\"#首先：封装\" class=\"headerlink\" title=\"首先：封装\"></a>首先：封装</h3><p>在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。</p>\n<p>今天我们重新温习加强理解下实现的要点与注意事项：</p>\n<p>javascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">\"Hello\"</span>,age =<span class=\"number\">27</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(myInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> showInfo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oldFish = myInfo();</span><br><span class=\"line\">  oldFish();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码段其实就是一个简单的闭包应用。<br>简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。<br>总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ </p>\n<p>如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name,age = age;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"\"</span>&gt;years old<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">  return &#123;</span></span><br><span class=\"line\"><span class=\"string\">    showInfo: function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">      alert(myInfo);  </span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">ioldFish(\"</span>Hello<span class=\"string\">\",27).showInfo();</span></span><br></pre></td></tr></table></figure>\n<p>上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！<br>上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ioldFish.func.init(name,age);  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func = ioldFish.prototype =&#123;</span><br><span class=\"line\">        init:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> info = <span class=\"string\">\"my name is\"</span> + <span class=\"keyword\">this</span>.name +<span class=\"string\">\"i am \"</span> +<span class=\"keyword\">this</span>.age+<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">            alert(info);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func.init.prototype = ioldFish.func;</span><br><span class=\"line\">    ioldFish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>).showInfo();</span><br><span class=\"line\">    <span class=\"comment\">//var oldFish = new ioldFish(\"Hello\",27);</span></span><br><span class=\"line\">    <span class=\"comment\">//alert(oldFish.name);</span></span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>两种模式各有特点，大家看情况随机使用。</p>\n<h2 id=\"其次：继承\"><a href=\"#其次：继承\" class=\"headerlink\" title=\"其次：继承\"></a>其次：继承</h2><p>与闭包封装有点冲突，闭包封装不利于子类派生。</p>\n<p>在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 </p>\n<p><em>A.类式继承</em>：这个是现在主流框架中常用的继承方式，看下例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Name.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Name.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Fish.prototype = <span class=\"keyword\">new</span> Name();</span><br><span class=\"line\">  Fish.prototype.constructor = Fish;</span><br><span class=\"line\">  Fish.prototype.showInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>);</span><br><span class=\"line\">  ioldFish.getName();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 </p>\n<p><em>B.原型继承</em>，从内存性能上看优于类式继承。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">object</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = object;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">\"who's name\"</span>,</span><br><span class=\"line\">    showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = clone(Name);</span><br><span class=\"line\">  <span class=\"comment\">//Fish.name = \"Hello\";</span></span><br><span class=\"line\">  Fish.showInfo();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.</p>\n<p><em>C.掺元类</em>：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agument</span>(<span class=\"params\">receveClass,giveClass</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">      receveClass.prototype[<span class=\"built_in\">arguments</span>[i]] = giveClass.prototype[<span class=\"built_in\">arguments</span>[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(method <span class=\"keyword\">in</span> giveClass.prototype)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!receveClass.prototype[method])&#123;</span><br><span class=\"line\">        receveClass.prototype[method] = giveClass.prototype[method];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Name.prototype =&#123;</span><br><span class=\"line\">  sayLike:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i like oldfish\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sayLove:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love oldfish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">agument(Fish,Name,<span class=\"string\">\"sayLove\"</span>);</span><br><span class=\"line\">ioldFish.sayLove();</span><br><span class=\"line\">ioldFish.sayLike();</span><br></pre></td></tr></table></figure>\n<p>多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。</p>\n<p>重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。</p>\n<p>覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！</p>\n<p>最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Name(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\">  btn.onclick = ioldFish.getName;</span><br><span class=\"line\">  <span class=\"comment\">//btn.onclick = function()&#123;ioldFish.getName.call(ioldFish)&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。</p>\n<p>当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">    temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。</p>\n<p>感谢老鱼的文章：本文引自：<a href=\"http://ued.alipay.com/2009/03/javascript-orient-object/\" target=\"_blank\" rel=\"noopener\">http://ued.alipay.com/2009/03/javascript-orient-object/</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。</p>\n<p>javascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。</p>\n<h3 id=\"首先：封装\"><a href=\"#首先：封装\" class=\"headerlink\" title=\"首先：封装\"></a>首先：封装</h3><p>在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。</p>\n<p>今天我们重新温习加强理解下实现的要点与注意事项：</p>\n<p>javascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">\"Hello\"</span>,age =<span class=\"number\">27</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(myInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> showInfo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oldFish = myInfo();</span><br><span class=\"line\">  oldFish();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码段其实就是一个简单的闭包应用。<br>简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。<br>总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ </p>\n<p>如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name,age = age;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"\"</span>&gt;years old<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">  return &#123;</span></span><br><span class=\"line\"><span class=\"string\">    showInfo: function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">      alert(myInfo);  </span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">ioldFish(\"</span>Hello<span class=\"string\">\",27).showInfo();</span></span><br></pre></td></tr></table></figure>\n<p>上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！<br>上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ioldFish.func.init(name,age);  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func = ioldFish.prototype =&#123;</span><br><span class=\"line\">        init:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> info = <span class=\"string\">\"my name is\"</span> + <span class=\"keyword\">this</span>.name +<span class=\"string\">\"i am \"</span> +<span class=\"keyword\">this</span>.age+<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">            alert(info);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func.init.prototype = ioldFish.func;</span><br><span class=\"line\">    ioldFish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>).showInfo();</span><br><span class=\"line\">    <span class=\"comment\">//var oldFish = new ioldFish(\"Hello\",27);</span></span><br><span class=\"line\">    <span class=\"comment\">//alert(oldFish.name);</span></span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>两种模式各有特点，大家看情况随机使用。</p>\n<h2 id=\"其次：继承\"><a href=\"#其次：继承\" class=\"headerlink\" title=\"其次：继承\"></a>其次：继承</h2><p>与闭包封装有点冲突，闭包封装不利于子类派生。</p>\n<p>在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 </p>\n<p><em>A.类式继承</em>：这个是现在主流框架中常用的继承方式，看下例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Name.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Name.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Fish.prototype = <span class=\"keyword\">new</span> Name();</span><br><span class=\"line\">  Fish.prototype.constructor = Fish;</span><br><span class=\"line\">  Fish.prototype.showInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>);</span><br><span class=\"line\">  ioldFish.getName();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 </p>\n<p><em>B.原型继承</em>，从内存性能上看优于类式继承。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">object</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = object;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">\"who's name\"</span>,</span><br><span class=\"line\">    showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = clone(Name);</span><br><span class=\"line\">  <span class=\"comment\">//Fish.name = \"Hello\";</span></span><br><span class=\"line\">  Fish.showInfo();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.</p>\n<p><em>C.掺元类</em>：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agument</span>(<span class=\"params\">receveClass,giveClass</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">      receveClass.prototype[<span class=\"built_in\">arguments</span>[i]] = giveClass.prototype[<span class=\"built_in\">arguments</span>[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(method <span class=\"keyword\">in</span> giveClass.prototype)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!receveClass.prototype[method])&#123;</span><br><span class=\"line\">        receveClass.prototype[method] = giveClass.prototype[method];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Name.prototype =&#123;</span><br><span class=\"line\">  sayLike:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i like oldfish\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sayLove:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love oldfish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">agument(Fish,Name,<span class=\"string\">\"sayLove\"</span>);</span><br><span class=\"line\">ioldFish.sayLove();</span><br><span class=\"line\">ioldFish.sayLike();</span><br></pre></td></tr></table></figure>\n<p>多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。</p>\n<p>重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。</p>\n<p>覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！</p>\n<p>最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Name(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\">  btn.onclick = ioldFish.getName;</span><br><span class=\"line\">  <span class=\"comment\">//btn.onclick = function()&#123;ioldFish.getName.call(ioldFish)&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。</p>\n<p>当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">    temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。</p>\n<p>感谢老鱼的文章：本文引自：<a href=\"http://ued.alipay.com/2009/03/javascript-orient-object/\" target=\"_blank\" rel=\"noopener\">http://ued.alipay.com/2009/03/javascript-orient-object/</a>  </p>\n"},{"title":"OOJ-面向对象的JAVASCRIPT（一）","p":"javascript/OOJ-ONE","date":"2010-05-15T08:52:05.000Z","_content":"\n现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。\nWEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。\n\n## 一、面向对象的基础理论\n百度知道里讲诉的已经非常清晰, [更多详情](http://baike.baidu.com/view/125370.htm) ，这里纯理论的知识大家就自我学习。\n\n## 二、OOJ概述\njavascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。\n\n### JavaScript 对象是词典\n在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：\n\n``` JS\nvar userObject = new Object();\nuserObject.lastLoginTime = new Date();\nalert(userObject.lastLoginTime);        \n```\n的功能与下面的代码段完全相同：\n\n``` JS\nvar userObject = {}; // equivalent to new Object()\nuserObject[“lastLoginTime”] = new Date();\nalert(userObject[“lastLoginTime”]);\n```\n\n 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：\n\n``` JS\nvar userObject = { “lastLoginTime”: new Date() };\nalert(userObject.lastLoginTime);\n```\n\n这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字\n\n如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。\n\n接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。\n\n### JavaScript 函数的奇特性\n\n大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：\n\n``` JS\nfunction func(x) {\n    alert(x);\n}\nfunc(“blah”);\n```\n 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func  \n``` JS\nvar func = function(x) {\n    alert(x);\n};\nfunc(“blah2”);\n```\n 甚至也可以像下面这样，使用 Function 构造函数：   \n``` JS\nvar func = new Function(“x”, “alert(x);”);\nfunc(“blah3”);\n```\n 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。\n\n为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： \n\n``` JS\nfunction sayHi(x) {\n    alert(“Hi, “ + x + “!”);\n}\nsayHi.text = “Hello World!”;\nsayHi[“text2”] = “Hello World... again.”;\n\nalert(sayHi[“text”]); // displays “Hello World!”\nalert(sayHi.text2); // displays “Hello World... again.”\n```\n\n作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：\n \n``` JS\n// assign an anonymous function to a variable\nvar greet = function(x) {\n    alert(“Hello, “ + x);\n};\ngreet(“MSDN readers”);\n\n// passing a function as an argument to another\nfunction square(x) {\n    return x * x;\n}\nfunction operateOn(num, func) {\n    return func(num);\n}\n// displays 256\nalert(operateOn(16, square));\n\n// functions as return values\nfunction makeIncrementer() {\n    return function(x) { return x + 1; };\n}\nvar inc = makeIncrementer();\n// displays 8\nalert(inc(7));\n\n// functions stored as array elements\nvar arr = [];\narr[0] = function(x) { return x * x; };\narr[1] = arr[0](2);\narr[2] = arr[0](arr[1]);\narr[3] = arr[0](arr[2]);\n// displays 256\nalert(arr[3]);\n\n// functions as object properties\nvar obj = { “toString” : function() { return “This is an object.”; } };\n// calls obj.toString()\nalert(obj);\n\n```\n\n记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： \n\n``` JS\nvar myDog = {\n    “name” : “Spot”,\n    “bark” : function() { alert(“Woof!”); },\n    “displayFullName” : function() {\n        alert(this.name + “ The Alpha Dog”);\n    },\n    “chaseMrPostman” : function() { \n        // implementation beyond the scope of this article \n    }    \n};\nmyDog.displayFullName(); \nmyDog.bark(); // Woof!\n```        \n\nC++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。\n\n#### “this”随对象更改而更改\n\n``` JS\nfunction displayQuote() {\n    // the value of “this” will change; depends on \n    // which object it is called through\n    alert(this.memorableQuote);    \n}\n\nvar williamShakespeare = {\n    “memorableQuote”: “It is a wise father that knows his own child.”, \n    “sayIt” : displayQuote\n};\n\nvar markTwain = {\n    “memorableQuote”: “Golf is a good walk spoiled.”, \n    “sayIt” : displayQuote\n};\n\nvar oscarWilde = {\n    “memorableQuote”: “True friends stab you in the front.” \n    // we can call the function displayQuote\n    // as a method of oscarWilde without assigning it \n    // as oscarWilde’s method. \n    //”sayIt” : displayQuote\n};\n\nwilliamShakespeare.sayIt(); // true, true\nmarkTwain.sayIt(); // he didn’t know where to play golf\n\n// watch this, each function has a method call()\n// that allows the function to be called as a \n// method of the object passed to call() as an\n// argument. \n// this line below is equivalent to assigning\n// displayQuote to sayIt, and calling oscarWilde.sayIt().\ndisplayQuote.call(oscarWilde); // ouch!\n```\n\n上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。\n\n有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！\n\n``` JS\nalert(“NaN is NaN: “ + isNaN(NaN));\n\nfunction x() {\n    this.isNaN = function() { \n        return “not anymore!”;\n    };\n}\n// alert!!! trampling the Global object!!!\nx();\n\nalert(“NaN is NaN: “ + isNaN(NaN));\n```\n\n到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。\n\n     在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n\n### 构造函数而不是类\n\n前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时： \n``` JS\nDog spot = new Dog();\n```\n将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  \n\n``` JS\nfunction DogConstructor(name) {\n    this.name = name;\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new DogConstructor(“Spot”);\nspot.respondTo(“Rover”); // nope\nspot.respondTo(“Spot”); // yeah!\n```\n \n\n那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：\n``` JS\nvar spot = new DogConstructor(“Spot”);\n```\n\n“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： \n\n``` JS\n// create an empty object\nvar spot = {}; \n// call the function as a method of the empty object\nDogConstructor.call(spot, “Spot”);\n```\n\n正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  \n\n``` JS\n// Think of this as class Dog\nfunction Dog(name) {\n    // instance variable \n    this.name = name;\n    // instance method? Hmmm...\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new Dog(“Spot”);\n```\n\n在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：\n\n``` JS\nfunction respondTo() {\n    // respondTo definition\n}\n\nfunction Dog(name) {\n    this.name = name;\n    // attached this function as a method of the object\n    this.respondTo = respondTo;\n}\n```\n这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。\n\n\n## 三、Javascript核心理论原型\n\n在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：\n``` JS\nvar buddy = new Dog(“Buddy“);\n```\nbuddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。\n\n在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。\n\n![图A1 每个函数的原型都有一个 Constructor 属性](/imgs/ooj-1.gif)\n\n现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。\n\n代码段B1\n=====\n``` JS\nvar spot = new Dog(“Spot”);\n\n// Dog.prototype is the prototype of spot\nalert(Dog.prototype.isPrototypeOf(spot));\n\n// spot inherits the constructor property\n// from Dog.prototype\nalert(spot.constructor == Dog.prototype.constructor);\nalert(spot.constructor == Dog);\n\n// But constructor property doesn’t belong\n// to spot. The line below displays “false”\nalert(spot.hasOwnProperty(“constructor”));\n\n// The constructor property belongs to Dog.prototype\n// The line below displays “true”\nalert(Dog.prototype.hasOwnProperty(“constructor”));\n```\n\n![图A2-实例继承其原型](/imgs/ooj-2.gif)\n\n某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）\n在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：\n \n``` JS\nDog.prototype = new Object();\n```\n\n因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。\n每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。\n图A3 说明了此解析过程。\n\n\n![图A3 在原型链中解析 toString() 方法](/imgs/ooj-3.gif)\n\n\nJavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：\n-   继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。\n-   如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。\n-   更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。\n\n代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。\n\n代码段B2-继承原型\n--------------\n\n``` JS\nfunction GreatDane() { }\n\nvar rover = new GreatDane();\nvar spot = new GreatDane();\n\nGreatDane.prototype.getBreed = function() {\n    return “Great Dane”;\n};\n\n// Works, even though at this point\n// rover and spot are already created.\nalert(rover.getBreed());\n\n// this hides getBreed() in GreatDane.prototype\nspot.getBreed = function() {\n    return “Little Great Dane”;\n};\nalert(spot.getBreed()); \n\n// but of course, the change to getBreed \n// doesn’t propagate back to GreatDane.prototype\n// and other objects inheriting from it,\n// it only happens in the spot object\nalert(rover.getBreed());\n\n```\n\n### 静态属性和方法\n有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：\n\n``` JS\nfunction DateTime() { }\n\n    // set static method now()\n    DateTime.now = function() {\n        return new Date();\n    };\n\n    alert(DateTime.now());\n```\n\n在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。\n \n### 闭包\n不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。\nJavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。\n假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。\n\n代码段B3 -根据谓词筛选元素\n===========\n\n``` JS\nfunction filter(pred, arr) {\n    var len = arr.length;\n    var filtered = []; // shorter version of new Array();\n    // iterate through every element in the array...\n    for(var i = 0; i < len; i++) {\n        var val = arr[i];\n        // if the element satisfies the predicate let it through\n        if(pred(val)) {\n            filtered.push(val);\n        }\n    }\n    return filtered;\n}\n\nvar someRandomNumbers = [12, 32, 1, 3, 2, 2, 234, 236, 632,7, 8];\nvar numbersGreaterThan100 = filter(\n    function(x) { return (x > 100) ? true : false; }, \n    someRandomNumbers);\n\n// displays 234, 236, 632\nalert(numbersGreaterThan100);\n```\n\n但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：\n``` JS\nvar greaterThan300 = filter(\n    function(x) { return (x > 300) ? true : false; }, \n    someRandomNumbers);\n ```\n\n然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：\n\n``` JS\nfunction makeGreaterThanPredicate(lowerBound) {\n    return function(numberToCheck) {\n        return (numberToCheck > lowerBound) ? true : false;\n    };\n}\n```\n\n这样，您就可以编写以下代码：\n``` JS\nvar greaterThan10 = makeGreaterThanPredicate(10);\nvar greaterThan100 = makeGreaterThanPredicate(100);\nalert(filter(greaterThan10, someRandomNumbers));\nalert(filter(greaterThan100, someRandomNumbers));\n```\n\n通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。\n\n开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。\n\n模拟私有属性\n-----------\n现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：\n\n``` JS\nfunction Person(name, age) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n    this.getAge = function() { return age; };\n    this.setAge = function(newAge) { age = newAge; };\n}\n```\n\n参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：\n\n``` JS\nvar ray = new Person(“Ray”, 31);\nalert(ray.getName());\nalert(ray.getAge());\nray.setName(“Younger Ray”);\n// Instant rejuvenation!\nray.setAge(22);\nalert(ray.getName() + “ is now “ + ray.getAge() + \n      “ years old.”);\n```\n\n未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：\n\n``` JS\nfunction Person(name, age) {\n    var occupation;\n    this.getOccupation = function() { return occupation; };\n    this.setOccupation = function(newOcc) { occupation = \n                         newOcc; };\n  \n    // accessors for name and age    \n}\n```\n\n注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：\n\n``` JS\nPerson.prototype.somePublicMethod = function() {\n    // doesn’t work!\n    // alert(this.name);\n    // this one below works\n    alert(this.getName());\n};\n```\n\nDouglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。\n\n从类继承\n---------\n到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。\n例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：\n\n\n![图A4-类图](/imgs/ooj-4.gif)\n\n``` JS\n// class Pet\nfunction Pet(name) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n}\n\nPet.prototype.toString = function() {\n    return “This pet’s name is: “ + this.getName();\n};\n// end of class Pet\n\nvar parrotty = new Pet(“Parrotty the Parrot”);\nalert(parrotty);\n```\n\n现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。\n\n代码段B3-从PET类派生\n-------\n\n``` JS\n// class Dog : Pet \n// public Dog(string name, string breed)\nfunction Dog(name, breed) {\n    // think Dog : base(name) \n    Pet.call(this, name);\n    this.getBreed = function() { return breed; };\n    // Breed doesn’t change, obviously! It’s read only.\n    // this.setBreed = function(newBreed) { name = newName; };\n}\n\n// this makes Dog.prototype inherits\n// from Pet.prototype\nDog.prototype = new Pet();\n\n// remember that Pet.prototype.constructor\n// points to Pet. We want our Dog instances’\n// constructor to point to Dog.\nDog.prototype.constructor = Dog;\n\n// Now we override Pet.prototype.toString\nDog.prototype.toString = function() {\n    return “This dog’s name is: “ + this.getName() + \n        “, and its breed is: “ + this.getBreed();\n};\n// end of class Dog\n\nvar dog = new Dog(“Buddy”, “Great Dane”);\n// test the new toString()\nalert(dog);\n\n// Testing instanceof (similar to the is operator)\n// (dog is Dog)? yes\nalert(dog instanceof Dog);\n// (dog is Pet)? yes\nalert(dog instanceof Pet);\n// (dog is Object)? yes\nalert(dog instanceof Object);\n```\n\n所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。\n\n\n模拟命名空间\n-------------\n\n在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：\n\n``` JS\nvar MSDNMagNS = {};\n\nMSDNMagNS.Pet = function(name) { // code here };\nMSDNMagNS.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Pet(“Yammer”);\n```\n\n命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：\n\n``` JS\nvar MSDNMagNS = {};\n// nested namespace “Examples”\nMSDNMagNS.Examples = {}; \n\nMSDNMagNS.Examples.Pet = function(name) { // code };\nMSDNMagNS.Examples.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Examples.Pet(“Yammer”);\n```\n\n可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：\n\n``` JS\n// MSDNMagNS.Examples and Pet definition...\n\n// think “using Eg = MSDNMagNS.Examples;” \nvar Eg = MSDNMagNS.Examples;\nvar pet = new Eg.Pet(“Yammer”);\nalert(pet);\n```\n\n\n如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。\n\n应当这样编写 JavaScript 代码吗？\n----------------------------\n您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。\n在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：\n\n``` JS\nfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n```\n\n然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。\n\n这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。\n\n...更多内容请看下篇文章\n\n## 四、作者总结\n\n　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。\n\n　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。\n\n　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。\n\n　　本文作者：朱峰（Peter Zhu）\n\n　　发表时间：2010-05-31\n\n## 五、本文参考引用文章列表\n\n1. 使用面向对象的技术创建高级Web 应用程序 http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\n\n2. 百度知道 http://baike.baidu.com/view/125370.htm \n\n3. OOJ-面向对象的JAVASCRIPT - [PeterZhu](http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html)\n\n","source":"_posts/javascript/OOJ-ONE.md","raw":"---\ntitle: OOJ-面向对象的JAVASCRIPT（一）\np: javascript/OOJ-ONE\ndate: 2010-05-15 16:52:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。\nWEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。\n\n## 一、面向对象的基础理论\n百度知道里讲诉的已经非常清晰, [更多详情](http://baike.baidu.com/view/125370.htm) ，这里纯理论的知识大家就自我学习。\n\n## 二、OOJ概述\njavascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。\n\n### JavaScript 对象是词典\n在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：\n\n``` JS\nvar userObject = new Object();\nuserObject.lastLoginTime = new Date();\nalert(userObject.lastLoginTime);        \n```\n的功能与下面的代码段完全相同：\n\n``` JS\nvar userObject = {}; // equivalent to new Object()\nuserObject[“lastLoginTime”] = new Date();\nalert(userObject[“lastLoginTime”]);\n```\n\n 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：\n\n``` JS\nvar userObject = { “lastLoginTime”: new Date() };\nalert(userObject.lastLoginTime);\n```\n\n这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字\n\n如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。\n\n接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。\n\n### JavaScript 函数的奇特性\n\n大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：\n\n``` JS\nfunction func(x) {\n    alert(x);\n}\nfunc(“blah”);\n```\n 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func  \n``` JS\nvar func = function(x) {\n    alert(x);\n};\nfunc(“blah2”);\n```\n 甚至也可以像下面这样，使用 Function 构造函数：   \n``` JS\nvar func = new Function(“x”, “alert(x);”);\nfunc(“blah3”);\n```\n 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。\n\n为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： \n\n``` JS\nfunction sayHi(x) {\n    alert(“Hi, “ + x + “!”);\n}\nsayHi.text = “Hello World!”;\nsayHi[“text2”] = “Hello World... again.”;\n\nalert(sayHi[“text”]); // displays “Hello World!”\nalert(sayHi.text2); // displays “Hello World... again.”\n```\n\n作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：\n \n``` JS\n// assign an anonymous function to a variable\nvar greet = function(x) {\n    alert(“Hello, “ + x);\n};\ngreet(“MSDN readers”);\n\n// passing a function as an argument to another\nfunction square(x) {\n    return x * x;\n}\nfunction operateOn(num, func) {\n    return func(num);\n}\n// displays 256\nalert(operateOn(16, square));\n\n// functions as return values\nfunction makeIncrementer() {\n    return function(x) { return x + 1; };\n}\nvar inc = makeIncrementer();\n// displays 8\nalert(inc(7));\n\n// functions stored as array elements\nvar arr = [];\narr[0] = function(x) { return x * x; };\narr[1] = arr[0](2);\narr[2] = arr[0](arr[1]);\narr[3] = arr[0](arr[2]);\n// displays 256\nalert(arr[3]);\n\n// functions as object properties\nvar obj = { “toString” : function() { return “This is an object.”; } };\n// calls obj.toString()\nalert(obj);\n\n```\n\n记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： \n\n``` JS\nvar myDog = {\n    “name” : “Spot”,\n    “bark” : function() { alert(“Woof!”); },\n    “displayFullName” : function() {\n        alert(this.name + “ The Alpha Dog”);\n    },\n    “chaseMrPostman” : function() { \n        // implementation beyond the scope of this article \n    }    \n};\nmyDog.displayFullName(); \nmyDog.bark(); // Woof!\n```        \n\nC++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。\n\n#### “this”随对象更改而更改\n\n``` JS\nfunction displayQuote() {\n    // the value of “this” will change; depends on \n    // which object it is called through\n    alert(this.memorableQuote);    \n}\n\nvar williamShakespeare = {\n    “memorableQuote”: “It is a wise father that knows his own child.”, \n    “sayIt” : displayQuote\n};\n\nvar markTwain = {\n    “memorableQuote”: “Golf is a good walk spoiled.”, \n    “sayIt” : displayQuote\n};\n\nvar oscarWilde = {\n    “memorableQuote”: “True friends stab you in the front.” \n    // we can call the function displayQuote\n    // as a method of oscarWilde without assigning it \n    // as oscarWilde’s method. \n    //”sayIt” : displayQuote\n};\n\nwilliamShakespeare.sayIt(); // true, true\nmarkTwain.sayIt(); // he didn’t know where to play golf\n\n// watch this, each function has a method call()\n// that allows the function to be called as a \n// method of the object passed to call() as an\n// argument. \n// this line below is equivalent to assigning\n// displayQuote to sayIt, and calling oscarWilde.sayIt().\ndisplayQuote.call(oscarWilde); // ouch!\n```\n\n上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。\n\n有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！\n\n``` JS\nalert(“NaN is NaN: “ + isNaN(NaN));\n\nfunction x() {\n    this.isNaN = function() { \n        return “not anymore!”;\n    };\n}\n// alert!!! trampling the Global object!!!\nx();\n\nalert(“NaN is NaN: “ + isNaN(NaN));\n```\n\n到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。\n\n     在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n\n### 构造函数而不是类\n\n前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时： \n``` JS\nDog spot = new Dog();\n```\n将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  \n\n``` JS\nfunction DogConstructor(name) {\n    this.name = name;\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new DogConstructor(“Spot”);\nspot.respondTo(“Rover”); // nope\nspot.respondTo(“Spot”); // yeah!\n```\n \n\n那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：\n``` JS\nvar spot = new DogConstructor(“Spot”);\n```\n\n“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： \n\n``` JS\n// create an empty object\nvar spot = {}; \n// call the function as a method of the empty object\nDogConstructor.call(spot, “Spot”);\n```\n\n正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  \n\n``` JS\n// Think of this as class Dog\nfunction Dog(name) {\n    // instance variable \n    this.name = name;\n    // instance method? Hmmm...\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new Dog(“Spot”);\n```\n\n在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：\n\n``` JS\nfunction respondTo() {\n    // respondTo definition\n}\n\nfunction Dog(name) {\n    this.name = name;\n    // attached this function as a method of the object\n    this.respondTo = respondTo;\n}\n```\n这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。\n\n\n## 三、Javascript核心理论原型\n\n在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：\n``` JS\nvar buddy = new Dog(“Buddy“);\n```\nbuddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。\n\n在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。\n\n![图A1 每个函数的原型都有一个 Constructor 属性](/imgs/ooj-1.gif)\n\n现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。\n\n代码段B1\n=====\n``` JS\nvar spot = new Dog(“Spot”);\n\n// Dog.prototype is the prototype of spot\nalert(Dog.prototype.isPrototypeOf(spot));\n\n// spot inherits the constructor property\n// from Dog.prototype\nalert(spot.constructor == Dog.prototype.constructor);\nalert(spot.constructor == Dog);\n\n// But constructor property doesn’t belong\n// to spot. The line below displays “false”\nalert(spot.hasOwnProperty(“constructor”));\n\n// The constructor property belongs to Dog.prototype\n// The line below displays “true”\nalert(Dog.prototype.hasOwnProperty(“constructor”));\n```\n\n![图A2-实例继承其原型](/imgs/ooj-2.gif)\n\n某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）\n在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：\n \n``` JS\nDog.prototype = new Object();\n```\n\n因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。\n每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。\n图A3 说明了此解析过程。\n\n\n![图A3 在原型链中解析 toString() 方法](/imgs/ooj-3.gif)\n\n\nJavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：\n-   继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。\n-   如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。\n-   更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。\n\n代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。\n\n代码段B2-继承原型\n--------------\n\n``` JS\nfunction GreatDane() { }\n\nvar rover = new GreatDane();\nvar spot = new GreatDane();\n\nGreatDane.prototype.getBreed = function() {\n    return “Great Dane”;\n};\n\n// Works, even though at this point\n// rover and spot are already created.\nalert(rover.getBreed());\n\n// this hides getBreed() in GreatDane.prototype\nspot.getBreed = function() {\n    return “Little Great Dane”;\n};\nalert(spot.getBreed()); \n\n// but of course, the change to getBreed \n// doesn’t propagate back to GreatDane.prototype\n// and other objects inheriting from it,\n// it only happens in the spot object\nalert(rover.getBreed());\n\n```\n\n### 静态属性和方法\n有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：\n\n``` JS\nfunction DateTime() { }\n\n    // set static method now()\n    DateTime.now = function() {\n        return new Date();\n    };\n\n    alert(DateTime.now());\n```\n\n在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。\n \n### 闭包\n不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。\nJavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。\n假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。\n\n代码段B3 -根据谓词筛选元素\n===========\n\n``` JS\nfunction filter(pred, arr) {\n    var len = arr.length;\n    var filtered = []; // shorter version of new Array();\n    // iterate through every element in the array...\n    for(var i = 0; i < len; i++) {\n        var val = arr[i];\n        // if the element satisfies the predicate let it through\n        if(pred(val)) {\n            filtered.push(val);\n        }\n    }\n    return filtered;\n}\n\nvar someRandomNumbers = [12, 32, 1, 3, 2, 2, 234, 236, 632,7, 8];\nvar numbersGreaterThan100 = filter(\n    function(x) { return (x > 100) ? true : false; }, \n    someRandomNumbers);\n\n// displays 234, 236, 632\nalert(numbersGreaterThan100);\n```\n\n但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：\n``` JS\nvar greaterThan300 = filter(\n    function(x) { return (x > 300) ? true : false; }, \n    someRandomNumbers);\n ```\n\n然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：\n\n``` JS\nfunction makeGreaterThanPredicate(lowerBound) {\n    return function(numberToCheck) {\n        return (numberToCheck > lowerBound) ? true : false;\n    };\n}\n```\n\n这样，您就可以编写以下代码：\n``` JS\nvar greaterThan10 = makeGreaterThanPredicate(10);\nvar greaterThan100 = makeGreaterThanPredicate(100);\nalert(filter(greaterThan10, someRandomNumbers));\nalert(filter(greaterThan100, someRandomNumbers));\n```\n\n通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。\n\n开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。\n\n模拟私有属性\n-----------\n现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：\n\n``` JS\nfunction Person(name, age) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n    this.getAge = function() { return age; };\n    this.setAge = function(newAge) { age = newAge; };\n}\n```\n\n参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：\n\n``` JS\nvar ray = new Person(“Ray”, 31);\nalert(ray.getName());\nalert(ray.getAge());\nray.setName(“Younger Ray”);\n// Instant rejuvenation!\nray.setAge(22);\nalert(ray.getName() + “ is now “ + ray.getAge() + \n      “ years old.”);\n```\n\n未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：\n\n``` JS\nfunction Person(name, age) {\n    var occupation;\n    this.getOccupation = function() { return occupation; };\n    this.setOccupation = function(newOcc) { occupation = \n                         newOcc; };\n  \n    // accessors for name and age    \n}\n```\n\n注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：\n\n``` JS\nPerson.prototype.somePublicMethod = function() {\n    // doesn’t work!\n    // alert(this.name);\n    // this one below works\n    alert(this.getName());\n};\n```\n\nDouglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。\n\n从类继承\n---------\n到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。\n例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：\n\n\n![图A4-类图](/imgs/ooj-4.gif)\n\n``` JS\n// class Pet\nfunction Pet(name) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n}\n\nPet.prototype.toString = function() {\n    return “This pet’s name is: “ + this.getName();\n};\n// end of class Pet\n\nvar parrotty = new Pet(“Parrotty the Parrot”);\nalert(parrotty);\n```\n\n现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。\n\n代码段B3-从PET类派生\n-------\n\n``` JS\n// class Dog : Pet \n// public Dog(string name, string breed)\nfunction Dog(name, breed) {\n    // think Dog : base(name) \n    Pet.call(this, name);\n    this.getBreed = function() { return breed; };\n    // Breed doesn’t change, obviously! It’s read only.\n    // this.setBreed = function(newBreed) { name = newName; };\n}\n\n// this makes Dog.prototype inherits\n// from Pet.prototype\nDog.prototype = new Pet();\n\n// remember that Pet.prototype.constructor\n// points to Pet. We want our Dog instances’\n// constructor to point to Dog.\nDog.prototype.constructor = Dog;\n\n// Now we override Pet.prototype.toString\nDog.prototype.toString = function() {\n    return “This dog’s name is: “ + this.getName() + \n        “, and its breed is: “ + this.getBreed();\n};\n// end of class Dog\n\nvar dog = new Dog(“Buddy”, “Great Dane”);\n// test the new toString()\nalert(dog);\n\n// Testing instanceof (similar to the is operator)\n// (dog is Dog)? yes\nalert(dog instanceof Dog);\n// (dog is Pet)? yes\nalert(dog instanceof Pet);\n// (dog is Object)? yes\nalert(dog instanceof Object);\n```\n\n所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。\n\n\n模拟命名空间\n-------------\n\n在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：\n\n``` JS\nvar MSDNMagNS = {};\n\nMSDNMagNS.Pet = function(name) { // code here };\nMSDNMagNS.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Pet(“Yammer”);\n```\n\n命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：\n\n``` JS\nvar MSDNMagNS = {};\n// nested namespace “Examples”\nMSDNMagNS.Examples = {}; \n\nMSDNMagNS.Examples.Pet = function(name) { // code };\nMSDNMagNS.Examples.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Examples.Pet(“Yammer”);\n```\n\n可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：\n\n``` JS\n// MSDNMagNS.Examples and Pet definition...\n\n// think “using Eg = MSDNMagNS.Examples;” \nvar Eg = MSDNMagNS.Examples;\nvar pet = new Eg.Pet(“Yammer”);\nalert(pet);\n```\n\n\n如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。\n\n应当这样编写 JavaScript 代码吗？\n----------------------------\n您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。\n在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：\n\n``` JS\nfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n```\n\n然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。\n\n这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。\n\n...更多内容请看下篇文章\n\n## 四、作者总结\n\n　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。\n\n　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。\n\n　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。\n\n　　本文作者：朱峰（Peter Zhu）\n\n　　发表时间：2010-05-31\n\n## 五、本文参考引用文章列表\n\n1. 使用面向对象的技术创建高级Web 应用程序 http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\n\n2. 百度知道 http://baike.baidu.com/view/125370.htm \n\n3. OOJ-面向对象的JAVASCRIPT - [PeterZhu](http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html)\n\n","slug":"javascript/OOJ-ONE","published":1,"updated":"2017-12-27T06:18:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcpa0008a4e3w9yar7kt","content":"<p>现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。<br>WEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。</p>\n<h2 id=\"一、面向对象的基础理论\"><a href=\"#一、面向对象的基础理论\" class=\"headerlink\" title=\"一、面向对象的基础理论\"></a>一、面向对象的基础理论</h2><p>百度知道里讲诉的已经非常清晰, <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">更多详情</a> ，这里纯理论的知识大家就自我学习。</p>\n<h2 id=\"二、OOJ概述\"><a href=\"#二、OOJ概述\" class=\"headerlink\" title=\"二、OOJ概述\"></a>二、OOJ概述</h2><p>javascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。</p>\n<h3 id=\"JavaScript-对象是词典\"><a href=\"#JavaScript-对象是词典\" class=\"headerlink\" title=\"JavaScript 对象是词典\"></a>JavaScript 对象是词典</h3><p>在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">userObject.lastLoginTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>的功能与下面的代码段完全相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123;&#125;; <span class=\"comment\">// equivalent to new Object()</span></span><br><span class=\"line\">userObject[“lastLoginTime”] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject[“lastLoginTime”]);</span><br></pre></td></tr></table></figure>\n<p> 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123; “lastLoginTime”: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() &#125;;</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字</p>\n<p>如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。</p>\n<p>接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。</p>\n<h3 id=\"JavaScript-函数的奇特性\"><a href=\"#JavaScript-函数的奇特性\" class=\"headerlink\" title=\"JavaScript 函数的奇特性\"></a>JavaScript 函数的奇特性</h3><p>大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(“blah”);</span><br></pre></td></tr></table></figure>\n<p> 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(“blah2”);</span><br></pre></td></tr></table></figure></p>\n<p> 甚至也可以像下面这样，使用 Function 构造函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(“x”, “alert(x);”);</span><br><span class=\"line\">func(“blah3”);</span><br></pre></td></tr></table></figure></p>\n<p> 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。</p>\n<p>为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hi, “ + x + “!”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.text = “Hello World!”;</span><br><span class=\"line\">sayHi[“text2”] = “Hello World... again.”;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sayHi[“text”]); <span class=\"comment\">// displays “Hello World!”</span></span><br><span class=\"line\">alert(sayHi.text2); <span class=\"comment\">// displays “Hello World... again.”</span></span><br></pre></td></tr></table></figure>\n<p>作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assign an anonymous function to a variable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hello, “ + x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">greet(“MSDN readers”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// passing a function as an argument to another</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operateOn</span>(<span class=\"params\">num, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(operateOn(<span class=\"number\">16</span>, square));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as return values</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIncrementer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = makeIncrementer();</span><br><span class=\"line\"><span class=\"comment\">// displays 8</span></span><br><span class=\"line\">alert(inc(<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions stored as array elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = arr[<span class=\"number\">0</span>](<span class=\"number\">2</span>);</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">arr[<span class=\"number\">3</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">2</span>]);</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as object properties</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; “toString” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> “This is an object.”; &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// calls obj.toString()</span></span><br><span class=\"line\">alert(obj);</span><br></pre></td></tr></table></figure>\n<p>记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDog = &#123;</span><br><span class=\"line\">    “name” : “Spot”,</span><br><span class=\"line\">    “bark” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; alert(“Woof!”); &#125;,</span><br><span class=\"line\">    “displayFullName” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name + “ The Alpha Dog”);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    “chaseMrPostman” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// implementation beyond the scope of this article </span></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myDog.displayFullName(); </span><br><span class=\"line\">myDog.bark(); <span class=\"comment\">// Woof!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`        </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">C++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### “this”随对象更改而更改</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayQuote</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the value of “this” will change; depends on </span></span><br><span class=\"line\">    <span class=\"comment\">// which object it is called through</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.memorableQuote);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> williamShakespeare = &#123;</span><br><span class=\"line\">    “memorableQuote”: “It is a wise father that knows his own child.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> markTwain = &#123;</span><br><span class=\"line\">    “memorableQuote”: “Golf is a good walk spoiled.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oscarWilde = &#123;</span><br><span class=\"line\">    “memorableQuote”: “True friends stab you <span class=\"keyword\">in</span> the front.” </span><br><span class=\"line\">    <span class=\"comment\">// we can call the function displayQuote</span></span><br><span class=\"line\">    <span class=\"comment\">// as a method of oscarWilde without assigning it </span></span><br><span class=\"line\">    <span class=\"comment\">// as oscarWilde’s method. </span></span><br><span class=\"line\">    <span class=\"comment\">//”sayIt” : displayQuote</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">williamShakespeare.sayIt(); <span class=\"comment\">// true, true</span></span><br><span class=\"line\">markTwain.sayIt(); <span class=\"comment\">// he didn’t know where to play golf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// watch this, each function has a method call()</span></span><br><span class=\"line\"><span class=\"comment\">// that allows the function to be called as a </span></span><br><span class=\"line\"><span class=\"comment\">// method of the object passed to call() as an</span></span><br><span class=\"line\"><span class=\"comment\">// argument. </span></span><br><span class=\"line\"><span class=\"comment\">// this line below is equivalent to assigning</span></span><br><span class=\"line\"><span class=\"comment\">// displayQuote to sayIt, and calling oscarWilde.sayIt().</span></span><br><span class=\"line\">displayQuote.call(oscarWilde); <span class=\"comment\">// ouch!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。</p>\n<p>有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> “not anymore!”;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alert!!! trampling the Global object!!!</span></span><br><span class=\"line\">x();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。</p>\n<pre><code>在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n</code></pre><h3 id=\"构造函数而不是类\"><a href=\"#构造函数而不是类\" class=\"headerlink\" title=\"构造函数而不是类\"></a>构造函数而不是类</h3><p>前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog spot = <span class=\"keyword\">new</span> Dog();</span><br></pre></td></tr></table></figure></p>\n<p>将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DogConstructor</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br><span class=\"line\">spot.respondTo(“Rover”); <span class=\"comment\">// nope</span></span><br><span class=\"line\">spot.respondTo(“Spot”); <span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<p>那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br></pre></td></tr></table></figure></p>\n<p>“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an empty object</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = &#123;&#125;; </span><br><span class=\"line\"><span class=\"comment\">// call the function as a method of the empty object</span></span><br><span class=\"line\">DogConstructor.call(spot, “Spot”);</span><br></pre></td></tr></table></figure>\n<p>正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Think of this as class Dog</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// instance variable </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// instance method? Hmmm...</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br></pre></td></tr></table></figure>\n<p>在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respondTo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// respondTo definition</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// attached this function as a method of the object</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = respondTo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。</p>\n<h2 id=\"三、Javascript核心理论原型\"><a href=\"#三、Javascript核心理论原型\" class=\"headerlink\" title=\"三、Javascript核心理论原型\"></a>三、Javascript核心理论原型</h2><p>在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buddy = <span class=\"keyword\">new</span> Dog(“Buddy“);</span><br></pre></td></tr></table></figure></p>\n<p>buddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。</p>\n<p>在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。</p>\n<p><img src=\"/imgs/ooj-1.gif\" alt=\"图A1 每个函数的原型都有一个 Constructor 属性\"></p>\n<p>现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。</p>\n<h1 id=\"代码段B1\"><a href=\"#代码段B1\" class=\"headerlink\" title=\"代码段B1\"></a>代码段B1</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog.prototype is the prototype of spot</span></span><br><span class=\"line\">alert(Dog.prototype.isPrototypeOf(spot));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// spot inherits the constructor property</span></span><br><span class=\"line\"><span class=\"comment\">// from Dog.prototype</span></span><br><span class=\"line\">alert(spot.constructor == Dog.prototype.constructor);</span><br><span class=\"line\">alert(spot.constructor == Dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But constructor property doesn’t belong</span></span><br><span class=\"line\"><span class=\"comment\">// to spot. The line below displays “false”</span></span><br><span class=\"line\">alert(spot.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br><span class=\"line\"></span><br><span class=\"line\">// The <span class=\"keyword\">constructor</span> property belongs to Dog.prototype</span><br><span class=\"line\">// The line below displays “true”</span><br><span class=\"line\">alert(Dog.prototype.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br></pre></td></tr></table></figure>\n<p><img src=\"/imgs/ooj-2.gif\" alt=\"图A2-实例继承其原型\"></p>\n<p>某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）<br>在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。<br>每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。<br>图A3 说明了此解析过程。</p>\n<p><img src=\"/imgs/ooj-3.gif\" alt=\"图A3 在原型链中解析 toString() 方法\"></p>\n<p>JavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：</p>\n<ul>\n<li>继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。</li>\n<li>如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。</li>\n<li>更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。</li>\n</ul>\n<p>代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。</p>\n<h2 id=\"代码段B2-继承原型\"><a href=\"#代码段B2-继承原型\" class=\"headerlink\" title=\"代码段B2-继承原型\"></a>代码段B2-继承原型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GreatDane</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rover = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"></span><br><span class=\"line\">GreatDane.prototype.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Works, even though at this point</span></span><br><span class=\"line\"><span class=\"comment\">// rover and spot are already created.</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this hides getBreed() in GreatDane.prototype</span></span><br><span class=\"line\">spot.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Little Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(spot.getBreed()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// but of course, the change to getBreed </span></span><br><span class=\"line\"><span class=\"comment\">// doesn’t propagate back to GreatDane.prototype</span></span><br><span class=\"line\"><span class=\"comment\">// and other objects inheriting from it,</span></span><br><span class=\"line\"><span class=\"comment\">// it only happens in the spot object</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态属性和方法\"><a href=\"#静态属性和方法\" class=\"headerlink\" title=\"静态属性和方法\"></a>静态属性和方法</h3><p>有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DateTime</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set static method now()</span></span><br><span class=\"line\">    DateTime.now = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert(DateTime.now());</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。<br>JavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。<br>假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。</p>\n<h1 id=\"代码段B3-根据谓词筛选元素\"><a href=\"#代码段B3-根据谓词筛选元素\" class=\"headerlink\" title=\"代码段B3 -根据谓词筛选元素\"></a>代码段B3 -根据谓词筛选元素</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">pred, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> filtered = []; <span class=\"comment\">// shorter version of new Array();</span></span><br><span class=\"line\">    <span class=\"comment\">// iterate through every element in the array...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = arr[i];</span><br><span class=\"line\">        <span class=\"comment\">// if the element satisfies the predicate let it through</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pred(val)) &#123;</span><br><span class=\"line\">            filtered.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filtered;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someRandomNumbers = [<span class=\"number\">12</span>, <span class=\"number\">32</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">234</span>, <span class=\"number\">236</span>, <span class=\"number\">632</span>,<span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbersGreaterThan100 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">100</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// displays 234, 236, 632</span></span><br><span class=\"line\">alert(numbersGreaterThan100);</span><br></pre></td></tr></table></figure>\n<p>但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan300 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">300</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br></pre></td></tr></table></figure></p>\n<p>然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeGreaterThanPredicate</span>(<span class=\"params\">lowerBound</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numberToCheck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (numberToCheck &gt; lowerBound) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，您就可以编写以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan10 = makeGreaterThanPredicate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> greaterThan100 = makeGreaterThanPredicate(<span class=\"number\">100</span>);</span><br><span class=\"line\">alert(filter(greaterThan10, someRandomNumbers));</span><br><span class=\"line\">alert(filter(greaterThan100, someRandomNumbers));</span><br></pre></td></tr></table></figure></p>\n<p>通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。</p>\n<p>开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。</p>\n<h2 id=\"模拟私有属性\"><a href=\"#模拟私有属性\" class=\"headerlink\" title=\"模拟私有属性\"></a>模拟私有属性</h2><p>现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> age; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newAge</span>) </span>&#123; age = newAge; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ray = <span class=\"keyword\">new</span> Person(“Ray”, <span class=\"number\">31</span>);</span><br><span class=\"line\">alert(ray.getName());</span><br><span class=\"line\">alert(ray.getAge());</span><br><span class=\"line\">ray.setName(“Younger Ray”);</span><br><span class=\"line\"><span class=\"comment\">// Instant rejuvenation!</span></span><br><span class=\"line\">ray.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">alert(ray.getName() + “ is now “ + ray.getAge() + </span><br><span class=\"line\">      “ years old.”);</span><br></pre></td></tr></table></figure>\n<p>未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> occupation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> occupation; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newOcc</span>) </span>&#123; occupation = </span><br><span class=\"line\">                         newOcc; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// accessors for name and age    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.somePublicMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// doesn’t work!</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(this.name);</span></span><br><span class=\"line\">    <span class=\"comment\">// this one below works</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.getName());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Douglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。</p>\n<h2 id=\"从类继承\"><a href=\"#从类继承\" class=\"headerlink\" title=\"从类继承\"></a>从类继承</h2><p>到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。<br>例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：</p>\n<p><img src=\"/imgs/ooj-4.gif\" alt=\"图A4-类图\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Pet</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pet</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This pet’s name is: “ + <span class=\"keyword\">this</span>.getName();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Pet</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parrotty = <span class=\"keyword\">new</span> Pet(“Parrotty the Parrot”);</span><br><span class=\"line\">alert(parrotty);</span><br></pre></td></tr></table></figure>\n<p>现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。</p>\n<h2 id=\"代码段B3-从PET类派生\"><a href=\"#代码段B3-从PET类派生\" class=\"headerlink\" title=\"代码段B3-从PET类派生\"></a>代码段B3-从PET类派生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Dog : Pet </span></span><br><span class=\"line\"><span class=\"comment\">// public Dog(string name, string breed)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, breed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// think Dog : base(name) </span></span><br><span class=\"line\">    Pet.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> breed; &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Breed doesn’t change, obviously! It’s read only.</span></span><br><span class=\"line\">    <span class=\"comment\">// this.setBreed = function(newBreed) &#123; name = newName; &#125;;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this makes Dog.prototype inherits</span></span><br><span class=\"line\"><span class=\"comment\">// from Pet.prototype</span></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Pet();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remember that Pet.prototype.constructor</span></span><br><span class=\"line\"><span class=\"comment\">// points to Pet. We want our Dog instances’</span></span><br><span class=\"line\"><span class=\"comment\">// constructor to point to Dog.</span></span><br><span class=\"line\">Dog.prototype.constructor = Dog;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Now we override Pet.prototype.toString</span></span><br><span class=\"line\">Dog.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This dog’s name is: “ + <span class=\"keyword\">this</span>.getName() + </span><br><span class=\"line\">        “, and its breed is: “ + <span class=\"keyword\">this</span>.getBreed();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Dog</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(“Buddy”, “Great Dane”);</span><br><span class=\"line\"><span class=\"comment\">// test the new toString()</span></span><br><span class=\"line\">alert(dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Testing instanceof (similar to the is operator)</span></span><br><span class=\"line\"><span class=\"comment\">// (dog is Dog)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Dog);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Pet)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Pet);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Object)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<p>所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。</p>\n<h2 id=\"模拟命名空间\"><a href=\"#模拟命名空间\" class=\"headerlink\" title=\"模拟命名空间\"></a>模拟命名空间</h2><p>在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code here &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// nested namespace “Examples”</span></span><br><span class=\"line\">MSDNMagNS.Examples = &#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Examples.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Examples.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Examples.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MSDNMagNS.Examples and Pet definition...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// think “using Eg = MSDNMagNS.Examples;” </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Eg = MSDNMagNS.Examples;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> Eg.Pet(“Yammer”);</span><br><span class=\"line\">alert(pet);</span><br></pre></td></tr></table></figure>\n<p>如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。</p>\n<h2 id=\"应当这样编写-JavaScript-代码吗？\"><a href=\"#应当这样编写-JavaScript-代码吗？\" class=\"headerlink\" title=\"应当这样编写 JavaScript 代码吗？\"></a>应当这样编写 JavaScript 代码吗？</h2><p>您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。<br>在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。</p>\n<p>这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。</p>\n<p>…更多内容请看下篇文章</p>\n<h2 id=\"四、作者总结\"><a href=\"#四、作者总结\" class=\"headerlink\" title=\"四、作者总结\"></a>四、作者总结</h2><p>　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。</p>\n<p>　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。</p>\n<p>　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。</p>\n<p>　　本文作者：朱峰（Peter Zhu）</p>\n<p>　　发表时间：2010-05-31</p>\n<h2 id=\"五、本文参考引用文章列表\"><a href=\"#五、本文参考引用文章列表\" class=\"headerlink\" title=\"五、本文参考引用文章列表\"></a>五、本文参考引用文章列表</h2><ol>\n<li><p>使用面向对象的技术创建高级Web 应用程序 <a href=\"http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx</a></p>\n</li>\n<li><p>百度知道 <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/125370.htm</a> </p>\n</li>\n<li><p>OOJ-面向对象的JAVASCRIPT - <a href=\"http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html\" target=\"_blank\" rel=\"noopener\">PeterZhu</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。<br>WEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。</p>\n<h2 id=\"一、面向对象的基础理论\"><a href=\"#一、面向对象的基础理论\" class=\"headerlink\" title=\"一、面向对象的基础理论\"></a>一、面向对象的基础理论</h2><p>百度知道里讲诉的已经非常清晰, <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">更多详情</a> ，这里纯理论的知识大家就自我学习。</p>\n<h2 id=\"二、OOJ概述\"><a href=\"#二、OOJ概述\" class=\"headerlink\" title=\"二、OOJ概述\"></a>二、OOJ概述</h2><p>javascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。</p>\n<h3 id=\"JavaScript-对象是词典\"><a href=\"#JavaScript-对象是词典\" class=\"headerlink\" title=\"JavaScript 对象是词典\"></a>JavaScript 对象是词典</h3><p>在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">userObject.lastLoginTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>的功能与下面的代码段完全相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123;&#125;; <span class=\"comment\">// equivalent to new Object()</span></span><br><span class=\"line\">userObject[“lastLoginTime”] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject[“lastLoginTime”]);</span><br></pre></td></tr></table></figure>\n<p> 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123; “lastLoginTime”: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() &#125;;</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字</p>\n<p>如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。</p>\n<p>接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。</p>\n<h3 id=\"JavaScript-函数的奇特性\"><a href=\"#JavaScript-函数的奇特性\" class=\"headerlink\" title=\"JavaScript 函数的奇特性\"></a>JavaScript 函数的奇特性</h3><p>大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(“blah”);</span><br></pre></td></tr></table></figure>\n<p> 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(“blah2”);</span><br></pre></td></tr></table></figure></p>\n<p> 甚至也可以像下面这样，使用 Function 构造函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(“x”, “alert(x);”);</span><br><span class=\"line\">func(“blah3”);</span><br></pre></td></tr></table></figure></p>\n<p> 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。</p>\n<p>为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hi, “ + x + “!”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.text = “Hello World!”;</span><br><span class=\"line\">sayHi[“text2”] = “Hello World... again.”;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sayHi[“text”]); <span class=\"comment\">// displays “Hello World!”</span></span><br><span class=\"line\">alert(sayHi.text2); <span class=\"comment\">// displays “Hello World... again.”</span></span><br></pre></td></tr></table></figure>\n<p>作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assign an anonymous function to a variable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hello, “ + x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">greet(“MSDN readers”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// passing a function as an argument to another</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operateOn</span>(<span class=\"params\">num, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(operateOn(<span class=\"number\">16</span>, square));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as return values</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIncrementer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = makeIncrementer();</span><br><span class=\"line\"><span class=\"comment\">// displays 8</span></span><br><span class=\"line\">alert(inc(<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions stored as array elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = arr[<span class=\"number\">0</span>](<span class=\"number\">2</span>);</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">arr[<span class=\"number\">3</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">2</span>]);</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as object properties</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; “toString” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> “This is an object.”; &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// calls obj.toString()</span></span><br><span class=\"line\">alert(obj);</span><br></pre></td></tr></table></figure>\n<p>记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDog = &#123;</span><br><span class=\"line\">    “name” : “Spot”,</span><br><span class=\"line\">    “bark” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; alert(“Woof!”); &#125;,</span><br><span class=\"line\">    “displayFullName” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name + “ The Alpha Dog”);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    “chaseMrPostman” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// implementation beyond the scope of this article </span></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myDog.displayFullName(); </span><br><span class=\"line\">myDog.bark(); <span class=\"comment\">// Woof!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`        </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">C++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### “this”随对象更改而更改</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayQuote</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the value of “this” will change; depends on </span></span><br><span class=\"line\">    <span class=\"comment\">// which object it is called through</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.memorableQuote);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> williamShakespeare = &#123;</span><br><span class=\"line\">    “memorableQuote”: “It is a wise father that knows his own child.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> markTwain = &#123;</span><br><span class=\"line\">    “memorableQuote”: “Golf is a good walk spoiled.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oscarWilde = &#123;</span><br><span class=\"line\">    “memorableQuote”: “True friends stab you <span class=\"keyword\">in</span> the front.” </span><br><span class=\"line\">    <span class=\"comment\">// we can call the function displayQuote</span></span><br><span class=\"line\">    <span class=\"comment\">// as a method of oscarWilde without assigning it </span></span><br><span class=\"line\">    <span class=\"comment\">// as oscarWilde’s method. </span></span><br><span class=\"line\">    <span class=\"comment\">//”sayIt” : displayQuote</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">williamShakespeare.sayIt(); <span class=\"comment\">// true, true</span></span><br><span class=\"line\">markTwain.sayIt(); <span class=\"comment\">// he didn’t know where to play golf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// watch this, each function has a method call()</span></span><br><span class=\"line\"><span class=\"comment\">// that allows the function to be called as a </span></span><br><span class=\"line\"><span class=\"comment\">// method of the object passed to call() as an</span></span><br><span class=\"line\"><span class=\"comment\">// argument. </span></span><br><span class=\"line\"><span class=\"comment\">// this line below is equivalent to assigning</span></span><br><span class=\"line\"><span class=\"comment\">// displayQuote to sayIt, and calling oscarWilde.sayIt().</span></span><br><span class=\"line\">displayQuote.call(oscarWilde); <span class=\"comment\">// ouch!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。</p>\n<p>有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> “not anymore!”;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alert!!! trampling the Global object!!!</span></span><br><span class=\"line\">x();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。</p>\n<pre><code>在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n</code></pre><h3 id=\"构造函数而不是类\"><a href=\"#构造函数而不是类\" class=\"headerlink\" title=\"构造函数而不是类\"></a>构造函数而不是类</h3><p>前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog spot = <span class=\"keyword\">new</span> Dog();</span><br></pre></td></tr></table></figure></p>\n<p>将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DogConstructor</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br><span class=\"line\">spot.respondTo(“Rover”); <span class=\"comment\">// nope</span></span><br><span class=\"line\">spot.respondTo(“Spot”); <span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<p>那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br></pre></td></tr></table></figure></p>\n<p>“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an empty object</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = &#123;&#125;; </span><br><span class=\"line\"><span class=\"comment\">// call the function as a method of the empty object</span></span><br><span class=\"line\">DogConstructor.call(spot, “Spot”);</span><br></pre></td></tr></table></figure>\n<p>正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Think of this as class Dog</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// instance variable </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// instance method? Hmmm...</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br></pre></td></tr></table></figure>\n<p>在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respondTo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// respondTo definition</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// attached this function as a method of the object</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = respondTo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。</p>\n<h2 id=\"三、Javascript核心理论原型\"><a href=\"#三、Javascript核心理论原型\" class=\"headerlink\" title=\"三、Javascript核心理论原型\"></a>三、Javascript核心理论原型</h2><p>在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buddy = <span class=\"keyword\">new</span> Dog(“Buddy“);</span><br></pre></td></tr></table></figure></p>\n<p>buddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。</p>\n<p>在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。</p>\n<p><img src=\"/imgs/ooj-1.gif\" alt=\"图A1 每个函数的原型都有一个 Constructor 属性\"></p>\n<p>现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。</p>\n<h1 id=\"代码段B1\"><a href=\"#代码段B1\" class=\"headerlink\" title=\"代码段B1\"></a>代码段B1</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog.prototype is the prototype of spot</span></span><br><span class=\"line\">alert(Dog.prototype.isPrototypeOf(spot));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// spot inherits the constructor property</span></span><br><span class=\"line\"><span class=\"comment\">// from Dog.prototype</span></span><br><span class=\"line\">alert(spot.constructor == Dog.prototype.constructor);</span><br><span class=\"line\">alert(spot.constructor == Dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But constructor property doesn’t belong</span></span><br><span class=\"line\"><span class=\"comment\">// to spot. The line below displays “false”</span></span><br><span class=\"line\">alert(spot.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br><span class=\"line\"></span><br><span class=\"line\">// The <span class=\"keyword\">constructor</span> property belongs to Dog.prototype</span><br><span class=\"line\">// The line below displays “true”</span><br><span class=\"line\">alert(Dog.prototype.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br></pre></td></tr></table></figure>\n<p><img src=\"/imgs/ooj-2.gif\" alt=\"图A2-实例继承其原型\"></p>\n<p>某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）<br>在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。<br>每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。<br>图A3 说明了此解析过程。</p>\n<p><img src=\"/imgs/ooj-3.gif\" alt=\"图A3 在原型链中解析 toString() 方法\"></p>\n<p>JavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：</p>\n<ul>\n<li>继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。</li>\n<li>如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。</li>\n<li>更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。</li>\n</ul>\n<p>代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。</p>\n<h2 id=\"代码段B2-继承原型\"><a href=\"#代码段B2-继承原型\" class=\"headerlink\" title=\"代码段B2-继承原型\"></a>代码段B2-继承原型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GreatDane</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rover = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"></span><br><span class=\"line\">GreatDane.prototype.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Works, even though at this point</span></span><br><span class=\"line\"><span class=\"comment\">// rover and spot are already created.</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this hides getBreed() in GreatDane.prototype</span></span><br><span class=\"line\">spot.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Little Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(spot.getBreed()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// but of course, the change to getBreed </span></span><br><span class=\"line\"><span class=\"comment\">// doesn’t propagate back to GreatDane.prototype</span></span><br><span class=\"line\"><span class=\"comment\">// and other objects inheriting from it,</span></span><br><span class=\"line\"><span class=\"comment\">// it only happens in the spot object</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态属性和方法\"><a href=\"#静态属性和方法\" class=\"headerlink\" title=\"静态属性和方法\"></a>静态属性和方法</h3><p>有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DateTime</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set static method now()</span></span><br><span class=\"line\">    DateTime.now = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert(DateTime.now());</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。<br>JavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。<br>假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。</p>\n<h1 id=\"代码段B3-根据谓词筛选元素\"><a href=\"#代码段B3-根据谓词筛选元素\" class=\"headerlink\" title=\"代码段B3 -根据谓词筛选元素\"></a>代码段B3 -根据谓词筛选元素</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">pred, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> filtered = []; <span class=\"comment\">// shorter version of new Array();</span></span><br><span class=\"line\">    <span class=\"comment\">// iterate through every element in the array...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = arr[i];</span><br><span class=\"line\">        <span class=\"comment\">// if the element satisfies the predicate let it through</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pred(val)) &#123;</span><br><span class=\"line\">            filtered.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filtered;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someRandomNumbers = [<span class=\"number\">12</span>, <span class=\"number\">32</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">234</span>, <span class=\"number\">236</span>, <span class=\"number\">632</span>,<span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbersGreaterThan100 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">100</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// displays 234, 236, 632</span></span><br><span class=\"line\">alert(numbersGreaterThan100);</span><br></pre></td></tr></table></figure>\n<p>但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan300 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">300</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br></pre></td></tr></table></figure></p>\n<p>然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeGreaterThanPredicate</span>(<span class=\"params\">lowerBound</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numberToCheck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (numberToCheck &gt; lowerBound) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，您就可以编写以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan10 = makeGreaterThanPredicate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> greaterThan100 = makeGreaterThanPredicate(<span class=\"number\">100</span>);</span><br><span class=\"line\">alert(filter(greaterThan10, someRandomNumbers));</span><br><span class=\"line\">alert(filter(greaterThan100, someRandomNumbers));</span><br></pre></td></tr></table></figure></p>\n<p>通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。</p>\n<p>开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。</p>\n<h2 id=\"模拟私有属性\"><a href=\"#模拟私有属性\" class=\"headerlink\" title=\"模拟私有属性\"></a>模拟私有属性</h2><p>现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> age; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newAge</span>) </span>&#123; age = newAge; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ray = <span class=\"keyword\">new</span> Person(“Ray”, <span class=\"number\">31</span>);</span><br><span class=\"line\">alert(ray.getName());</span><br><span class=\"line\">alert(ray.getAge());</span><br><span class=\"line\">ray.setName(“Younger Ray”);</span><br><span class=\"line\"><span class=\"comment\">// Instant rejuvenation!</span></span><br><span class=\"line\">ray.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">alert(ray.getName() + “ is now “ + ray.getAge() + </span><br><span class=\"line\">      “ years old.”);</span><br></pre></td></tr></table></figure>\n<p>未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> occupation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> occupation; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newOcc</span>) </span>&#123; occupation = </span><br><span class=\"line\">                         newOcc; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// accessors for name and age    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.somePublicMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// doesn’t work!</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(this.name);</span></span><br><span class=\"line\">    <span class=\"comment\">// this one below works</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.getName());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Douglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。</p>\n<h2 id=\"从类继承\"><a href=\"#从类继承\" class=\"headerlink\" title=\"从类继承\"></a>从类继承</h2><p>到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。<br>例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：</p>\n<p><img src=\"/imgs/ooj-4.gif\" alt=\"图A4-类图\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Pet</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pet</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This pet’s name is: “ + <span class=\"keyword\">this</span>.getName();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Pet</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parrotty = <span class=\"keyword\">new</span> Pet(“Parrotty the Parrot”);</span><br><span class=\"line\">alert(parrotty);</span><br></pre></td></tr></table></figure>\n<p>现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。</p>\n<h2 id=\"代码段B3-从PET类派生\"><a href=\"#代码段B3-从PET类派生\" class=\"headerlink\" title=\"代码段B3-从PET类派生\"></a>代码段B3-从PET类派生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Dog : Pet </span></span><br><span class=\"line\"><span class=\"comment\">// public Dog(string name, string breed)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, breed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// think Dog : base(name) </span></span><br><span class=\"line\">    Pet.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> breed; &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Breed doesn’t change, obviously! It’s read only.</span></span><br><span class=\"line\">    <span class=\"comment\">// this.setBreed = function(newBreed) &#123; name = newName; &#125;;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this makes Dog.prototype inherits</span></span><br><span class=\"line\"><span class=\"comment\">// from Pet.prototype</span></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Pet();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remember that Pet.prototype.constructor</span></span><br><span class=\"line\"><span class=\"comment\">// points to Pet. We want our Dog instances’</span></span><br><span class=\"line\"><span class=\"comment\">// constructor to point to Dog.</span></span><br><span class=\"line\">Dog.prototype.constructor = Dog;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Now we override Pet.prototype.toString</span></span><br><span class=\"line\">Dog.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This dog’s name is: “ + <span class=\"keyword\">this</span>.getName() + </span><br><span class=\"line\">        “, and its breed is: “ + <span class=\"keyword\">this</span>.getBreed();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Dog</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(“Buddy”, “Great Dane”);</span><br><span class=\"line\"><span class=\"comment\">// test the new toString()</span></span><br><span class=\"line\">alert(dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Testing instanceof (similar to the is operator)</span></span><br><span class=\"line\"><span class=\"comment\">// (dog is Dog)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Dog);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Pet)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Pet);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Object)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<p>所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。</p>\n<h2 id=\"模拟命名空间\"><a href=\"#模拟命名空间\" class=\"headerlink\" title=\"模拟命名空间\"></a>模拟命名空间</h2><p>在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code here &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// nested namespace “Examples”</span></span><br><span class=\"line\">MSDNMagNS.Examples = &#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Examples.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Examples.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Examples.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MSDNMagNS.Examples and Pet definition...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// think “using Eg = MSDNMagNS.Examples;” </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Eg = MSDNMagNS.Examples;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> Eg.Pet(“Yammer”);</span><br><span class=\"line\">alert(pet);</span><br></pre></td></tr></table></figure>\n<p>如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。</p>\n<h2 id=\"应当这样编写-JavaScript-代码吗？\"><a href=\"#应当这样编写-JavaScript-代码吗？\" class=\"headerlink\" title=\"应当这样编写 JavaScript 代码吗？\"></a>应当这样编写 JavaScript 代码吗？</h2><p>您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。<br>在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。</p>\n<p>这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。</p>\n<p>…更多内容请看下篇文章</p>\n<h2 id=\"四、作者总结\"><a href=\"#四、作者总结\" class=\"headerlink\" title=\"四、作者总结\"></a>四、作者总结</h2><p>　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。</p>\n<p>　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。</p>\n<p>　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。</p>\n<p>　　本文作者：朱峰（Peter Zhu）</p>\n<p>　　发表时间：2010-05-31</p>\n<h2 id=\"五、本文参考引用文章列表\"><a href=\"#五、本文参考引用文章列表\" class=\"headerlink\" title=\"五、本文参考引用文章列表\"></a>五、本文参考引用文章列表</h2><ol>\n<li><p>使用面向对象的技术创建高级Web 应用程序 <a href=\"http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx</a></p>\n</li>\n<li><p>百度知道 <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/125370.htm</a> </p>\n</li>\n<li><p>OOJ-面向对象的JAVASCRIPT - <a href=\"http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html\" target=\"_blank\" rel=\"noopener\">PeterZhu</a></p>\n</li>\n</ol>\n"},{"title":"OOJ-面向对象的JAVASCRIPT（二）","p":"javascript/OOJ-TWO","date":"2010-05-31T12:52:05.000Z","_content":"\n本文继上篇文章介绍javascript 匿名函数以及闭包的特性\n----------------\n\n## 1、什么叫匿名函数？\n\n　　匿名函数：就是没有函数名的函数。\n\n　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。\n\n1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式\n\n第一种：这也是最常规的一种\n\n``` JS\nfunction double( x ){\n\n    return 2 * x;  \n\n}\n``` \n\n第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。\n``` JS\nvar double = new Function( 'x'  , ' return 2 * x;');\n``` \n\n第三种：\n``` JS\nvar double = function( x ) { return 2* x; }\n``` \n\n注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。\n\n2、匿名函数的创建\n\n第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。\n\n第二种方式：\n``` JS\n(function( x , y){\n\n    alert( x + y); \n\n})(2 ,3 );//函数的自调用的形式，直接可以得出结果。\n```\n这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。\n\n## 2、闭包\n闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。\n\n闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。\n\n示例一：\n``` JS\nfunction checkClosure(){\n\n    var str = 'rain-man';\n\n    setTimeout(\n\n        function(){ alert( str ); } //这是一个匿名函数\n\n    , 2000);\n\n}//这个函数要求延迟2秒执行。\n\ncheckClosure();\n```\n这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。\n\n``` JS\n//示例二：优化代码\n\nfunction forTimeout( x, y){\n\n    alert( x + y );\n\n}\n\nfunction delay( x , y  , time ){\n    setTimeout( 'forTimeout(' +  x + ',' +  y + ')' , time );   \n}\n\n/**\n *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰\n\nfunction delay( x , y , time ){\n\n    setTimeout(\n\n        function(){\n\n            forTimeout( x , y )\n\n        }         \n\n    , time );  \n\n}\n*/\n```\n\n举例\n\n匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。\n\n``` JS\n//示例三：\nvar oEvent = {};\n(function(){\nvar addEvent = function(){ /*代码的实现省略了*/ };\nfunction removeEvent(){}\noEvent.addEvent = addEvent;\noEvent.removeEvent = removeEvent;\n})();\n```\n\n在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。\n\n我们要想使用此段代码：\n``` JS\noEvent.addEvent( document.getElementById('box') , 'click' , function(){} );\n```\n\n``` JS\n//示例四：\n\nvar rainman = (function( x , y ){\n    return x + y;\n})( 2 , 3 );\n/**\n *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。\nvar rainman = function( x , y ){\n    return x + y;\n}( 2 , 3 );\n*/\n```\n\n在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。\n\n``` JS\n示例五：\n\nvar outer = null;\n(function(){\nvar one = 1;\nfunction inner (){\n    one += 1;\n    alert( one );\n}\nouter = inner;\n})();\nouter();    //2\nouter();    //3\nouter();    //4\n\n```\n\n这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。\n\n注意\n\n一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。\n\n``` JS\n示例六：\n\n/**\n<body>\n<ul>\n    <li>one</li>\n    <li>two</li>\n    <li>three</li>\n    <li>one</li>\n</ul>\n*/\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].onmouseover = function(){\n        alert( i );       };\n}\n```\n\n你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。\n\n``` JS\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。\n\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n解决方法一：\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    (function( index ){\n        lists[ index ].onmouseover = function(){\n            alert( index );   \n        };                   \n    })( i );//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。\n}\n\n解决方法二：\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].$$index = i;    //通过在Dom元素上绑定$$index属性记录下标\n    lists[ i ].onmouseover = function(){\n        alert( this.$$index );   \n    };\n}\n\n解决方法三：\n\nfunction eventListener( list , index ){\n    list.onmouseover = function(){\n        alert(index);\n    };\n}\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    eventListener( lists[ i ] , i );\n}\n```","source":"_posts/javascript/OOJ-TWO.md","raw":"---\ntitle: OOJ-面向对象的JAVASCRIPT（二）\np: javascript/OOJ-TWO\ndate: 2010-05-31 20:52:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n本文继上篇文章介绍javascript 匿名函数以及闭包的特性\n----------------\n\n## 1、什么叫匿名函数？\n\n　　匿名函数：就是没有函数名的函数。\n\n　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。\n\n1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式\n\n第一种：这也是最常规的一种\n\n``` JS\nfunction double( x ){\n\n    return 2 * x;  \n\n}\n``` \n\n第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。\n``` JS\nvar double = new Function( 'x'  , ' return 2 * x;');\n``` \n\n第三种：\n``` JS\nvar double = function( x ) { return 2* x; }\n``` \n\n注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。\n\n2、匿名函数的创建\n\n第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。\n\n第二种方式：\n``` JS\n(function( x , y){\n\n    alert( x + y); \n\n})(2 ,3 );//函数的自调用的形式，直接可以得出结果。\n```\n这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。\n\n## 2、闭包\n闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。\n\n闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。\n\n示例一：\n``` JS\nfunction checkClosure(){\n\n    var str = 'rain-man';\n\n    setTimeout(\n\n        function(){ alert( str ); } //这是一个匿名函数\n\n    , 2000);\n\n}//这个函数要求延迟2秒执行。\n\ncheckClosure();\n```\n这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。\n\n``` JS\n//示例二：优化代码\n\nfunction forTimeout( x, y){\n\n    alert( x + y );\n\n}\n\nfunction delay( x , y  , time ){\n    setTimeout( 'forTimeout(' +  x + ',' +  y + ')' , time );   \n}\n\n/**\n *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰\n\nfunction delay( x , y , time ){\n\n    setTimeout(\n\n        function(){\n\n            forTimeout( x , y )\n\n        }         \n\n    , time );  \n\n}\n*/\n```\n\n举例\n\n匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。\n\n``` JS\n//示例三：\nvar oEvent = {};\n(function(){\nvar addEvent = function(){ /*代码的实现省略了*/ };\nfunction removeEvent(){}\noEvent.addEvent = addEvent;\noEvent.removeEvent = removeEvent;\n})();\n```\n\n在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。\n\n我们要想使用此段代码：\n``` JS\noEvent.addEvent( document.getElementById('box') , 'click' , function(){} );\n```\n\n``` JS\n//示例四：\n\nvar rainman = (function( x , y ){\n    return x + y;\n})( 2 , 3 );\n/**\n *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。\nvar rainman = function( x , y ){\n    return x + y;\n}( 2 , 3 );\n*/\n```\n\n在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。\n\n``` JS\n示例五：\n\nvar outer = null;\n(function(){\nvar one = 1;\nfunction inner (){\n    one += 1;\n    alert( one );\n}\nouter = inner;\n})();\nouter();    //2\nouter();    //3\nouter();    //4\n\n```\n\n这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。\n\n注意\n\n一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。\n\n``` JS\n示例六：\n\n/**\n<body>\n<ul>\n    <li>one</li>\n    <li>two</li>\n    <li>three</li>\n    <li>one</li>\n</ul>\n*/\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].onmouseover = function(){\n        alert( i );       };\n}\n```\n\n你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。\n\n``` JS\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。\n\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n解决方法一：\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    (function( index ){\n        lists[ index ].onmouseover = function(){\n            alert( index );   \n        };                   \n    })( i );//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。\n}\n\n解决方法二：\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].$$index = i;    //通过在Dom元素上绑定$$index属性记录下标\n    lists[ i ].onmouseover = function(){\n        alert( this.$$index );   \n    };\n}\n\n解决方法三：\n\nfunction eventListener( list , index ){\n    list.onmouseover = function(){\n        alert(index);\n    };\n}\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    eventListener( lists[ i ] , i );\n}\n```","slug":"javascript/OOJ-TWO","published":1,"updated":"2017-12-27T06:07:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcpc000ba4e3xzo3xbzh","content":"<h2 id=\"本文继上篇文章介绍javascript-匿名函数以及闭包的特性\"><a href=\"#本文继上篇文章介绍javascript-匿名函数以及闭包的特性\" class=\"headerlink\" title=\"本文继上篇文章介绍javascript 匿名函数以及闭包的特性\"></a>本文继上篇文章介绍javascript 匿名函数以及闭包的特性</h2><h2 id=\"1、什么叫匿名函数？\"><a href=\"#1、什么叫匿名函数？\" class=\"headerlink\" title=\"1、什么叫匿名函数？\"></a>1、什么叫匿名函数？</h2><p>　　匿名函数：就是没有函数名的函数。</p>\n<p>　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。</p>\n<p>1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式</p>\n<p>第一种：这也是最常规的一种</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\"> x </span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * x;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>( <span class=\"string\">'x'</span>  , <span class=\"string\">' return 2 * x;'</span>);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第三种：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x </span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>* x; &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2、匿名函数的创建</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种方式：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y); </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span> ,<span class=\"number\">3</span> );<span class=\"comment\">//函数的自调用的形式，直接可以得出结果。</span></span><br></pre></td></tr></table></figure>\n<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。</p>\n<h2 id=\"2、闭包\"><a href=\"#2、闭包\" class=\"headerlink\" title=\"2、闭包\"></a>2、闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p>\n<p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p>\n<p>示例一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkClosure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'rain-man'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; alert( str ); &#125; <span class=\"comment\">//这是一个匿名函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    , <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">//这个函数要求延迟2秒执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">checkClosure();</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例二：优化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forTimeout</span>(<span class=\"params\"> x, y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\"> x , y  , time </span>)</span>&#123;</span><br><span class=\"line\">    setTimeout( <span class=\"string\">'forTimeout('</span> +  x + <span class=\"string\">','</span> +  y + <span class=\"string\">')'</span> , time );   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">function delay( x , y , time )&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    setTimeout(</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        function()&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">            forTimeout( x , y )</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        &#125;         </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    , time );  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>举例</p>\n<p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例三：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oEvent = &#123;&#125;;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/*代码的实现省略了*/</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeEvent</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">oEvent.addEvent = addEvent;</span><br><span class=\"line\">oEvent.removeEvent = removeEvent;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>\n<p>我们要想使用此段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oEvent.addEvent( <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>) , <span class=\"string\">'click'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; );</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例四：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainman = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;)( <span class=\"number\">2</span> , <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。</span></span><br><span class=\"line\"><span class=\"comment\">var rainman = function( x , y )&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return x + y;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;( 2 , 3 );</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例五：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    one += <span class=\"number\">1</span>;</span><br><span class=\"line\">    alert( one );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer = inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">outer();    <span class=\"comment\">//2</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//3</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。</p>\n<p>注意</p>\n<p>一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例六：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;two&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;three&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( i );       &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</li></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。</span><br><span class=\"line\"></span><br><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法一：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> index </span>)</span>&#123;</span><br><span class=\"line\">        lists[ index ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert( index );   </span><br><span class=\"line\">        &#125;;                   </span><br><span class=\"line\">    &#125;)( i );<span class=\"comment\">//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法二：</span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].$$index = i;    <span class=\"comment\">//通过在Dom元素上绑定$$index属性记录下标</span></span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( <span class=\"keyword\">this</span>.$$index );   </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法三：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventListener</span>(<span class=\"params\"> list , index </span>)</span>&#123;</span><br><span class=\"line\">    list.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    eventListener( lists[ i ] , i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"本文继上篇文章介绍javascript-匿名函数以及闭包的特性\"><a href=\"#本文继上篇文章介绍javascript-匿名函数以及闭包的特性\" class=\"headerlink\" title=\"本文继上篇文章介绍javascript 匿名函数以及闭包的特性\"></a>本文继上篇文章介绍javascript 匿名函数以及闭包的特性</h2><h2 id=\"1、什么叫匿名函数？\"><a href=\"#1、什么叫匿名函数？\" class=\"headerlink\" title=\"1、什么叫匿名函数？\"></a>1、什么叫匿名函数？</h2><p>　　匿名函数：就是没有函数名的函数。</p>\n<p>　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。</p>\n<p>1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式</p>\n<p>第一种：这也是最常规的一种</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\"> x </span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * x;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>( <span class=\"string\">'x'</span>  , <span class=\"string\">' return 2 * x;'</span>);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第三种：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x </span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>* x; &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2、匿名函数的创建</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种方式：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y); </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span> ,<span class=\"number\">3</span> );<span class=\"comment\">//函数的自调用的形式，直接可以得出结果。</span></span><br></pre></td></tr></table></figure>\n<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。</p>\n<h2 id=\"2、闭包\"><a href=\"#2、闭包\" class=\"headerlink\" title=\"2、闭包\"></a>2、闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p>\n<p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p>\n<p>示例一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkClosure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'rain-man'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; alert( str ); &#125; <span class=\"comment\">//这是一个匿名函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    , <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">//这个函数要求延迟2秒执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">checkClosure();</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例二：优化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forTimeout</span>(<span class=\"params\"> x, y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\"> x , y  , time </span>)</span>&#123;</span><br><span class=\"line\">    setTimeout( <span class=\"string\">'forTimeout('</span> +  x + <span class=\"string\">','</span> +  y + <span class=\"string\">')'</span> , time );   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">function delay( x , y , time )&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    setTimeout(</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        function()&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">            forTimeout( x , y )</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        &#125;         </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    , time );  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>举例</p>\n<p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例三：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oEvent = &#123;&#125;;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/*代码的实现省略了*/</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeEvent</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">oEvent.addEvent = addEvent;</span><br><span class=\"line\">oEvent.removeEvent = removeEvent;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>\n<p>我们要想使用此段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oEvent.addEvent( <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>) , <span class=\"string\">'click'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; );</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例四：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainman = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;)( <span class=\"number\">2</span> , <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。</span></span><br><span class=\"line\"><span class=\"comment\">var rainman = function( x , y )&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return x + y;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;( 2 , 3 );</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例五：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    one += <span class=\"number\">1</span>;</span><br><span class=\"line\">    alert( one );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer = inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">outer();    <span class=\"comment\">//2</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//3</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。</p>\n<p>注意</p>\n<p>一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例六：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;two&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;three&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( i );       &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</li></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。</span><br><span class=\"line\"></span><br><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法一：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> index </span>)</span>&#123;</span><br><span class=\"line\">        lists[ index ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert( index );   </span><br><span class=\"line\">        &#125;;                   </span><br><span class=\"line\">    &#125;)( i );<span class=\"comment\">//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法二：</span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].$$index = i;    <span class=\"comment\">//通过在Dom元素上绑定$$index属性记录下标</span></span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( <span class=\"keyword\">this</span>.$$index );   </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法三：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventListener</span>(<span class=\"params\"> list , index </span>)</span>&#123;</span><br><span class=\"line\">    list.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    eventListener( lists[ i ] , i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript模块化 --- Commonjs、AMD、CMD、ES6 Modules","p":"javascript/modules-one","date":"2015-01-01T12:26:12.000Z","_content":"\n随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化。\n\nJavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。\n\n### 第一阶段：无模块化\n\nJavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。\n\n后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样：\n\n``` JS\n<script src=\"jquery.js\"></script>\n<script src=\"jquery_scroller.js\"></script>\n<script src=\"main.js\"></script>\n<script src=\"other1.js\"></script>\n<script src=\"other2.js\"></script>\n<script src=\"other3.js\"></script>\n```\n\n即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。\n\n优点：\n------\n\n相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　\n\n缺点：\n-------\n污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。\n\n对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。\n依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。\n\n### 第二阶段： CommonJS规范\n\nCommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。\n\n根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。\n\nCommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示：\n``` JS\n// a.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n```\n这里的a.js就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的x和addX。\n\nexports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码：\n``` JS\nexports = module.exports\n```\n所以，我们不能直接给exports赋值，比如number、function等。\n\n然后我们就可以在其他模块中引入这个模块使用了：\n``` JS\nvar a = require('./a.js');\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n```\n这里的require就会获取到a.js所暴露的module.exports变量，然后就可以使用其暴露的x和addX了。\n\n优点：\n------------\nCommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。\n\n缺点：\n-------------\n此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。\n\n### 第三阶段： AMD规范\n\n之前提到: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。\n\nAMD标准中，定义了下面两个API：\n``` JS\n1. require([module], callback)\n2. define(id, [depends], callback)\n```\n即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。\n\n定义alert模块：\n``` JS\ndefine(function () {\n    var alertName = function (str) {\n      alert(\"I am \" + str);\n    }\n    var alertAge = function (num) {\n      alert(\"I am \" + num + \" years old\");\n    }\n    return {\n      alertName: alertName,\n      alertAge: alertAge\n    };\n});\n```\n\n引入模块：\n``` JS\nrequire(['alert'], function (alert) {\n  alert.alertName('JohnZhu');\n  alert.alertAge(21);\n});\n```\n但是，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。\n\n优点：\n---------\n适合在浏览器环境中异步加载模块。可以并行加载多个模块。\n\n缺点：\n-----------\n提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。\n\n### 第四阶段：CMD规范\n\nCMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：\n\n``` JS\ndefine(function(require, exports, module) {\n  var $ = require('jquery');\n  var Spinning = require('./spinning');\n  exports.doSomething = ...\n  module.exports = ...\n})\n```\n\n优点：\n-----------\n同样实现了浏览器端的模块化加载。\n可以按需加载，依赖就近。\n\n缺点：\n------------\n依赖SPM打包，模块的加载逻辑偏重。\n\n其实，这时我们就可以看出AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下：\n\n``` JS\n// AMD\ndefine(['./a', './b'], function(a, b) {  // 依赖必须一开始就写好  \n   a.doSomething()    \n   // 此处略去 100 行    \n   b.doSomething()    \n   ...\n});\n// CMD\ndefine(function(require, exports, module) {\n   var a = require('./a')   \n   a.doSomething()   \n   // 此处略去 100 行   \n   var b = require('./b') \n   // 依赖可以就近书写   \n   b.doSomething()\n   // ... \n});\n```\n\n### 第五阶段： ES6模块化\n\n之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。\n\n虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如：\n\n``` JS\nimport store from '../store/index'\nimport {mapState, mapMutations, mapActions} from 'vuex'\nimport axios from '../assets/js/request'\nimport util from '../utils/js/util.js'\n\nexport default {\ncreated () {\n    this.getClassify(); \n    this.RESET_VALUE();\n    console.log('created' ,new Date().getTime());\n}\n``` ","source":"_posts/javascript/modules-one.md","raw":"---\ntitle: JavaScript模块化 --- Commonjs、AMD、CMD、ES6 Modules\np: javascript/modules-one\ndate: 2015-1-1 20:26:12\ntags: [JS,Javascript, commonjs, AMD, CMD, ES6]\ncategories: Javascript\n---\n\n随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化。\n\nJavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。\n\n### 第一阶段：无模块化\n\nJavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。\n\n后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样：\n\n``` JS\n<script src=\"jquery.js\"></script>\n<script src=\"jquery_scroller.js\"></script>\n<script src=\"main.js\"></script>\n<script src=\"other1.js\"></script>\n<script src=\"other2.js\"></script>\n<script src=\"other3.js\"></script>\n```\n\n即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。\n\n优点：\n------\n\n相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　\n\n缺点：\n-------\n污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。\n\n对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。\n依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。\n\n### 第二阶段： CommonJS规范\n\nCommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。\n\n根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。\n\nCommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示：\n``` JS\n// a.js\nvar x = 5;\nvar addX = function (value) {\n  return value + x;\n};\nmodule.exports.x = x;\nmodule.exports.addX = addX;\n```\n这里的a.js就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的x和addX。\n\nexports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码：\n``` JS\nexports = module.exports\n```\n所以，我们不能直接给exports赋值，比如number、function等。\n\n然后我们就可以在其他模块中引入这个模块使用了：\n``` JS\nvar a = require('./a.js');\nconsole.log(example.x); // 5\nconsole.log(example.addX(1)); // 6\n```\n这里的require就会获取到a.js所暴露的module.exports变量，然后就可以使用其暴露的x和addX了。\n\n优点：\n------------\nCommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。\n\n缺点：\n-------------\n此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。\n\n### 第三阶段： AMD规范\n\n之前提到: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。\n\nAMD标准中，定义了下面两个API：\n``` JS\n1. require([module], callback)\n2. define(id, [depends], callback)\n```\n即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。\n\n定义alert模块：\n``` JS\ndefine(function () {\n    var alertName = function (str) {\n      alert(\"I am \" + str);\n    }\n    var alertAge = function (num) {\n      alert(\"I am \" + num + \" years old\");\n    }\n    return {\n      alertName: alertName,\n      alertAge: alertAge\n    };\n});\n```\n\n引入模块：\n``` JS\nrequire(['alert'], function (alert) {\n  alert.alertName('JohnZhu');\n  alert.alertAge(21);\n});\n```\n但是，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。\n\n优点：\n---------\n适合在浏览器环境中异步加载模块。可以并行加载多个模块。\n\n缺点：\n-----------\n提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。\n\n### 第四阶段：CMD规范\n\nCMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：\n\n``` JS\ndefine(function(require, exports, module) {\n  var $ = require('jquery');\n  var Spinning = require('./spinning');\n  exports.doSomething = ...\n  module.exports = ...\n})\n```\n\n优点：\n-----------\n同样实现了浏览器端的模块化加载。\n可以按需加载，依赖就近。\n\n缺点：\n------------\n依赖SPM打包，模块的加载逻辑偏重。\n\n其实，这时我们就可以看出AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下：\n\n``` JS\n// AMD\ndefine(['./a', './b'], function(a, b) {  // 依赖必须一开始就写好  \n   a.doSomething()    \n   // 此处略去 100 行    \n   b.doSomething()    \n   ...\n});\n// CMD\ndefine(function(require, exports, module) {\n   var a = require('./a')   \n   a.doSomething()   \n   // 此处略去 100 行   \n   var b = require('./b') \n   // 依赖可以就近书写   \n   b.doSomething()\n   // ... \n});\n```\n\n### 第五阶段： ES6模块化\n\n之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。\n\n虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如：\n\n``` JS\nimport store from '../store/index'\nimport {mapState, mapMutations, mapActions} from 'vuex'\nimport axios from '../assets/js/request'\nimport util from '../utils/js/util.js'\n\nexport default {\ncreated () {\n    this.getClassify(); \n    this.RESET_VALUE();\n    console.log('created' ,new Date().getTime());\n}\n``` ","slug":"javascript/modules-one","published":1,"updated":"2017-12-27T12:38:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc0atcpd000ca4e3verv0ts4","content":"<p>随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化。</p>\n<p>JavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。</p>\n<h3 id=\"第一阶段：无模块化\"><a href=\"#第一阶段：无模块化\" class=\"headerlink\" title=\"第一阶段：无模块化\"></a>第一阶段：无模块化</h3><p>JavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。</p>\n<p>后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"jquery.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"jquery_scroller.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"main.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other1.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other2.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other3.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。</p>\n<p>对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。<br>依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。</p>\n<h3 id=\"第二阶段：-CommonJS规范\"><a href=\"#第二阶段：-CommonJS规范\" class=\"headerlink\" title=\"第二阶段： CommonJS规范\"></a>第二阶段： CommonJS规范</h3><p>CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。</p>\n<p>根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p>\n<p>CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addX = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value + x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.x = x;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure></p>\n<p>这里的a.js就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的x和addX。</p>\n<p>exports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们不能直接给exports赋值，比如number、function等。</p>\n<p>然后我们就可以在其他模块中引入这个模块使用了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(example.x); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(example.addX(<span class=\"number\">1</span>)); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的require就会获取到a.js所暴露的module.exports变量，然后就可以使用其暴露的x和addX了。</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。</p>\n<h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。</p>\n<h3 id=\"第三阶段：-AMD规范\"><a href=\"#第三阶段：-AMD规范\" class=\"headerlink\" title=\"第三阶段： AMD规范\"></a>第三阶段： AMD规范</h3><p>之前提到: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。</p>\n<p>AMD标准中，定义了下面两个API：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">require</span>([<span class=\"built_in\">module</span>], callback)</span><br><span class=\"line\"><span class=\"number\">2.</span> define(id, [depends], callback)</span><br></pre></td></tr></table></figure></p>\n<p>即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。</p>\n<p>定义alert模块：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> alertName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"I am \"</span> + str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> alertAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"I am \"</span> + num + <span class=\"string\">\" years old\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      alertName: alertName,</span><br><span class=\"line\">      alertAge: alertAge</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>引入模块：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'alert'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">alert</span>) </span>&#123;</span><br><span class=\"line\">  alert.alertName(<span class=\"string\">'JohnZhu'</span>);</span><br><span class=\"line\">  alert.alertAge(<span class=\"number\">21</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>但是，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。</p>\n<h2 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>适合在浏览器环境中异步加载模块。可以并行加载多个模块。</p>\n<h2 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。</p>\n<h3 id=\"第四阶段：CMD规范\"><a href=\"#第四阶段：CMD规范\" class=\"headerlink\" title=\"第四阶段：CMD规范\"></a>第四阶段：CMD规范</h3><p>CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);</span><br><span class=\"line\">  exports.doSomething = ...</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>同样实现了浏览器端的模块化加载。<br>可以按需加载，依赖就近。</p>\n<h2 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>依赖SPM打包，模块的加载逻辑偏重。</p>\n<p>其实，这时我们就可以看出AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖必须一开始就写好  </span></span><br><span class=\"line\">   a.doSomething()    </span><br><span class=\"line\">   <span class=\"comment\">// 此处略去 100 行    </span></span><br><span class=\"line\">   b.doSomething()    </span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)   </span><br><span class=\"line\">   a.doSomething()   </span><br><span class=\"line\">   <span class=\"comment\">// 此处略去 100 行   </span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) </span><br><span class=\"line\">   <span class=\"comment\">// 依赖可以就近书写   </span></span><br><span class=\"line\">   b.doSomething()</span><br><span class=\"line\">   <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五阶段：-ES6模块化\"><a href=\"#第五阶段：-ES6模块化\" class=\"headerlink\" title=\"第五阶段： ES6模块化\"></a>第五阶段： ES6模块化</h3><p>之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。</p>\n<p>虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如：</p>\n<pre><code class=\"JS\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'../store/index'</span>\n<span class=\"keyword\">import</span> {mapState, mapMutations, mapActions} <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>\n<span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'../assets/js/request'</span>\n<span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">'../utils/js/util.js'</span>\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> {\ncreated () {\n    <span class=\"keyword\">this</span>.getClassify(); \n    <span class=\"keyword\">this</span>.RESET_VALUE();\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'created'</span> ,<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化。</p>\n<p>JavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。</p>\n<h3 id=\"第一阶段：无模块化\"><a href=\"#第一阶段：无模块化\" class=\"headerlink\" title=\"第一阶段：无模块化\"></a>第一阶段：无模块化</h3><p>JavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。</p>\n<p>后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"jquery.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"jquery_scroller.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"main.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other1.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other2.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"other3.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。</p>\n<h2 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的。　</p>\n<h2 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。</p>\n<p>对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。<br>依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。</p>\n<h3 id=\"第二阶段：-CommonJS规范\"><a href=\"#第二阶段：-CommonJS规范\" class=\"headerlink\" title=\"第二阶段： CommonJS规范\"></a>第二阶段： CommonJS规范</h3><p>CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。</p>\n<p>根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p>\n<p>CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addX = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value + x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.x = x;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure></p>\n<p>这里的a.js就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的x和addX。</p>\n<p>exports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports = <span class=\"built_in\">module</span>.exports</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们不能直接给exports赋值，比如number、function等。</p>\n<p>然后我们就可以在其他模块中引入这个模块使用了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a.js'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(example.x); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(example.addX(<span class=\"number\">1</span>)); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></p>\n<p>这里的require就会获取到a.js所暴露的module.exports变量，然后就可以使用其暴露的x和addX了。</p>\n<h2 id=\"优点：-1\"><a href=\"#优点：-1\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。</p>\n<h2 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。</p>\n<h3 id=\"第三阶段：-AMD规范\"><a href=\"#第三阶段：-AMD规范\" class=\"headerlink\" title=\"第三阶段： AMD规范\"></a>第三阶段： AMD规范</h3><p>之前提到: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了。</p>\n<p>AMD标准中，定义了下面两个API：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">require</span>([<span class=\"built_in\">module</span>], callback)</span><br><span class=\"line\"><span class=\"number\">2.</span> define(id, [depends], callback)</span><br></pre></td></tr></table></figure></p>\n<p>即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。</p>\n<p>定义alert模块：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> alertName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"I am \"</span> + str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> alertAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">      alert(<span class=\"string\">\"I am \"</span> + num + <span class=\"string\">\" years old\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      alertName: alertName,</span><br><span class=\"line\">      alertAge: alertAge</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>引入模块：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'alert'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">alert</span>) </span>&#123;</span><br><span class=\"line\">  alert.alertName(<span class=\"string\">'JohnZhu'</span>);</span><br><span class=\"line\">  alert.alertAge(<span class=\"number\">21</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>但是，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。</p>\n<h2 id=\"优点：-2\"><a href=\"#优点：-2\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>适合在浏览器环境中异步加载模块。可以并行加载多个模块。</p>\n<h2 id=\"缺点：-2\"><a href=\"#缺点：-2\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。</p>\n<h3 id=\"第四阶段：CMD规范\"><a href=\"#第四阶段：CMD规范\" class=\"headerlink\" title=\"第四阶段：CMD规范\"></a>第四阶段：CMD规范</h3><p>CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);</span><br><span class=\"line\">  exports.doSomething = ...</span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"优点：-3\"><a href=\"#优点：-3\" class=\"headerlink\" title=\"优点：\"></a>优点：</h2><p>同样实现了浏览器端的模块化加载。<br>可以按需加载，依赖就近。</p>\n<h2 id=\"缺点：-3\"><a href=\"#缺点：-3\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h2><p>依赖SPM打包，模块的加载逻辑偏重。</p>\n<p>其实，这时我们就可以看出AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AMD</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;  <span class=\"comment\">// 依赖必须一开始就写好  </span></span><br><span class=\"line\">   a.doSomething()    </span><br><span class=\"line\">   <span class=\"comment\">// 此处略去 100 行    </span></span><br><span class=\"line\">   b.doSomething()    </span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)   </span><br><span class=\"line\">   a.doSomething()   </span><br><span class=\"line\">   <span class=\"comment\">// 此处略去 100 行   </span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) </span><br><span class=\"line\">   <span class=\"comment\">// 依赖可以就近书写   </span></span><br><span class=\"line\">   b.doSomething()</span><br><span class=\"line\">   <span class=\"comment\">// ... </span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"第五阶段：-ES6模块化\"><a href=\"#第五阶段：-ES6模块化\" class=\"headerlink\" title=\"第五阶段： ES6模块化\"></a>第五阶段： ES6模块化</h3><p>之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的，但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。</p>\n<p>虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如：</p>\n<pre><code class=\"JS\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'../store/index'</span>\n<span class=\"keyword\">import</span> {mapState, mapMutations, mapActions} <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span>\n<span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">'../assets/js/request'</span>\n<span class=\"keyword\">import</span> util <span class=\"keyword\">from</span> <span class=\"string\">'../utils/js/util.js'</span>\n\n<span class=\"keyword\">export</span> <span class=\"keyword\">default</span> {\ncreated () {\n    <span class=\"keyword\">this</span>.getClassify(); \n    <span class=\"keyword\">this</span>.RESET_VALUE();\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'created'</span> ,<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime());\n}\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjc0atcp50005a4e3el7n1p3h","category_id":"cjc0atcpa0007a4e381fsuie5","_id":"cjc0atcpg000ga4e321yr6gqy"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","category_id":"cjc0atcpf000da4e3nyqw1jfg","_id":"cjc0atcpj000ka4e31v9m3pbz"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","category_id":"cjc0atcpf000da4e3nyqw1jfg","_id":"cjc0atcpl000na4e3lr4kq9q7"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","category_id":"cjc0atcpf000da4e3nyqw1jfg","_id":"cjc0atcpl000pa4e3egpoi11p"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","category_id":"cjc0atcpf000da4e3nyqw1jfg","_id":"cjc0atcpm000ra4e3ndmzud1s"}],"PostTag":[{"post_id":"cjc0atcoy0002a4e395bnyybg","tag_id":"cjc0atcp10004a4e3hl7h92om","_id":"cjc0atcpc000aa4e3t8adqhzv"},{"post_id":"cjc0atcoz0003a4e332qb290x","tag_id":"cjc0atcpb0009a4e3up8n72xy","_id":"cjc0atcpg000fa4e3q4ivfp4x"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpf000ea4e3fw0ryrfd","_id":"cjc0atcpn000ua4e38ozutp58"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpi000ia4e3kkj7lfyb","_id":"cjc0atcpn000va4e39t77kf53"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpk000la4e3y2gkimkv","_id":"cjc0atcpn000xa4e3wdmkgwly"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpl000oa4e30zmmf7qi","_id":"cjc0atcpn000ya4e3gbhtwmss"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpm000qa4e39kfhlt7y","_id":"cjc0atcpn0010a4e309dqlfzl"},{"post_id":"cjc0atcp70006a4e3v7cpy65b","tag_id":"cjc0atcpm000sa4e310to69d9","_id":"cjc0atcpo0011a4e3hjd4yofl"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpf000ea4e3fw0ryrfd","_id":"cjc0atcpp0016a4e3esdsk6th"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpi000ia4e3kkj7lfyb","_id":"cjc0atcpp0017a4e3q606ifgl"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpk000la4e3y2gkimkv","_id":"cjc0atcpp0019a4e3v89bo09f"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpl000oa4e30zmmf7qi","_id":"cjc0atcpp001aa4e37gy5sty2"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpm000qa4e39kfhlt7y","_id":"cjc0atcpp001ca4e3vuwbh9w9"},{"post_id":"cjc0atcpa0008a4e3w9yar7kt","tag_id":"cjc0atcpm000sa4e310to69d9","_id":"cjc0atcpq001da4e3is3qqcqw"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpf000ea4e3fw0ryrfd","_id":"cjc0atcpt001ia4e3p8l0dd29"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpi000ia4e3kkj7lfyb","_id":"cjc0atcpt001ja4e357bha017"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpk000la4e3y2gkimkv","_id":"cjc0atcpu001la4e37gnjw5ku"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpl000oa4e30zmmf7qi","_id":"cjc0atcpu001ma4e3dd9v53p7"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpm000qa4e39kfhlt7y","_id":"cjc0atcpu001oa4e3t31ftv6d"},{"post_id":"cjc0atcpc000ba4e3xzo3xbzh","tag_id":"cjc0atcpm000sa4e310to69d9","_id":"cjc0atcpu001pa4e3eybog03p"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpf000ea4e3fw0ryrfd","_id":"cjc0atcpw001ta4e377gfxxkw"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpi000ia4e3kkj7lfyb","_id":"cjc0atcpw001ua4e30hj2o9tc"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpu001na4e3zo7sj6mg","_id":"cjc0atcpw001va4e3iolkinu5"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpu001qa4e3yifghi6i","_id":"cjc0atcpw001wa4e374sb2lvp"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpu001ra4e3m0hnx2qh","_id":"cjc0atcpw001xa4e3qwr8zdzy"},{"post_id":"cjc0atcpd000ca4e3verv0ts4","tag_id":"cjc0atcpv001sa4e31ebthvbq","_id":"cjc0atcpx001ya4e3v37aix4v"}],"Tag":[{"name":"ITPMP","_id":"cjc0atcp10004a4e3hl7h92om"},{"name":"git","_id":"cjc0atcpb0009a4e3up8n72xy"},{"name":"JS","_id":"cjc0atcpf000ea4e3fw0ryrfd"},{"name":"Javascript","_id":"cjc0atcpi000ia4e3kkj7lfyb"},{"name":"OOP","_id":"cjc0atcpk000la4e3y2gkimkv"},{"name":"OOJ","_id":"cjc0atcpl000oa4e30zmmf7qi"},{"name":"H5","_id":"cjc0atcpm000qa4e39kfhlt7y"},{"name":"WEB","_id":"cjc0atcpm000sa4e310to69d9"},{"name":"commonjs","_id":"cjc0atcpu001na4e3zo7sj6mg"},{"name":"AMD","_id":"cjc0atcpu001qa4e3yifghi6i"},{"name":"CMD","_id":"cjc0atcpu001ra4e3m0hnx2qh"},{"name":"ES6","_id":"cjc0atcpv001sa4e31ebthvbq"}]}}