{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-1.gif","path":"imgs/ooj-1.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-2.gif","path":"imgs/ooj-2.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-3.gif","path":"imgs/ooj-3.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/imgs/ooj-4.gif","path":"imgs/ooj-4.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1514280699000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1514280699000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1514280699000},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1514280699000},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1514280699000},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1514280699000},{"_id":"source/_drafts/hello-page.md","hash":"69e2b3b9a445faefaa62e4a45415df044ef6e0a5","modified":1514280699000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1514280699000},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1514280699000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1514280699000},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1514280699000},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1514280699000},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1514280699000},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1514280699000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1514280699000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1514280699000},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1514280699000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1514280699000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1514280699000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1514280699000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1514280699000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1514280699000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1514280699000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1514280699000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514280699000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1514280699000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1514280699000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1514280699000},{"_id":"source/_posts/csharp/hello-csharp.md","hash":"84ae7e7aabdde37e53638d7e13890edd59f1d42d","modified":1514280815000},{"_id":"source/_posts/javascript/OOJ-ONE.md","hash":"48baf5449633b2e4eeadf04e80d4e8da375f8dbf","modified":1514355537000},{"_id":"source/_posts/javascript/OOJ-TWO.md","hash":"817dcec17c7d8d516f99192b6ae1bc8566077d9e","modified":1514354828000},{"_id":"source/_posts/javascript/hello-js.md","hash":"f106f071c2315309c455a4ec2646011d48fa4cb9","modified":1514280852000},{"_id":"source/_posts/javascript/OOJ-THREE.md","hash":"71c6f76b9066a7d9346a5e0b4b35e1e7f645cb91","modified":1514354807000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"af08a6a4957ad88e8eea457b3f54812085bd4608","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"926285ade4eedacb38d27289f69966724ad4fb83","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1514280699000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1514280699000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1514280699000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"0a8de18e3749cb488f24ac50b68bb112f75032d6","modified":1514355828000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1514280699000},{"_id":"themes/landscape/source/imgs/ooj-1.gif","hash":"ca81d82ec8823f7ffefaf37d71227482221643e4","modified":1514355296000},{"_id":"themes/landscape/source/imgs/ooj-2.gif","hash":"31a3530c12a79b718664e3c233b94478af760a56","modified":1514355292000},{"_id":"themes/landscape/source/imgs/ooj-3.gif","hash":"6e94fe132149b30f9c9dc372755a69152af1e7d4","modified":1514355292000},{"_id":"themes/landscape/source/imgs/ooj-4.gif","hash":"24cfb25c0f15bd26c3bf077bb10bd47a47fc3d3a","modified":1514355292000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1514280699000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1514280699000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1514280699000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1514280699000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1514280699000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1514280699000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1514280699000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1514280699000}],"Category":[{"name":"C#","_id":"cjbood4w00003h2e3pdgtvfxv"},{"name":"Javascript","_id":"cjbood4wj0007h2e3bxyxgidp"}],"Data":[],"Page":[],"Post":[{"title":"hello-page","_content":"","source":"_drafts/hello-page.md","raw":"---\ntitle: hello-page\ntags:\n---\n","slug":"hello-page","published":0,"date":"2017-12-26T09:31:39.000Z","updated":"2017-12-26T09:31:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4v50000h2e3qwusz0nl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-12-26T09:31:39.000Z","updated":"2017-12-26T09:31:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4vb0001h2e3u9oyemj5","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Hello C#","p":"csharp/hello-csharp","date":"2006-12-26T08:49:10.000Z","_content":"","source":"_posts/csharp/hello-csharp.md","raw":"---\ntitle: Hello C#\np: csharp/hello-csharp\ndate: 2006-12-26 16:49:10\ntags:\ncategories: C#\n---\n","slug":"csharp/hello-csharp","published":1,"updated":"2017-12-26T09:33:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4vz0002h2e36jxb095s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OOJ-面向对象的JAVASCRIPT（一）","p":"javascript/OOJ-ONE","date":"2010-05-15T08:52:05.000Z","_content":"\n现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。\nWEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。\n\n## 一、面向对象的基础理论\n百度知道里讲诉的已经非常清晰, [更多详情](http://baike.baidu.com/view/125370.htm) ，这里纯理论的知识大家就自我学习。\n\n## 二、OOJ概述\njavascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。\n\n### JavaScript 对象是词典\n在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：\n\n``` JS\nvar userObject = new Object();\nuserObject.lastLoginTime = new Date();\nalert(userObject.lastLoginTime);        \n```\n的功能与下面的代码段完全相同：\n\n``` JS\nvar userObject = {}; // equivalent to new Object()\nuserObject[“lastLoginTime”] = new Date();\nalert(userObject[“lastLoginTime”]);\n```\n\n 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：\n\n``` JS\nvar userObject = { “lastLoginTime”: new Date() };\nalert(userObject.lastLoginTime);\n```\n\n这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字\n\n如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。\n\n接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。\n\n### JavaScript 函数的奇特性\n\n大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：\n\n``` JS\nfunction func(x) {\n    alert(x);\n}\nfunc(“blah”);\n```\n 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func  \n``` JS\nvar func = function(x) {\n    alert(x);\n};\nfunc(“blah2”);\n```\n 甚至也可以像下面这样，使用 Function 构造函数：   \n``` JS\nvar func = new Function(“x”, “alert(x);”);\nfunc(“blah3”);\n```\n 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。\n\n为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： \n\n``` JS\nfunction sayHi(x) {\n    alert(“Hi, “ + x + “!”);\n}\nsayHi.text = “Hello World!”;\nsayHi[“text2”] = “Hello World... again.”;\n\nalert(sayHi[“text”]); // displays “Hello World!”\nalert(sayHi.text2); // displays “Hello World... again.”\n```\n\n作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：\n \n``` JS\n// assign an anonymous function to a variable\nvar greet = function(x) {\n    alert(“Hello, “ + x);\n};\ngreet(“MSDN readers”);\n\n// passing a function as an argument to another\nfunction square(x) {\n    return x * x;\n}\nfunction operateOn(num, func) {\n    return func(num);\n}\n// displays 256\nalert(operateOn(16, square));\n\n// functions as return values\nfunction makeIncrementer() {\n    return function(x) { return x + 1; };\n}\nvar inc = makeIncrementer();\n// displays 8\nalert(inc(7));\n\n// functions stored as array elements\nvar arr = [];\narr[0] = function(x) { return x * x; };\narr[1] = arr[0](2);\narr[2] = arr[0](arr[1]);\narr[3] = arr[0](arr[2]);\n// displays 256\nalert(arr[3]);\n\n// functions as object properties\nvar obj = { “toString” : function() { return “This is an object.”; } };\n// calls obj.toString()\nalert(obj);\n\n```\n\n记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： \n\n``` JS\nvar myDog = {\n    “name” : “Spot”,\n    “bark” : function() { alert(“Woof!”); },\n    “displayFullName” : function() {\n        alert(this.name + “ The Alpha Dog”);\n    },\n    “chaseMrPostman” : function() { \n        // implementation beyond the scope of this article \n    }    \n};\nmyDog.displayFullName(); \nmyDog.bark(); // Woof!\n```        \n\nC++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。\n\n#### “this”随对象更改而更改\n\n``` JS\nfunction displayQuote() {\n    // the value of “this” will change; depends on \n    // which object it is called through\n    alert(this.memorableQuote);    \n}\n\nvar williamShakespeare = {\n    “memorableQuote”: “It is a wise father that knows his own child.”, \n    “sayIt” : displayQuote\n};\n\nvar markTwain = {\n    “memorableQuote”: “Golf is a good walk spoiled.”, \n    “sayIt” : displayQuote\n};\n\nvar oscarWilde = {\n    “memorableQuote”: “True friends stab you in the front.” \n    // we can call the function displayQuote\n    // as a method of oscarWilde without assigning it \n    // as oscarWilde’s method. \n    //”sayIt” : displayQuote\n};\n\nwilliamShakespeare.sayIt(); // true, true\nmarkTwain.sayIt(); // he didn’t know where to play golf\n\n// watch this, each function has a method call()\n// that allows the function to be called as a \n// method of the object passed to call() as an\n// argument. \n// this line below is equivalent to assigning\n// displayQuote to sayIt, and calling oscarWilde.sayIt().\ndisplayQuote.call(oscarWilde); // ouch!\n```\n\n上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。\n\n有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！\n\n``` JS\nalert(“NaN is NaN: “ + isNaN(NaN));\n\nfunction x() {\n    this.isNaN = function() { \n        return “not anymore!”;\n    };\n}\n// alert!!! trampling the Global object!!!\nx();\n\nalert(“NaN is NaN: “ + isNaN(NaN));\n```\n\n到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。\n\n     在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n\n### 构造函数而不是类\n\n前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时： \n``` JS\nDog spot = new Dog();\n```\n将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  \n\n``` JS\nfunction DogConstructor(name) {\n    this.name = name;\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new DogConstructor(“Spot”);\nspot.respondTo(“Rover”); // nope\nspot.respondTo(“Spot”); // yeah!\n```\n \n\n那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：\n``` JS\nvar spot = new DogConstructor(“Spot”);\n```\n\n“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： \n\n``` JS\n// create an empty object\nvar spot = {}; \n// call the function as a method of the empty object\nDogConstructor.call(spot, “Spot”);\n```\n\n正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  \n\n``` JS\n// Think of this as class Dog\nfunction Dog(name) {\n    // instance variable \n    this.name = name;\n    // instance method? Hmmm...\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new Dog(“Spot”);\n```\n\n在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：\n\n``` JS\nfunction respondTo() {\n    // respondTo definition\n}\n\nfunction Dog(name) {\n    this.name = name;\n    // attached this function as a method of the object\n    this.respondTo = respondTo;\n}\n```\n这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。\n\n\n## 三、Javascript核心理论原型\n\n在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：\n``` JS\nvar buddy = new Dog(“Buddy“);\n```\nbuddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。\n\n在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。\n\n![图A1 每个函数的原型都有一个 Constructor 属性](/imgs/ooj-1.gif)\n\n现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。\n\n代码段B1\n=====\n``` JS\nvar spot = new Dog(“Spot”);\n\n// Dog.prototype is the prototype of spot\nalert(Dog.prototype.isPrototypeOf(spot));\n\n// spot inherits the constructor property\n// from Dog.prototype\nalert(spot.constructor == Dog.prototype.constructor);\nalert(spot.constructor == Dog);\n\n// But constructor property doesn’t belong\n// to spot. The line below displays “false”\nalert(spot.hasOwnProperty(“constructor”));\n\n// The constructor property belongs to Dog.prototype\n// The line below displays “true”\nalert(Dog.prototype.hasOwnProperty(“constructor”));\n```\n\n![图A2-实例继承其原型](/imgs/ooj-2.gif)\n\n某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）\n在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：\n \n``` JS\nDog.prototype = new Object();\n```\n\n因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。\n每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。\n图A3 说明了此解析过程。\n\n\n![图A3 在原型链中解析 toString() 方法](/imgs/ooj-3.gif)\n\n\nJavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：\n-   继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。\n-   如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。\n-   更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。\n\n代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。\n\n代码段B2-继承原型\n--------------\n\n``` JS\nfunction GreatDane() { }\n\nvar rover = new GreatDane();\nvar spot = new GreatDane();\n\nGreatDane.prototype.getBreed = function() {\n    return “Great Dane”;\n};\n\n// Works, even though at this point\n// rover and spot are already created.\nalert(rover.getBreed());\n\n// this hides getBreed() in GreatDane.prototype\nspot.getBreed = function() {\n    return “Little Great Dane”;\n};\nalert(spot.getBreed()); \n\n// but of course, the change to getBreed \n// doesn’t propagate back to GreatDane.prototype\n// and other objects inheriting from it,\n// it only happens in the spot object\nalert(rover.getBreed());\n\n```\n\n### 静态属性和方法\n有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：\n\n``` JS\nfunction DateTime() { }\n\n    // set static method now()\n    DateTime.now = function() {\n        return new Date();\n    };\n\n    alert(DateTime.now());\n```\n\n在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。\n \n### 闭包\n不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。\nJavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。\n假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。\n\n代码段B3 -根据谓词筛选元素\n===========\n\n``` JS\nfunction filter(pred, arr) {\n    var len = arr.length;\n    var filtered = []; // shorter version of new Array();\n    // iterate through every element in the array...\n    for(var i = 0; i < len; i++) {\n        var val = arr[i];\n        // if the element satisfies the predicate let it through\n        if(pred(val)) {\n            filtered.push(val);\n        }\n    }\n    return filtered;\n}\n\nvar someRandomNumbers = [12, 32, 1, 3, 2, 2, 234, 236, 632,7, 8];\nvar numbersGreaterThan100 = filter(\n    function(x) { return (x > 100) ? true : false; }, \n    someRandomNumbers);\n\n// displays 234, 236, 632\nalert(numbersGreaterThan100);\n```\n\n但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：\n``` JS\nvar greaterThan300 = filter(\n    function(x) { return (x > 300) ? true : false; }, \n    someRandomNumbers);\n ```\n\n然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：\n\n``` JS\nfunction makeGreaterThanPredicate(lowerBound) {\n    return function(numberToCheck) {\n        return (numberToCheck > lowerBound) ? true : false;\n    };\n}\n```\n\n这样，您就可以编写以下代码：\n``` JS\nvar greaterThan10 = makeGreaterThanPredicate(10);\nvar greaterThan100 = makeGreaterThanPredicate(100);\nalert(filter(greaterThan10, someRandomNumbers));\nalert(filter(greaterThan100, someRandomNumbers));\n```\n\n通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。\n\n开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。\n\n模拟私有属性\n-----------\n现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：\n\n``` JS\nfunction Person(name, age) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n    this.getAge = function() { return age; };\n    this.setAge = function(newAge) { age = newAge; };\n}\n```\n\n参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：\n\n``` JS\nvar ray = new Person(“Ray”, 31);\nalert(ray.getName());\nalert(ray.getAge());\nray.setName(“Younger Ray”);\n// Instant rejuvenation!\nray.setAge(22);\nalert(ray.getName() + “ is now “ + ray.getAge() + \n      “ years old.”);\n```\n\n未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：\n\n``` JS\nfunction Person(name, age) {\n    var occupation;\n    this.getOccupation = function() { return occupation; };\n    this.setOccupation = function(newOcc) { occupation = \n                         newOcc; };\n  \n    // accessors for name and age    \n}\n```\n\n注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：\n\n``` JS\nPerson.prototype.somePublicMethod = function() {\n    // doesn’t work!\n    // alert(this.name);\n    // this one below works\n    alert(this.getName());\n};\n```\n\nDouglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。\n\n从类继承\n---------\n到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。\n例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：\n\n\n![图A4-类图](/imgs/ooj-4.gif)\n\n``` JS\n// class Pet\nfunction Pet(name) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n}\n\nPet.prototype.toString = function() {\n    return “This pet’s name is: “ + this.getName();\n};\n// end of class Pet\n\nvar parrotty = new Pet(“Parrotty the Parrot”);\nalert(parrotty);\n```\n\n现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。\n\n代码段B3-从PET类派生\n-------\n\n``` JS\n// class Dog : Pet \n// public Dog(string name, string breed)\nfunction Dog(name, breed) {\n    // think Dog : base(name) \n    Pet.call(this, name);\n    this.getBreed = function() { return breed; };\n    // Breed doesn’t change, obviously! It’s read only.\n    // this.setBreed = function(newBreed) { name = newName; };\n}\n\n// this makes Dog.prototype inherits\n// from Pet.prototype\nDog.prototype = new Pet();\n\n// remember that Pet.prototype.constructor\n// points to Pet. We want our Dog instances’\n// constructor to point to Dog.\nDog.prototype.constructor = Dog;\n\n// Now we override Pet.prototype.toString\nDog.prototype.toString = function() {\n    return “This dog’s name is: “ + this.getName() + \n        “, and its breed is: “ + this.getBreed();\n};\n// end of class Dog\n\nvar dog = new Dog(“Buddy”, “Great Dane”);\n// test the new toString()\nalert(dog);\n\n// Testing instanceof (similar to the is operator)\n// (dog is Dog)? yes\nalert(dog instanceof Dog);\n// (dog is Pet)? yes\nalert(dog instanceof Pet);\n// (dog is Object)? yes\nalert(dog instanceof Object);\n```\n\n所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。\n\n\n模拟命名空间\n-------------\n\n在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：\n\n``` JS\nvar MSDNMagNS = {};\n\nMSDNMagNS.Pet = function(name) { // code here };\nMSDNMagNS.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Pet(“Yammer”);\n```\n\n命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：\n\n``` JS\nvar MSDNMagNS = {};\n// nested namespace “Examples”\nMSDNMagNS.Examples = {}; \n\nMSDNMagNS.Examples.Pet = function(name) { // code };\nMSDNMagNS.Examples.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Examples.Pet(“Yammer”);\n```\n\n可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：\n\n``` JS\n// MSDNMagNS.Examples and Pet definition...\n\n// think “using Eg = MSDNMagNS.Examples;” \nvar Eg = MSDNMagNS.Examples;\nvar pet = new Eg.Pet(“Yammer”);\nalert(pet);\n```\n\n\n如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。\n\n应当这样编写 JavaScript 代码吗？\n----------------------------\n您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。\n在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：\n\n``` JS\nfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n```\n\n然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。\n\n这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。\n\n...更多内容请看下篇文章\n\n## 四、作者总结\n\n　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。\n\n　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。\n\n　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。\n\n　　本文作者：朱峰（Peter Zhu）\n\n　　发表时间：2010-05-31\n\n## 五、本文参考引用文章列表\n\n1. 使用面向对象的技术创建高级Web 应用程序 http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\n\n2. 百度知道 http://baike.baidu.com/view/125370.htm \n\n3. OOJ-面向对象的JAVASCRIPT - [PeterZhu](http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html)\n\n","source":"_posts/javascript/OOJ-ONE.md","raw":"---\ntitle: OOJ-面向对象的JAVASCRIPT（一）\np: javascript/OOJ-ONE\ndate: 2010-05-15 16:52:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。\nWEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。\n\n## 一、面向对象的基础理论\n百度知道里讲诉的已经非常清晰, [更多详情](http://baike.baidu.com/view/125370.htm) ，这里纯理论的知识大家就自我学习。\n\n## 二、OOJ概述\njavascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。\n\n### JavaScript 对象是词典\n在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：\n\n``` JS\nvar userObject = new Object();\nuserObject.lastLoginTime = new Date();\nalert(userObject.lastLoginTime);        \n```\n的功能与下面的代码段完全相同：\n\n``` JS\nvar userObject = {}; // equivalent to new Object()\nuserObject[“lastLoginTime”] = new Date();\nalert(userObject[“lastLoginTime”]);\n```\n\n 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：\n\n``` JS\nvar userObject = { “lastLoginTime”: new Date() };\nalert(userObject.lastLoginTime);\n```\n\n这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字\n\n如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。\n\n接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。\n\n### JavaScript 函数的奇特性\n\n大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：\n\n``` JS\nfunction func(x) {\n    alert(x);\n}\nfunc(“blah”);\n```\n 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func  \n``` JS\nvar func = function(x) {\n    alert(x);\n};\nfunc(“blah2”);\n```\n 甚至也可以像下面这样，使用 Function 构造函数：   \n``` JS\nvar func = new Function(“x”, “alert(x);”);\nfunc(“blah3”);\n```\n 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。\n\n为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： \n\n``` JS\nfunction sayHi(x) {\n    alert(“Hi, “ + x + “!”);\n}\nsayHi.text = “Hello World!”;\nsayHi[“text2”] = “Hello World... again.”;\n\nalert(sayHi[“text”]); // displays “Hello World!”\nalert(sayHi.text2); // displays “Hello World... again.”\n```\n\n作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：\n \n``` JS\n// assign an anonymous function to a variable\nvar greet = function(x) {\n    alert(“Hello, “ + x);\n};\ngreet(“MSDN readers”);\n\n// passing a function as an argument to another\nfunction square(x) {\n    return x * x;\n}\nfunction operateOn(num, func) {\n    return func(num);\n}\n// displays 256\nalert(operateOn(16, square));\n\n// functions as return values\nfunction makeIncrementer() {\n    return function(x) { return x + 1; };\n}\nvar inc = makeIncrementer();\n// displays 8\nalert(inc(7));\n\n// functions stored as array elements\nvar arr = [];\narr[0] = function(x) { return x * x; };\narr[1] = arr[0](2);\narr[2] = arr[0](arr[1]);\narr[3] = arr[0](arr[2]);\n// displays 256\nalert(arr[3]);\n\n// functions as object properties\nvar obj = { “toString” : function() { return “This is an object.”; } };\n// calls obj.toString()\nalert(obj);\n\n```\n\n记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： \n\n``` JS\nvar myDog = {\n    “name” : “Spot”,\n    “bark” : function() { alert(“Woof!”); },\n    “displayFullName” : function() {\n        alert(this.name + “ The Alpha Dog”);\n    },\n    “chaseMrPostman” : function() { \n        // implementation beyond the scope of this article \n    }    \n};\nmyDog.displayFullName(); \nmyDog.bark(); // Woof!\n```        \n\nC++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。\n\n#### “this”随对象更改而更改\n\n``` JS\nfunction displayQuote() {\n    // the value of “this” will change; depends on \n    // which object it is called through\n    alert(this.memorableQuote);    \n}\n\nvar williamShakespeare = {\n    “memorableQuote”: “It is a wise father that knows his own child.”, \n    “sayIt” : displayQuote\n};\n\nvar markTwain = {\n    “memorableQuote”: “Golf is a good walk spoiled.”, \n    “sayIt” : displayQuote\n};\n\nvar oscarWilde = {\n    “memorableQuote”: “True friends stab you in the front.” \n    // we can call the function displayQuote\n    // as a method of oscarWilde without assigning it \n    // as oscarWilde’s method. \n    //”sayIt” : displayQuote\n};\n\nwilliamShakespeare.sayIt(); // true, true\nmarkTwain.sayIt(); // he didn’t know where to play golf\n\n// watch this, each function has a method call()\n// that allows the function to be called as a \n// method of the object passed to call() as an\n// argument. \n// this line below is equivalent to assigning\n// displayQuote to sayIt, and calling oscarWilde.sayIt().\ndisplayQuote.call(oscarWilde); // ouch!\n```\n\n上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。\n\n有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！\n\n``` JS\nalert(“NaN is NaN: “ + isNaN(NaN));\n\nfunction x() {\n    this.isNaN = function() { \n        return “not anymore!”;\n    };\n}\n// alert!!! trampling the Global object!!!\nx();\n\nalert(“NaN is NaN: “ + isNaN(NaN));\n```\n\n到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。\n\n     在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n\n### 构造函数而不是类\n\n前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时： \n``` JS\nDog spot = new Dog();\n```\n将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  \n\n``` JS\nfunction DogConstructor(name) {\n    this.name = name;\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new DogConstructor(“Spot”);\nspot.respondTo(“Rover”); // nope\nspot.respondTo(“Spot”); // yeah!\n```\n \n\n那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：\n``` JS\nvar spot = new DogConstructor(“Spot”);\n```\n\n“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： \n\n``` JS\n// create an empty object\nvar spot = {}; \n// call the function as a method of the empty object\nDogConstructor.call(spot, “Spot”);\n```\n\n正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  \n\n``` JS\n// Think of this as class Dog\nfunction Dog(name) {\n    // instance variable \n    this.name = name;\n    // instance method? Hmmm...\n    this.respondTo = function(name) {\n        if(this.name == name) {\n            alert(“Woof”);        \n        }\n    };\n}\n\nvar spot = new Dog(“Spot”);\n```\n\n在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：\n\n``` JS\nfunction respondTo() {\n    // respondTo definition\n}\n\nfunction Dog(name) {\n    this.name = name;\n    // attached this function as a method of the object\n    this.respondTo = respondTo;\n}\n```\n这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。\n\n\n## 三、Javascript核心理论原型\n\n在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：\n``` JS\nvar buddy = new Dog(“Buddy“);\n```\nbuddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。\n\n在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。\n\n![图A1 每个函数的原型都有一个 Constructor 属性](/imgs/ooj-1.gif)\n\n现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。\n\n代码段B1\n=====\n``` JS\nvar spot = new Dog(“Spot”);\n\n// Dog.prototype is the prototype of spot\nalert(Dog.prototype.isPrototypeOf(spot));\n\n// spot inherits the constructor property\n// from Dog.prototype\nalert(spot.constructor == Dog.prototype.constructor);\nalert(spot.constructor == Dog);\n\n// But constructor property doesn’t belong\n// to spot. The line below displays “false”\nalert(spot.hasOwnProperty(“constructor”));\n\n// The constructor property belongs to Dog.prototype\n// The line below displays “true”\nalert(Dog.prototype.hasOwnProperty(“constructor”));\n```\n\n![图A2-实例继承其原型](/imgs/ooj-2.gif)\n\n某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）\n在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：\n \n``` JS\nDog.prototype = new Object();\n```\n\n因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。\n每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。\n图A3 说明了此解析过程。\n\n\n![图A3 在原型链中解析 toString() 方法](/imgs/ooj-3.gif)\n\n\nJavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：\n-   继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。\n-   如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。\n-   更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。\n\n代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。\n\n代码段B2-继承原型\n--------------\n\n``` JS\nfunction GreatDane() { }\n\nvar rover = new GreatDane();\nvar spot = new GreatDane();\n\nGreatDane.prototype.getBreed = function() {\n    return “Great Dane”;\n};\n\n// Works, even though at this point\n// rover and spot are already created.\nalert(rover.getBreed());\n\n// this hides getBreed() in GreatDane.prototype\nspot.getBreed = function() {\n    return “Little Great Dane”;\n};\nalert(spot.getBreed()); \n\n// but of course, the change to getBreed \n// doesn’t propagate back to GreatDane.prototype\n// and other objects inheriting from it,\n// it only happens in the spot object\nalert(rover.getBreed());\n\n```\n\n### 静态属性和方法\n有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：\n\n``` JS\nfunction DateTime() { }\n\n    // set static method now()\n    DateTime.now = function() {\n        return new Date();\n    };\n\n    alert(DateTime.now());\n```\n\n在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。\n \n### 闭包\n不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。\nJavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。\n假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。\n\n代码段B3 -根据谓词筛选元素\n===========\n\n``` JS\nfunction filter(pred, arr) {\n    var len = arr.length;\n    var filtered = []; // shorter version of new Array();\n    // iterate through every element in the array...\n    for(var i = 0; i < len; i++) {\n        var val = arr[i];\n        // if the element satisfies the predicate let it through\n        if(pred(val)) {\n            filtered.push(val);\n        }\n    }\n    return filtered;\n}\n\nvar someRandomNumbers = [12, 32, 1, 3, 2, 2, 234, 236, 632,7, 8];\nvar numbersGreaterThan100 = filter(\n    function(x) { return (x > 100) ? true : false; }, \n    someRandomNumbers);\n\n// displays 234, 236, 632\nalert(numbersGreaterThan100);\n```\n\n但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：\n``` JS\nvar greaterThan300 = filter(\n    function(x) { return (x > 300) ? true : false; }, \n    someRandomNumbers);\n ```\n\n然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：\n\n``` JS\nfunction makeGreaterThanPredicate(lowerBound) {\n    return function(numberToCheck) {\n        return (numberToCheck > lowerBound) ? true : false;\n    };\n}\n```\n\n这样，您就可以编写以下代码：\n``` JS\nvar greaterThan10 = makeGreaterThanPredicate(10);\nvar greaterThan100 = makeGreaterThanPredicate(100);\nalert(filter(greaterThan10, someRandomNumbers));\nalert(filter(greaterThan100, someRandomNumbers));\n```\n\n通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。\n\n开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。\n\n模拟私有属性\n-----------\n现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：\n\n``` JS\nfunction Person(name, age) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n    this.getAge = function() { return age; };\n    this.setAge = function(newAge) { age = newAge; };\n}\n```\n\n参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：\n\n``` JS\nvar ray = new Person(“Ray”, 31);\nalert(ray.getName());\nalert(ray.getAge());\nray.setName(“Younger Ray”);\n// Instant rejuvenation!\nray.setAge(22);\nalert(ray.getName() + “ is now “ + ray.getAge() + \n      “ years old.”);\n```\n\n未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：\n\n``` JS\nfunction Person(name, age) {\n    var occupation;\n    this.getOccupation = function() { return occupation; };\n    this.setOccupation = function(newOcc) { occupation = \n                         newOcc; };\n  \n    // accessors for name and age    \n}\n```\n\n注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：\n\n``` JS\nPerson.prototype.somePublicMethod = function() {\n    // doesn’t work!\n    // alert(this.name);\n    // this one below works\n    alert(this.getName());\n};\n```\n\nDouglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。\n\n从类继承\n---------\n到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。\n例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：\n\n\n![图A4-类图](/imgs/ooj-4.gif)\n\n``` JS\n// class Pet\nfunction Pet(name) {\n    this.getName = function() { return name; };\n    this.setName = function(newName) { name = newName; };\n}\n\nPet.prototype.toString = function() {\n    return “This pet’s name is: “ + this.getName();\n};\n// end of class Pet\n\nvar parrotty = new Pet(“Parrotty the Parrot”);\nalert(parrotty);\n```\n\n现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。\n\n代码段B3-从PET类派生\n-------\n\n``` JS\n// class Dog : Pet \n// public Dog(string name, string breed)\nfunction Dog(name, breed) {\n    // think Dog : base(name) \n    Pet.call(this, name);\n    this.getBreed = function() { return breed; };\n    // Breed doesn’t change, obviously! It’s read only.\n    // this.setBreed = function(newBreed) { name = newName; };\n}\n\n// this makes Dog.prototype inherits\n// from Pet.prototype\nDog.prototype = new Pet();\n\n// remember that Pet.prototype.constructor\n// points to Pet. We want our Dog instances’\n// constructor to point to Dog.\nDog.prototype.constructor = Dog;\n\n// Now we override Pet.prototype.toString\nDog.prototype.toString = function() {\n    return “This dog’s name is: “ + this.getName() + \n        “, and its breed is: “ + this.getBreed();\n};\n// end of class Dog\n\nvar dog = new Dog(“Buddy”, “Great Dane”);\n// test the new toString()\nalert(dog);\n\n// Testing instanceof (similar to the is operator)\n// (dog is Dog)? yes\nalert(dog instanceof Dog);\n// (dog is Pet)? yes\nalert(dog instanceof Pet);\n// (dog is Object)? yes\nalert(dog instanceof Object);\n```\n\n所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。\n\n\n模拟命名空间\n-------------\n\n在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：\n\n``` JS\nvar MSDNMagNS = {};\n\nMSDNMagNS.Pet = function(name) { // code here };\nMSDNMagNS.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Pet(“Yammer”);\n```\n\n命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：\n\n``` JS\nvar MSDNMagNS = {};\n// nested namespace “Examples”\nMSDNMagNS.Examples = {}; \n\nMSDNMagNS.Examples.Pet = function(name) { // code };\nMSDNMagNS.Examples.Pet.prototype.toString = function() { // code };\n\nvar pet = new MSDNMagNS.Examples.Pet(“Yammer”);\n```\n\n可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：\n\n``` JS\n// MSDNMagNS.Examples and Pet definition...\n\n// think “using Eg = MSDNMagNS.Examples;” \nvar Eg = MSDNMagNS.Examples;\nvar pet = new Eg.Pet(“Yammer”);\nalert(pet);\n```\n\n\n如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。\n\n应当这样编写 JavaScript 代码吗？\n----------------------------\n您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。\n在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：\n\n``` JS\nfunction object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n```\n\n然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。\n\n这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。\n\n...更多内容请看下篇文章\n\n## 四、作者总结\n\n　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。\n\n　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。\n\n　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。\n\n　　本文作者：朱峰（Peter Zhu）\n\n　　发表时间：2010-05-31\n\n## 五、本文参考引用文章列表\n\n1. 使用面向对象的技术创建高级Web 应用程序 http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\n\n2. 百度知道 http://baike.baidu.com/view/125370.htm \n\n3. OOJ-面向对象的JAVASCRIPT - [PeterZhu](http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html)\n\n","slug":"javascript/OOJ-ONE","published":1,"updated":"2017-12-27T06:18:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4wa0005h2e3qsj96zja","content":"<p>现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。<br>WEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。</p>\n<h2 id=\"一、面向对象的基础理论\"><a href=\"#一、面向对象的基础理论\" class=\"headerlink\" title=\"一、面向对象的基础理论\"></a>一、面向对象的基础理论</h2><p>百度知道里讲诉的已经非常清晰, <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">更多详情</a> ，这里纯理论的知识大家就自我学习。</p>\n<h2 id=\"二、OOJ概述\"><a href=\"#二、OOJ概述\" class=\"headerlink\" title=\"二、OOJ概述\"></a>二、OOJ概述</h2><p>javascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。</p>\n<h3 id=\"JavaScript-对象是词典\"><a href=\"#JavaScript-对象是词典\" class=\"headerlink\" title=\"JavaScript 对象是词典\"></a>JavaScript 对象是词典</h3><p>在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">userObject.lastLoginTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>的功能与下面的代码段完全相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123;&#125;; <span class=\"comment\">// equivalent to new Object()</span></span><br><span class=\"line\">userObject[“lastLoginTime”] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject[“lastLoginTime”]);</span><br></pre></td></tr></table></figure>\n<p> 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123; “lastLoginTime”: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() &#125;;</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字</p>\n<p>如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。</p>\n<p>接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。</p>\n<h3 id=\"JavaScript-函数的奇特性\"><a href=\"#JavaScript-函数的奇特性\" class=\"headerlink\" title=\"JavaScript 函数的奇特性\"></a>JavaScript 函数的奇特性</h3><p>大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(“blah”);</span><br></pre></td></tr></table></figure>\n<p> 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(“blah2”);</span><br></pre></td></tr></table></figure></p>\n<p> 甚至也可以像下面这样，使用 Function 构造函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(“x”, “alert(x);”);</span><br><span class=\"line\">func(“blah3”);</span><br></pre></td></tr></table></figure></p>\n<p> 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。</p>\n<p>为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hi, “ + x + “!”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.text = “Hello World!”;</span><br><span class=\"line\">sayHi[“text2”] = “Hello World... again.”;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sayHi[“text”]); <span class=\"comment\">// displays “Hello World!”</span></span><br><span class=\"line\">alert(sayHi.text2); <span class=\"comment\">// displays “Hello World... again.”</span></span><br></pre></td></tr></table></figure>\n<p>作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assign an anonymous function to a variable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hello, “ + x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">greet(“MSDN readers”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// passing a function as an argument to another</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operateOn</span>(<span class=\"params\">num, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(operateOn(<span class=\"number\">16</span>, square));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as return values</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIncrementer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = makeIncrementer();</span><br><span class=\"line\"><span class=\"comment\">// displays 8</span></span><br><span class=\"line\">alert(inc(<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions stored as array elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = arr[<span class=\"number\">0</span>](<span class=\"number\">2</span>);</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">arr[<span class=\"number\">3</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">2</span>]);</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as object properties</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; “toString” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> “This is an object.”; &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// calls obj.toString()</span></span><br><span class=\"line\">alert(obj);</span><br></pre></td></tr></table></figure>\n<p>记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDog = &#123;</span><br><span class=\"line\">    “name” : “Spot”,</span><br><span class=\"line\">    “bark” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; alert(“Woof!”); &#125;,</span><br><span class=\"line\">    “displayFullName” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name + “ The Alpha Dog”);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    “chaseMrPostman” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// implementation beyond the scope of this article </span></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myDog.displayFullName(); </span><br><span class=\"line\">myDog.bark(); <span class=\"comment\">// Woof!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`        </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">C++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### “this”随对象更改而更改</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayQuote</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the value of “this” will change; depends on </span></span><br><span class=\"line\">    <span class=\"comment\">// which object it is called through</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.memorableQuote);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> williamShakespeare = &#123;</span><br><span class=\"line\">    “memorableQuote”: “It is a wise father that knows his own child.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> markTwain = &#123;</span><br><span class=\"line\">    “memorableQuote”: “Golf is a good walk spoiled.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oscarWilde = &#123;</span><br><span class=\"line\">    “memorableQuote”: “True friends stab you <span class=\"keyword\">in</span> the front.” </span><br><span class=\"line\">    <span class=\"comment\">// we can call the function displayQuote</span></span><br><span class=\"line\">    <span class=\"comment\">// as a method of oscarWilde without assigning it </span></span><br><span class=\"line\">    <span class=\"comment\">// as oscarWilde’s method. </span></span><br><span class=\"line\">    <span class=\"comment\">//”sayIt” : displayQuote</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">williamShakespeare.sayIt(); <span class=\"comment\">// true, true</span></span><br><span class=\"line\">markTwain.sayIt(); <span class=\"comment\">// he didn’t know where to play golf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// watch this, each function has a method call()</span></span><br><span class=\"line\"><span class=\"comment\">// that allows the function to be called as a </span></span><br><span class=\"line\"><span class=\"comment\">// method of the object passed to call() as an</span></span><br><span class=\"line\"><span class=\"comment\">// argument. </span></span><br><span class=\"line\"><span class=\"comment\">// this line below is equivalent to assigning</span></span><br><span class=\"line\"><span class=\"comment\">// displayQuote to sayIt, and calling oscarWilde.sayIt().</span></span><br><span class=\"line\">displayQuote.call(oscarWilde); <span class=\"comment\">// ouch!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。</p>\n<p>有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> “not anymore!”;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alert!!! trampling the Global object!!!</span></span><br><span class=\"line\">x();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。</p>\n<pre><code>在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n</code></pre><h3 id=\"构造函数而不是类\"><a href=\"#构造函数而不是类\" class=\"headerlink\" title=\"构造函数而不是类\"></a>构造函数而不是类</h3><p>前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog spot = <span class=\"keyword\">new</span> Dog();</span><br></pre></td></tr></table></figure></p>\n<p>将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DogConstructor</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br><span class=\"line\">spot.respondTo(“Rover”); <span class=\"comment\">// nope</span></span><br><span class=\"line\">spot.respondTo(“Spot”); <span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<p>那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br></pre></td></tr></table></figure></p>\n<p>“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an empty object</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = &#123;&#125;; </span><br><span class=\"line\"><span class=\"comment\">// call the function as a method of the empty object</span></span><br><span class=\"line\">DogConstructor.call(spot, “Spot”);</span><br></pre></td></tr></table></figure>\n<p>正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Think of this as class Dog</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// instance variable </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// instance method? Hmmm...</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br></pre></td></tr></table></figure>\n<p>在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respondTo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// respondTo definition</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// attached this function as a method of the object</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = respondTo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。</p>\n<h2 id=\"三、Javascript核心理论原型\"><a href=\"#三、Javascript核心理论原型\" class=\"headerlink\" title=\"三、Javascript核心理论原型\"></a>三、Javascript核心理论原型</h2><p>在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buddy = <span class=\"keyword\">new</span> Dog(“Buddy“);</span><br></pre></td></tr></table></figure></p>\n<p>buddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。</p>\n<p>在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。</p>\n<p><img src=\"/imgs/ooj-1.gif\" alt=\"图A1 每个函数的原型都有一个 Constructor 属性\"></p>\n<p>现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。</p>\n<h1 id=\"代码段B1\"><a href=\"#代码段B1\" class=\"headerlink\" title=\"代码段B1\"></a>代码段B1</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog.prototype is the prototype of spot</span></span><br><span class=\"line\">alert(Dog.prototype.isPrototypeOf(spot));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// spot inherits the constructor property</span></span><br><span class=\"line\"><span class=\"comment\">// from Dog.prototype</span></span><br><span class=\"line\">alert(spot.constructor == Dog.prototype.constructor);</span><br><span class=\"line\">alert(spot.constructor == Dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But constructor property doesn’t belong</span></span><br><span class=\"line\"><span class=\"comment\">// to spot. The line below displays “false”</span></span><br><span class=\"line\">alert(spot.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br><span class=\"line\"></span><br><span class=\"line\">// The <span class=\"keyword\">constructor</span> property belongs to Dog.prototype</span><br><span class=\"line\">// The line below displays “true”</span><br><span class=\"line\">alert(Dog.prototype.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br></pre></td></tr></table></figure>\n<p><img src=\"/imgs/ooj-2.gif\" alt=\"图A2-实例继承其原型\"></p>\n<p>某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）<br>在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。<br>每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。<br>图A3 说明了此解析过程。</p>\n<p><img src=\"/imgs/ooj-3.gif\" alt=\"图A3 在原型链中解析 toString() 方法\"></p>\n<p>JavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：</p>\n<ul>\n<li>继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。</li>\n<li>如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。</li>\n<li>更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。</li>\n</ul>\n<p>代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。</p>\n<h2 id=\"代码段B2-继承原型\"><a href=\"#代码段B2-继承原型\" class=\"headerlink\" title=\"代码段B2-继承原型\"></a>代码段B2-继承原型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GreatDane</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rover = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"></span><br><span class=\"line\">GreatDane.prototype.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Works, even though at this point</span></span><br><span class=\"line\"><span class=\"comment\">// rover and spot are already created.</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this hides getBreed() in GreatDane.prototype</span></span><br><span class=\"line\">spot.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Little Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(spot.getBreed()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// but of course, the change to getBreed </span></span><br><span class=\"line\"><span class=\"comment\">// doesn’t propagate back to GreatDane.prototype</span></span><br><span class=\"line\"><span class=\"comment\">// and other objects inheriting from it,</span></span><br><span class=\"line\"><span class=\"comment\">// it only happens in the spot object</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态属性和方法\"><a href=\"#静态属性和方法\" class=\"headerlink\" title=\"静态属性和方法\"></a>静态属性和方法</h3><p>有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DateTime</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set static method now()</span></span><br><span class=\"line\">    DateTime.now = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert(DateTime.now());</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。<br>JavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。<br>假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。</p>\n<h1 id=\"代码段B3-根据谓词筛选元素\"><a href=\"#代码段B3-根据谓词筛选元素\" class=\"headerlink\" title=\"代码段B3 -根据谓词筛选元素\"></a>代码段B3 -根据谓词筛选元素</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">pred, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> filtered = []; <span class=\"comment\">// shorter version of new Array();</span></span><br><span class=\"line\">    <span class=\"comment\">// iterate through every element in the array...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = arr[i];</span><br><span class=\"line\">        <span class=\"comment\">// if the element satisfies the predicate let it through</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pred(val)) &#123;</span><br><span class=\"line\">            filtered.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filtered;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someRandomNumbers = [<span class=\"number\">12</span>, <span class=\"number\">32</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">234</span>, <span class=\"number\">236</span>, <span class=\"number\">632</span>,<span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbersGreaterThan100 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">100</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// displays 234, 236, 632</span></span><br><span class=\"line\">alert(numbersGreaterThan100);</span><br></pre></td></tr></table></figure>\n<p>但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan300 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">300</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br></pre></td></tr></table></figure></p>\n<p>然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeGreaterThanPredicate</span>(<span class=\"params\">lowerBound</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numberToCheck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (numberToCheck &gt; lowerBound) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，您就可以编写以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan10 = makeGreaterThanPredicate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> greaterThan100 = makeGreaterThanPredicate(<span class=\"number\">100</span>);</span><br><span class=\"line\">alert(filter(greaterThan10, someRandomNumbers));</span><br><span class=\"line\">alert(filter(greaterThan100, someRandomNumbers));</span><br></pre></td></tr></table></figure></p>\n<p>通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。</p>\n<p>开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。</p>\n<h2 id=\"模拟私有属性\"><a href=\"#模拟私有属性\" class=\"headerlink\" title=\"模拟私有属性\"></a>模拟私有属性</h2><p>现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> age; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newAge</span>) </span>&#123; age = newAge; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ray = <span class=\"keyword\">new</span> Person(“Ray”, <span class=\"number\">31</span>);</span><br><span class=\"line\">alert(ray.getName());</span><br><span class=\"line\">alert(ray.getAge());</span><br><span class=\"line\">ray.setName(“Younger Ray”);</span><br><span class=\"line\"><span class=\"comment\">// Instant rejuvenation!</span></span><br><span class=\"line\">ray.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">alert(ray.getName() + “ is now “ + ray.getAge() + </span><br><span class=\"line\">      “ years old.”);</span><br></pre></td></tr></table></figure>\n<p>未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> occupation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> occupation; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newOcc</span>) </span>&#123; occupation = </span><br><span class=\"line\">                         newOcc; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// accessors for name and age    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.somePublicMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// doesn’t work!</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(this.name);</span></span><br><span class=\"line\">    <span class=\"comment\">// this one below works</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.getName());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Douglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。</p>\n<h2 id=\"从类继承\"><a href=\"#从类继承\" class=\"headerlink\" title=\"从类继承\"></a>从类继承</h2><p>到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。<br>例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：</p>\n<p><img src=\"/imgs/ooj-4.gif\" alt=\"图A4-类图\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Pet</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pet</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This pet’s name is: “ + <span class=\"keyword\">this</span>.getName();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Pet</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parrotty = <span class=\"keyword\">new</span> Pet(“Parrotty the Parrot”);</span><br><span class=\"line\">alert(parrotty);</span><br></pre></td></tr></table></figure>\n<p>现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。</p>\n<h2 id=\"代码段B3-从PET类派生\"><a href=\"#代码段B3-从PET类派生\" class=\"headerlink\" title=\"代码段B3-从PET类派生\"></a>代码段B3-从PET类派生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Dog : Pet </span></span><br><span class=\"line\"><span class=\"comment\">// public Dog(string name, string breed)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, breed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// think Dog : base(name) </span></span><br><span class=\"line\">    Pet.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> breed; &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Breed doesn’t change, obviously! It’s read only.</span></span><br><span class=\"line\">    <span class=\"comment\">// this.setBreed = function(newBreed) &#123; name = newName; &#125;;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this makes Dog.prototype inherits</span></span><br><span class=\"line\"><span class=\"comment\">// from Pet.prototype</span></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Pet();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remember that Pet.prototype.constructor</span></span><br><span class=\"line\"><span class=\"comment\">// points to Pet. We want our Dog instances’</span></span><br><span class=\"line\"><span class=\"comment\">// constructor to point to Dog.</span></span><br><span class=\"line\">Dog.prototype.constructor = Dog;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Now we override Pet.prototype.toString</span></span><br><span class=\"line\">Dog.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This dog’s name is: “ + <span class=\"keyword\">this</span>.getName() + </span><br><span class=\"line\">        “, and its breed is: “ + <span class=\"keyword\">this</span>.getBreed();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Dog</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(“Buddy”, “Great Dane”);</span><br><span class=\"line\"><span class=\"comment\">// test the new toString()</span></span><br><span class=\"line\">alert(dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Testing instanceof (similar to the is operator)</span></span><br><span class=\"line\"><span class=\"comment\">// (dog is Dog)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Dog);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Pet)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Pet);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Object)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<p>所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。</p>\n<h2 id=\"模拟命名空间\"><a href=\"#模拟命名空间\" class=\"headerlink\" title=\"模拟命名空间\"></a>模拟命名空间</h2><p>在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code here &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// nested namespace “Examples”</span></span><br><span class=\"line\">MSDNMagNS.Examples = &#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Examples.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Examples.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Examples.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MSDNMagNS.Examples and Pet definition...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// think “using Eg = MSDNMagNS.Examples;” </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Eg = MSDNMagNS.Examples;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> Eg.Pet(“Yammer”);</span><br><span class=\"line\">alert(pet);</span><br></pre></td></tr></table></figure>\n<p>如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。</p>\n<h2 id=\"应当这样编写-JavaScript-代码吗？\"><a href=\"#应当这样编写-JavaScript-代码吗？\" class=\"headerlink\" title=\"应当这样编写 JavaScript 代码吗？\"></a>应当这样编写 JavaScript 代码吗？</h2><p>您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。<br>在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。</p>\n<p>这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。</p>\n<p>…更多内容请看下篇文章</p>\n<h2 id=\"四、作者总结\"><a href=\"#四、作者总结\" class=\"headerlink\" title=\"四、作者总结\"></a>四、作者总结</h2><p>　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。</p>\n<p>　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。</p>\n<p>　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。</p>\n<p>　　本文作者：朱峰（Peter Zhu）</p>\n<p>　　发表时间：2010-05-31</p>\n<h2 id=\"五、本文参考引用文章列表\"><a href=\"#五、本文参考引用文章列表\" class=\"headerlink\" title=\"五、本文参考引用文章列表\"></a>五、本文参考引用文章列表</h2><ol>\n<li><p>使用面向对象的技术创建高级Web 应用程序 <a href=\"http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx</a></p>\n</li>\n<li><p>百度知道 <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/125370.htm</a> </p>\n</li>\n<li><p>OOJ-面向对象的JAVASCRIPT - <a href=\"http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html\" target=\"_blank\" rel=\"noopener\">PeterZhu</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>现代编程都有一个共性，无任是新语言，还是发展健全的语言，都有一套面向对象编程的理论。<br>WEB前端开发的JAVASCRIPT也不例外。最近着迷发展的JAVASCRIPT，也想把自己的想法和前人的经验总结下，让更多的IT农民工学习研究。</p>\n<h2 id=\"一、面向对象的基础理论\"><a href=\"#一、面向对象的基础理论\" class=\"headerlink\" title=\"一、面向对象的基础理论\"></a>一、面向对象的基础理论</h2><p>百度知道里讲诉的已经非常清晰, <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">更多详情</a> ，这里纯理论的知识大家就自我学习。</p>\n<h2 id=\"二、OOJ概述\"><a href=\"#二、OOJ概述\" class=\"headerlink\" title=\"二、OOJ概述\"></a>二、OOJ概述</h2><p>javascript面向对象编程与一般的C++,C#等开发语言结构还不一致。它即面向对象，又类似于一般的结构性语言。</p>\n<h3 id=\"JavaScript-对象是词典\"><a href=\"#JavaScript-对象是词典\" class=\"headerlink\" title=\"JavaScript 对象是词典\"></a>JavaScript 对象是词典</h3><p>在 C++ 或 C# 中，在谈论对象时，是指类或结构的实例。对象有不同的属性和方法，具体取决于将它们实例化的模板（即类）。而 JavaScript 对象却不是这样。在 JavaScript 中，对象只是一组名称/值对，就是说，将 JavaScript 对象视为包含字符串关键字的词典。我们可以使用熟悉的“.”（点）运算符或“[]”运算符，来获得和设置对象的属性，这是在处理词典时通常采用的方法。以下代码段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">userObject.lastLoginTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>的功能与下面的代码段完全相同：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123;&#125;; <span class=\"comment\">// equivalent to new Object()</span></span><br><span class=\"line\">userObject[“lastLoginTime”] = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">alert(userObject[“lastLoginTime”]);</span><br></pre></td></tr></table></figure>\n<p> 我们还可以直接在 userObject 的定义中定义 lastLoginTime 属性，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userObject = &#123; “lastLoginTime”: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() &#125;;</span><br><span class=\"line\">alert(userObject.lastLoginTime);</span><br></pre></td></tr></table></figure>\n<p>这里大家需要注意的是： JavaScript 对象/词典只接受字符串关键字</p>\n<p>如果记住 JavaScript 对象是词典，您就不会对此感到吃惊了，毕竟，我们一直在向词典添加新关键字（和其各自的值）。</p>\n<p>接下来，我们了解下JAVASCRIPT的对象方法，若要理解对象方法，首先需要仔细了解一下 JavaScript 函数。</p>\n<h3 id=\"JavaScript-函数的奇特性\"><a href=\"#JavaScript-函数的奇特性\" class=\"headerlink\" title=\"JavaScript 函数的奇特性\"></a>JavaScript 函数的奇特性</h3><p>大家了解的很多编程语言中，函数和对象通常被视为两样不同的东西。在 JavaScript 中，其差别很模糊 — JavaScript 函数实际上是具有与它关联的可执行代码的对象。请如此看待普通函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(“blah”);</span><br></pre></td></tr></table></figure>\n<p> 这就是通常在 JavaScript 中定义函数的方法。但是，还可以按以下方法定义该函数，您在此创建匿名函数对象，并将它赋给变量 func<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">func(“blah2”);</span><br></pre></td></tr></table></figure></p>\n<p> 甚至也可以像下面这样，使用 Function 构造函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(“x”, “alert(x);”);</span><br><span class=\"line\">func(“blah3”);</span><br></pre></td></tr></table></figure></p>\n<p> 此示例表明函数实际上只是支持函数调用操作的对象。最后一个使用 Function 构造函数来定义函数的方法并不常用，但它展示的可能性非常有趣，因为您可能注意到，该函数的主体正是 Function 构造函数的 String 参数。这意味着，您可以在运行时构造任意函数。</p>\n<p>为了进一步演示函数是对象，您可以像对其他任何 JavaScript 对象一样，在函数中设置或添加属性： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHi</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hi, “ + x + “!”);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHi.text = “Hello World!”;</span><br><span class=\"line\">sayHi[“text2”] = “Hello World... again.”;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sayHi[“text”]); <span class=\"comment\">// displays “Hello World!”</span></span><br><span class=\"line\">alert(sayHi.text2); <span class=\"comment\">// displays “Hello World... again.”</span></span><br></pre></td></tr></table></figure>\n<p>作为对象，函数还可以赋给变量、作为参数传递给其他函数、作为其他函数的值返回，并可以作为对象的属性或数组的元素进行存储等等。下面提供了这样一个示例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// assign an anonymous function to a variable</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    alert(“Hello, “ + x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">greet(“MSDN readers”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// passing a function as an argument to another</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">operateOn</span>(<span class=\"params\">num, func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(operateOn(<span class=\"number\">16</span>, square));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as return values</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeIncrementer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = makeIncrementer();</span><br><span class=\"line\"><span class=\"comment\">// displays 8</span></span><br><span class=\"line\">alert(inc(<span class=\"number\">7</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions stored as array elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x; &#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = arr[<span class=\"number\">0</span>](<span class=\"number\">2</span>);</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">arr[<span class=\"number\">3</span>] = arr[<span class=\"number\">0</span>](arr[<span class=\"number\">2</span>]);</span><br><span class=\"line\"><span class=\"comment\">// displays 256</span></span><br><span class=\"line\">alert(arr[<span class=\"number\">3</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// functions as object properties</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; “toString” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> “This is an object.”; &#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// calls obj.toString()</span></span><br><span class=\"line\">alert(obj);</span><br></pre></td></tr></table></figure>\n<p>记住这一点后，向对象添加方法将是很容易的事情：只需选择名称，然后将函数赋给该名称。因此，我通过将匿名函数分别赋给相应的方法名称，在对象中定义了三个方法： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myDog = &#123;</span><br><span class=\"line\">    “name” : “Spot”,</span><br><span class=\"line\">    “bark” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; alert(“Woof!”); &#125;,</span><br><span class=\"line\">    “displayFullName” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        alert(<span class=\"keyword\">this</span>.name + “ The Alpha Dog”);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    “chaseMrPostman” : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">// implementation beyond the scope of this article </span></span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myDog.displayFullName(); </span><br><span class=\"line\">myDog.bark(); <span class=\"comment\">// Woof!</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`        </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">C++/C# 开发人员应当很熟悉 displayFullName 函数中使用的“this”关键字 — 它引用一个对象，通过对象调用方法（使用 Visual Basic 的开发人员也应当很熟悉它，它在 Visual Basic 中叫做“Me”）。因此在上面的示例中，displayFullName 中的“this”的值是 myDog 对象。但是，“this”的值不是静态的。通过不同对象调用“this”时，它的值也会更改以便指向相应的对象，如下所示。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### “this”随对象更改而更改</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">displayQuote</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// the value of “this” will change; depends on </span></span><br><span class=\"line\">    <span class=\"comment\">// which object it is called through</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.memorableQuote);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> williamShakespeare = &#123;</span><br><span class=\"line\">    “memorableQuote”: “It is a wise father that knows his own child.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> markTwain = &#123;</span><br><span class=\"line\">    “memorableQuote”: “Golf is a good walk spoiled.”, </span><br><span class=\"line\">    “sayIt” : displayQuote</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> oscarWilde = &#123;</span><br><span class=\"line\">    “memorableQuote”: “True friends stab you <span class=\"keyword\">in</span> the front.” </span><br><span class=\"line\">    <span class=\"comment\">// we can call the function displayQuote</span></span><br><span class=\"line\">    <span class=\"comment\">// as a method of oscarWilde without assigning it </span></span><br><span class=\"line\">    <span class=\"comment\">// as oscarWilde’s method. </span></span><br><span class=\"line\">    <span class=\"comment\">//”sayIt” : displayQuote</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">williamShakespeare.sayIt(); <span class=\"comment\">// true, true</span></span><br><span class=\"line\">markTwain.sayIt(); <span class=\"comment\">// he didn’t know where to play golf</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// watch this, each function has a method call()</span></span><br><span class=\"line\"><span class=\"comment\">// that allows the function to be called as a </span></span><br><span class=\"line\"><span class=\"comment\">// method of the object passed to call() as an</span></span><br><span class=\"line\"><span class=\"comment\">// argument. </span></span><br><span class=\"line\"><span class=\"comment\">// this line below is equivalent to assigning</span></span><br><span class=\"line\"><span class=\"comment\">// displayQuote to sayIt, and calling oscarWilde.sayIt().</span></span><br><span class=\"line\">displayQuote.call(oscarWilde); <span class=\"comment\">// ouch!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中最后一行表示的是将函数作为对象的方法进行调用的另一种方式。请记住，JavaScript 中的函数是对象。每个函数对象都有一个名为 call 的方法，它将函数作为第一个参数的方法进行调用。就是说，作为函数第一个参数传递给 call 的任何对象都将在函数调用中成为“this”的值。这一技术对于调用基类构造函数来说非常有用，稍后将对此进行介绍。</p>\n<p>有一点需要记住，绝不要调用包含“this”（却没有所属对象）的函数。否则，将违反全局命名空间，因为在该调用中，“this”将引用全局对象，而这必然会给您的应用程序带来灾难。例如，下面的脚本将更改 JavaScript 的全局函数 isNaN 的行为。一定不要这样做！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">x</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.isNaN = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> “not anymore!”;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// alert!!! trampling the Global object!!!</span></span><br><span class=\"line\">x();</span><br><span class=\"line\"></span><br><span class=\"line\">alert(“<span class=\"literal\">NaN</span> is <span class=\"literal\">NaN</span>: “ + <span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>));</span><br></pre></td></tr></table></figure>\n<p>到这里，我们已经介绍了如何创建对象，包括它的属性和方法。但如果注意上面的所有代码段，您会发现属性和方法是在对象定义本身中进行硬编码的。但如果需要更好地控制对象的创建，该怎么做呢？例如，您可能需要根据某些参数来计算对象的属性值。或者，可能需要将对象的属性初始化为仅在运行时才能获得的值。也可能需要创建对象的多个实例（此要求非常常见）。</p>\n<pre><code>在 C# 中，我们使用类来实例化对象实例。但 JavaScript 与此不同，因为它没有类。您将在下一节中看到，您可以充分利用这一情况：函数在与“new”运算符一起使用时，函数将充当构造函数。\n</code></pre><h3 id=\"构造函数而不是类\"><a href=\"#构造函数而不是类\" class=\"headerlink\" title=\"构造函数而不是类\"></a>构造函数而不是类</h3><p>前面提到过，有关 JavaScript OOP 的最奇怪的事情是，JavaScript 不像 C# 或 C++ 那样，它没有类。在 C# 中，在执行类似下面的操作时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog spot = <span class=\"keyword\">new</span> Dog();</span><br></pre></td></tr></table></figure></p>\n<p>将返回一个对象，该对象是 Dog 类的实例。但在 JavaScript 中，本来就没有类。与访问类最近似的方法是定义构造函数，如下所示：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DogConstructor</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br><span class=\"line\">spot.respondTo(“Rover”); <span class=\"comment\">// nope</span></span><br><span class=\"line\">spot.respondTo(“Spot”); <span class=\"comment\">// yeah!</span></span><br></pre></td></tr></table></figure>\n<p>那么，结果会怎样呢？暂时忽略 DogConstructor 函数定义，看一看这一行：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> DogConstructor(“Spot”);</span><br></pre></td></tr></table></figure></p>\n<p>“new”运算符执行的操作很简单。首先，它创建一个新的空对象。然后执行紧随其后的函数调用，将新的空对象设置为该函数中“this”的值。换句话说，可以认为上面这行包含“new”运算符的代码与下面两行代码的功能相当： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create an empty object</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = &#123;&#125;; </span><br><span class=\"line\"><span class=\"comment\">// call the function as a method of the empty object</span></span><br><span class=\"line\">DogConstructor.call(spot, “Spot”);</span><br></pre></td></tr></table></figure>\n<p>正如在 DogConstructor 主体中看到的那样，调用此函数将初始化对象，在调用期间关键字“this”将引用此对象。这样，就可以为对象创建模板！只要需要创建类似的对象，就可以与构造函数一起调用“new”，返回的结果将是一个完全初始化的对象。这与类非常相似，不是吗？实际上，在 JavaScript 中构造函数的名称通常就是所模拟的类的名称，因此在上面的示例中，可以直接命名构造函数 Dog：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Think of this as class Dog</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// instance variable </span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// instance method? Hmmm...</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.name == name) &#123;</span><br><span class=\"line\">            alert(“Woof”);        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br></pre></td></tr></table></figure>\n<p>在上面的 Dog 定义中，我定义了名为 name 的实例变量。使用 Dog 作为其构造函数所创建的每个对象都有它自己的实例变量名称副本（前面提到过，它就是对象词典的条目）。这就是希望的结果。毕竟，每个对象都需要它自己的实例变量副本来表示其状态。但如果看看下一行，就会发现每个 Dog 实例也都有它自己的 respondTo 方法副本，这是个浪费；您只需要一个可供各个 Dog 实例共享的 respondTo 实例！通过在 Dog 以外定义 respondTo，可以避免此问题，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respondTo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// respondTo definition</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"comment\">// attached this function as a method of the object</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.respondTo = respondTo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，所有 Dog 实例（即用构造函数 Dog 创建的所有实例）都可以共享 respondTo 方法的一个实例。但随着方法数的增加，维护工作将越来越难。最后，基本代码中将有很多全局函数，而且随着“类”的增加，事情只会变得更加糟糕（如果它们的方法具有相似的名称，则尤甚）。但使用原型对象可以更好地解决这个问题，这是下一节的主题。</p>\n<h2 id=\"三、Javascript核心理论原型\"><a href=\"#三、Javascript核心理论原型\" class=\"headerlink\" title=\"三、Javascript核心理论原型\"></a>三、Javascript核心理论原型</h2><p>在使用 JavaScript 的面向对象编程中，原型对象是个核心概念。在 JavaScript 中对象是作为现有示例（即原型）对象的副本而创建的，该名称就来自于这一概念。此原型对象的任何属性和方法都将显示为从原型的构造函数创建的对象的属性和方法。可以说，这些对象从其原型继承了属性和方法。当您创建如下所示的新 Dog 对象时：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> buddy = <span class=\"keyword\">new</span> Dog(“Buddy“);</span><br></pre></td></tr></table></figure></p>\n<p>buddy 所引用的对象将从它的原型继承属性和方法，尽管仅从这一行可能无法明确判断原型来自哪里。对象 buddy 的原型来自构造函数（在这里是函数 Dog）的属性。</p>\n<p>在 JavaScript 中，每个函数都有名为“prototype”的属性，用于引用原型对象。此原型对象又有名为“constructor”的属性，它反过来引用函数本身。这是一种循环引用，图A1 更好地说明了这种循环关系。</p>\n<p><img src=\"/imgs/ooj-1.gif\" alt=\"图A1 每个函数的原型都有一个 Constructor 属性\"></p>\n<p>现在，通过“new”运算符用函数（上面示例中为 Dog）创建对象时，所获得的对象将继承 Dog.prototype 的属性。在图A1 中，可以看到 Dog.prototype 对象有一个回指 Dog 函数的构造函数属性。这样，每个 Dog 对象（从 Dog.prototype 继承而来）都有一个回指 Dog 函数的构造函数属性。代码段B1 中的代码证实了这一点。图A2 显示了构造函数、原型对象以及用它们创建的对象之间的这一关系。</p>\n<h1 id=\"代码段B1\"><a href=\"#代码段B1\" class=\"headerlink\" title=\"代码段B1\"></a>代码段B1</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> Dog(“Spot”);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dog.prototype is the prototype of spot</span></span><br><span class=\"line\">alert(Dog.prototype.isPrototypeOf(spot));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// spot inherits the constructor property</span></span><br><span class=\"line\"><span class=\"comment\">// from Dog.prototype</span></span><br><span class=\"line\">alert(spot.constructor == Dog.prototype.constructor);</span><br><span class=\"line\">alert(spot.constructor == Dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But constructor property doesn’t belong</span></span><br><span class=\"line\"><span class=\"comment\">// to spot. The line below displays “false”</span></span><br><span class=\"line\">alert(spot.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br><span class=\"line\"></span><br><span class=\"line\">// The <span class=\"keyword\">constructor</span> property belongs to Dog.prototype</span><br><span class=\"line\">// The line below displays “true”</span><br><span class=\"line\">alert(Dog.prototype.hasOwnProperty(“<span class=\"keyword\">constructor</span>”));</span><br></pre></td></tr></table></figure>\n<p><img src=\"/imgs/ooj-2.gif\" alt=\"图A2-实例继承其原型\"></p>\n<p>某些读者可能已经注意到代码段B1 中对 hasOwnProperty 和 isPrototypeOf 方法的调用。这些方法是从哪里来的呢？它们不是来自 Dog.prototype。实际上，在 Dog.prototype 和 Dog 实例中还可以调用其他方法，比如 toString、toLocaleString 和 valueOf，但它们都不来自 Dog.prototype。您会发现，就像 .NET Framework 中的 System.Object 充当所有类的最终基类一样，JavaScript 中的 Object.prototype 是所有原型的最终基础原型。（Object.prototype 的原型是 null。）<br>在此示例中，请记住 Dog.prototype 是对象。它是通过调用 Object 构造函数创建的（尽管它不可见）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br></pre></td></tr></table></figure>\n<p>因此，正如 Dog 实例继承 Dog.prototype 一样，Dog.prototype 继承 Object.prototype。这使得所有 Dog 实例也继承了 Object.prototype 的方法和属性。<br>每个 JavaScript 对象都继承一个原型链，而所有原型都终止于 Object.prototype。注意，迄今为止您看到的这种继承是活动对象之间的继承。它不同于继承的常见概念，后者是指在声明类时类之间的发生的继承。因此，JavaScript 继承动态性更强。它使用简单算法实现这一点，如下所示：当您尝试访问对象的属性/方法时，JavaScript 将检查该属性/方法是否是在该对象中定义的。如果不是，则检查对象的原型。如果还不是，则检查该对象的原型的原型，如此继续，一直检查到 Object.prototype。<br>图A3 说明了此解析过程。</p>\n<p><img src=\"/imgs/ooj-3.gif\" alt=\"图A3 在原型链中解析 toString() 方法\"></p>\n<p>JavaScript 动态地解析属性访问和方法调用的方式产生了一些特殊效果：</p>\n<ul>\n<li>继承原型对象的对象上可以立即呈现对原型所做的更改，即使是在创建这些对象之后。</li>\n<li>如果在对象中定义了属性/方法 X，则该对象的原型中将隐藏同名的属性/方法。例如，通过在 Dog.prototype 中定义 toString 方法，可以改写 Object.prototype 的 toString 方法。</li>\n<li>更改只沿一个方向传递，即从原型到它的派生对象，但不能沿相反方向传递。</li>\n</ul>\n<p>代码段B2 说明了这些效果。B2还显示了如何解决前面遇到的不需要的方法实例的问题。通过将方法放在原型内部，可以使对象共享方法，而不必使每个对象都有单独的函数对象实例。在此示例中，rover 和 spot 共享 getBreed 方法，直至在 spot 中以任何方式改写 toString 方法。此后，spot 有了它自己版本的 getBreed 方法，但 rover 对象和用新 GreatDane 创建的后续对象仍将共享在 GreatDane.prototype 对象中定义的那个 getBreed 方法实例。</p>\n<h2 id=\"代码段B2-继承原型\"><a href=\"#代码段B2-继承原型\" class=\"headerlink\" title=\"代码段B2-继承原型\"></a>代码段B2-继承原型</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GreatDane</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rover = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"><span class=\"keyword\">var</span> spot = <span class=\"keyword\">new</span> GreatDane();</span><br><span class=\"line\"></span><br><span class=\"line\">GreatDane.prototype.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Works, even though at this point</span></span><br><span class=\"line\"><span class=\"comment\">// rover and spot are already created.</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this hides getBreed() in GreatDane.prototype</span></span><br><span class=\"line\">spot.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “Little Great Dane”;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">alert(spot.getBreed()); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// but of course, the change to getBreed </span></span><br><span class=\"line\"><span class=\"comment\">// doesn’t propagate back to GreatDane.prototype</span></span><br><span class=\"line\"><span class=\"comment\">// and other objects inheriting from it,</span></span><br><span class=\"line\"><span class=\"comment\">// it only happens in the spot object</span></span><br><span class=\"line\">alert(rover.getBreed());</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态属性和方法\"><a href=\"#静态属性和方法\" class=\"headerlink\" title=\"静态属性和方法\"></a>静态属性和方法</h3><p>有时，您需要绑定到类而不是实例的属性或方法，也就是，静态属性和方法。在 JavaScript 中很容易做到这一点，因为函数是可以按需要设置其属性和方法的对象。由于在 JavaScript 中构造函数表示类，因此可以通过在构造函数中设置静态方法和属性，直接将它们添加到类中，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DateTime</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set static method now()</span></span><br><span class=\"line\">    DateTime.now = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert(DateTime.now());</span><br></pre></td></tr></table></figure>\n<p>在 JavaScript 中调用静态方法的语法与在 C# 中几乎完全相同。这不应当让人感到吃惊，因为构造函数的名称实际上是类的名称。这样，就有了类、公用属性/方法，以及静态属性/方法。还需要其他什么吗？当然，私有成员。但 JavaScript 本身并不支持私有成员（同样，也不支持受保护成员）。任何人都可以访问对象的所有属性和方法。但我们有办法让类中包含私有成员，但在此之前，您首先需要理解闭包。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>不了解JAVASCRIPT就不要说JAVASCRIPT多么的简单或有多么的难学。JavaScript 实际上是功能强大、表现力强而且非常简练的语言。它甚至具有其他更流行的语言才刚刚开始支持的功能。<br>JavaScript 的更高级功能之一是它支持闭包，这是 C# 2.0 通过它的匿名方法支持的功能。闭包是当内部函数（或 C# 中的内部匿名方法）绑定到它的外部函数的本地变量时所发生的运行时现象。很明显，除非此内部函数以某种方式可被外部函数访问，否则它没有多少意义。示例可以更好说明这一点。<br>假设需要根据一个简单条件筛选一个数字序列，这个条件是：只有大于 100 的数字才能通过筛选，并忽略其余数字。为此，可以编写类似代码段B3 中的函数。</p>\n<h1 id=\"代码段B3-根据谓词筛选元素\"><a href=\"#代码段B3-根据谓词筛选元素\" class=\"headerlink\" title=\"代码段B3 -根据谓词筛选元素\"></a>代码段B3 -根据谓词筛选元素</h1><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">pred, arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> filtered = []; <span class=\"comment\">// shorter version of new Array();</span></span><br><span class=\"line\">    <span class=\"comment\">// iterate through every element in the array...</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = arr[i];</span><br><span class=\"line\">        <span class=\"comment\">// if the element satisfies the predicate let it through</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pred(val)) &#123;</span><br><span class=\"line\">            filtered.push(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> filtered;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someRandomNumbers = [<span class=\"number\">12</span>, <span class=\"number\">32</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">234</span>, <span class=\"number\">236</span>, <span class=\"number\">632</span>,<span class=\"number\">7</span>, <span class=\"number\">8</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbersGreaterThan100 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">100</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// displays 234, 236, 632</span></span><br><span class=\"line\">alert(numbersGreaterThan100);</span><br></pre></td></tr></table></figure>\n<p>但是，现在要创建不同的筛选条件，假设这次只有大于 300 的数字才能通过筛选，则可以编写下面这样的函数：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan300 = filter(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> (x &gt; <span class=\"number\">300</span>) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>; &#125;, </span><br><span class=\"line\">    someRandomNumbers);</span><br></pre></td></tr></table></figure></p>\n<p>然后，也许需要筛选大于 50、25、10、600 如此等等的数字，但作为一个聪明人，您会发现它们全部都有相同的谓词“greater than”，只有数字不同。因此，可以用类似下面的函数分开各个数字：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeGreaterThanPredicate</span>(<span class=\"params\">lowerBound</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numberToCheck</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (numberToCheck &gt; lowerBound) ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，您就可以编写以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greaterThan10 = makeGreaterThanPredicate(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> greaterThan100 = makeGreaterThanPredicate(<span class=\"number\">100</span>);</span><br><span class=\"line\">alert(filter(greaterThan10, someRandomNumbers));</span><br><span class=\"line\">alert(filter(greaterThan100, someRandomNumbers));</span><br></pre></td></tr></table></figure></p>\n<p>通过观察函数 makeGreaterThanPredicate 返回的内部匿名函数，可以发现，该匿名内部函数使用 lowerBound，后者是传递给 makeGreaterThanPredicate 的参数。按照作用域的一般规则，当 makeGreaterThanPredicate 退出时，lowerBound 超出了作用域！但在这里，内部匿名函数仍然携带 lowerBound，甚至在 makeGreaterThanPredicate 退出之后的很长时间内仍然如此。这就是我们所说的闭包：因为内部函数关闭了定义它的环境（即外部函数的参数和本地变量）。</p>\n<p>开始可能感觉不到闭包的功能很强大。但如果应用恰当，它们就可以非常有创造性地帮您将想法转换成代码，这个过程非常有趣。在 JavaScript 中，闭包最有趣的用途之一是模拟类的私有变量。</p>\n<h2 id=\"模拟私有属性\"><a href=\"#模拟私有属性\" class=\"headerlink\" title=\"模拟私有属性\"></a>模拟私有属性</h2><p>现在介绍闭包如何帮助模拟私有成员。正常情况下，无法从函数以外访问函数内的本地变量。函数退出之后，由于各种实际原因，该本地变量将永远消失。但是，如果该本地变量被内部函数的闭包捕获，它就会生存下来。这一事实是模拟 JavaScript 私有属性的关键。假设有一个 Person 类：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> age; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newAge</span>) </span>&#123; age = newAge; &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参数 name 和 age 是构造函数 Person 的本地变量。Person 返回时，name 和 age 应当永远消失。但是，它们被作为 Person 实例的方法而分配的四个内部函数捕获，实际上这会使 name 和 age 继续存在，但只能严格地通过这四个方法访问它们。因此，您可以：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ray = <span class=\"keyword\">new</span> Person(“Ray”, <span class=\"number\">31</span>);</span><br><span class=\"line\">alert(ray.getName());</span><br><span class=\"line\">alert(ray.getAge());</span><br><span class=\"line\">ray.setName(“Younger Ray”);</span><br><span class=\"line\"><span class=\"comment\">// Instant rejuvenation!</span></span><br><span class=\"line\">ray.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">alert(ray.getName() + “ is now “ + ray.getAge() + </span><br><span class=\"line\">      “ years old.”);</span><br></pre></td></tr></table></figure>\n<p>未在构造函数中初始化的私有成员可以成为构造函数的本地变量，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> occupation;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> occupation; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setOccupation = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newOcc</span>) </span>&#123; occupation = </span><br><span class=\"line\">                         newOcc; &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// accessors for name and age    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，这些私有成员与我们期望从 C# 中产生的私有成员略有不同。在 C# 中，类的公用方法可以访问它的私有成员。但在 JavaScript 中，只能通过在其闭包内拥有这些私有成员的方法来访问私有成员（由于这些方法不同于普通的公用方法，它们通常被称为特权方法）。因此，在 Person 的公用方法中，仍然必须通过私有成员的特权访问器方法才能访问私有成员：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person.prototype.somePublicMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// doesn’t work!</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(this.name);</span></span><br><span class=\"line\">    <span class=\"comment\">// this one below works</span></span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.getName());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>Douglas Crockford 是著名的发现（或者也许是发布）使用闭包来模拟私有成员这一技术的第一人。他的网站 javascript.crockford.com 包含有关 JavaScript 的丰富信息，任何对 JavaScript 感兴趣的开发人员都应当仔细研读。</p>\n<h2 id=\"从类继承\"><a href=\"#从类继承\" class=\"headerlink\" title=\"从类继承\"></a>从类继承</h2><p>到这里，我们已经了解了构造函数和原型对象如何使您在 JavaScript 中模拟类。您已经看到，原型链可以确保所有对象都有 Object.prototype 的公用方法，以及如何使用闭包来模拟类的私有成员。但这里还缺少点什么。您尚未看到如何从类派生，这在 C# 中是每天必做的工作。遗憾的是，在 JavaScript 中从类继承并非像在 C# 中键入冒号即可继承那样简单，它需要进行更多操作。另一方面，JavaScript 非常灵活，可以有很多从类继承的方式。<br>例如，有一个基类 Pet，它有一个派生类 Dog，如图A4 所示。这个在 JavaScript 中如何实现呢？Pet 类很容易。您已经看见如何实现它了：</p>\n<p><img src=\"/imgs/ooj-4.gif\" alt=\"图A4-类图\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Pet</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Pet</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> name; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>) </span>&#123; name = newName; &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This pet’s name is: “ + <span class=\"keyword\">this</span>.getName();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Pet</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parrotty = <span class=\"keyword\">new</span> Pet(“Parrotty the Parrot”);</span><br><span class=\"line\">alert(parrotty);</span><br></pre></td></tr></table></figure>\n<p>现在，如何创建从 Pet 派生的类 Dog 呢？在图A4 中可以看到，Dog 有另一个属性 breed，它改写了 Pet 的 toString 方法（注意，JavaScript 的约定是方法和属性名称使用 camel 大小写，而不是在 C# 中建议的 Pascal 大小写）。代码段B3 显示如何这样做。</p>\n<h2 id=\"代码段B3-从PET类派生\"><a href=\"#代码段B3-从PET类派生\" class=\"headerlink\" title=\"代码段B3-从PET类派生\"></a>代码段B3-从PET类派生</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// class Dog : Pet </span></span><br><span class=\"line\"><span class=\"comment\">// public Dog(string name, string breed)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name, breed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// think Dog : base(name) </span></span><br><span class=\"line\">    Pet.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getBreed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> breed; &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Breed doesn’t change, obviously! It’s read only.</span></span><br><span class=\"line\">    <span class=\"comment\">// this.setBreed = function(newBreed) &#123; name = newName; &#125;;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this makes Dog.prototype inherits</span></span><br><span class=\"line\"><span class=\"comment\">// from Pet.prototype</span></span><br><span class=\"line\">Dog.prototype = <span class=\"keyword\">new</span> Pet();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remember that Pet.prototype.constructor</span></span><br><span class=\"line\"><span class=\"comment\">// points to Pet. We want our Dog instances’</span></span><br><span class=\"line\"><span class=\"comment\">// constructor to point to Dog.</span></span><br><span class=\"line\">Dog.prototype.constructor = Dog;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Now we override Pet.prototype.toString</span></span><br><span class=\"line\">Dog.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> “This dog’s name is: “ + <span class=\"keyword\">this</span>.getName() + </span><br><span class=\"line\">        “, and its breed is: “ + <span class=\"keyword\">this</span>.getBreed();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// end of class Dog</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(“Buddy”, “Great Dane”);</span><br><span class=\"line\"><span class=\"comment\">// test the new toString()</span></span><br><span class=\"line\">alert(dog);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Testing instanceof (similar to the is operator)</span></span><br><span class=\"line\"><span class=\"comment\">// (dog is Dog)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Dog);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Pet)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> Pet);</span><br><span class=\"line\"><span class=\"comment\">// (dog is Object)? yes</span></span><br><span class=\"line\">alert(dog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<p>所使用的原型 — 替换技巧正确设置了原型链，因此假如使用 C#，测试的实例将按预期运行。而且，特权方法仍然会按预期运行。</p>\n<h2 id=\"模拟命名空间\"><a href=\"#模拟命名空间\" class=\"headerlink\" title=\"模拟命名空间\"></a>模拟命名空间</h2><p>在 C++ 和 C# 中，命名空间用于尽可能地减少名称冲突。例如，在 .NET Framework 中，命名空间有助于将 Microsoft.Build.Task.Message 类与 System.Messaging.Message 区分开来。JavaScript 没有任何特定语言功能来支持命名空间，但很容易使用对象来模拟命名空间。如果要创建一个 JavaScript 库，则可以将它们包装在命名空间内，而不需要定义全局函数和类，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code here &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>命名空间的一个级别可能不是唯一的，因此可以创建嵌套的命名空间：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MSDNMagNS = &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// nested namespace “Examples”</span></span><br><span class=\"line\">MSDNMagNS.Examples = &#123;&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\">MSDNMagNS.Examples.Pet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\">MSDNMagNS.Examples.Pet.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// code &#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> MSDNMagNS.Examples.Pet(“Yammer”);</span><br></pre></td></tr></table></figure>\n<p>可以想象，键入这些冗长的嵌套命名空间会让人很累。 幸运的是，库用户可以很容易地为命名空间指定更短的别名：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MSDNMagNS.Examples and Pet definition...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// think “using Eg = MSDNMagNS.Examples;” </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Eg = MSDNMagNS.Examples;</span><br><span class=\"line\"><span class=\"keyword\">var</span> pet = <span class=\"keyword\">new</span> Eg.Pet(“Yammer”);</span><br><span class=\"line\">alert(pet);</span><br></pre></td></tr></table></figure>\n<p>如果看一下 Microsoft AJAX 库的源代码，就会发现库的作者使用了类似的技术来实现命名空间（请参阅静态方法 Type.registerNamespace 的实现）。有关详细信息，请参与侧栏“OOP 和 ASP.NET AJAX”。</p>\n<h2 id=\"应当这样编写-JavaScript-代码吗？\"><a href=\"#应当这样编写-JavaScript-代码吗？\" class=\"headerlink\" title=\"应当这样编写 JavaScript 代码吗？\"></a>应当这样编写 JavaScript 代码吗？</h2><p>您已经看见 JavaScript 可以很好地支持面向对象的编程。尽管它是一种基于原型的语言，但它的灵活性和强大功能可以满足在其他流行语言中常见的基于类的编程风格。但问题是：是否应当这样编写 JavaScript 代码？在 JavaScript 中的编程方式是否应与 C# 或 C++ 中的编码方式相同？是否有更聪明的方式来模拟 JavaScript 中没有的功能？每种编程语言都各不相同，一种语言的最佳做法，对另一种语言而言则可能并非最佳。<br>在 JavaScript 中，您已看到对象继承对象（与类继承类不同）。因此，使用静态继承层次结构建立很多类的方式可能并不适合 JavaScript。也许，就像 Douglas Crockford 在他的文章 Prototypal Inheritance in JavaScript 中说的那样，JavaScript 编程方式是建立原型对象，并使用下面的简单对象函数建立新的对象，而后者则继承原始对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">        F.prototype = o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>然后，由于 JavaScript 中的对象是可延展的，因此可以方便地在创建对象之后，根据需要用新字段和新方法增大对象。</p>\n<p>这的确很好，但它不可否认的是，全世界大多数开发人员更熟悉基于类的编程。实际上，基于类的编程也会在这里出现。按照即将颁发的 ECMA-262 规范第 4 版（ECMA-262 是 JavaScript 的官方规范），JavaScript 2.0 将拥有真正的类。因此，JavaScript 正在发展成为基于类的语言。但是，数年之后 JavaScript 2.0 才可能会被广泛使用。同时，必须清楚当前的 JavaScript 完全可以用基于原型的风格和基于类的风格读取和写入 JavaScript 代码。</p>\n<p>…更多内容请看下篇文章</p>\n<h2 id=\"四、作者总结\"><a href=\"#四、作者总结\" class=\"headerlink\" title=\"四、作者总结\"></a>四、作者总结</h2><p>　　面向对象的JAVASCRIPT编程技术极大的拓展了JAVASCRIPT的应用。对WEB2.0的发展起到了关键性的作用。作为新一代的IT农民工，学习掌握这门奇特的语言将在未来的工作中受益匪浅。</p>\n<p>　　随着交互式胖客户端 AJAX 应用程序的广泛使用，越来越多的程序员开始学习和使用JAVASCRIPT，我也将在未来一段时间内不断的学习使用JAVASCRIPT更多的与ASP.NET之间的结合。</p>\n<p>　　本文献给刚出茅庐的农民工们！希望大家在城市的建设中发挥自己最大的能量。</p>\n<p>　　本文作者：朱峰（Peter Zhu）</p>\n<p>　　发表时间：2010-05-31</p>\n<h2 id=\"五、本文参考引用文章列表\"><a href=\"#五、本文参考引用文章列表\" class=\"headerlink\" title=\"五、本文参考引用文章列表\"></a>五、本文参考引用文章列表</h2><ol>\n<li><p>使用面向对象的技术创建高级Web 应用程序 <a href=\"http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/magazine/cc163419.aspx</a></p>\n</li>\n<li><p>百度知道 <a href=\"http://baike.baidu.com/view/125370.htm\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/125370.htm</a> </p>\n</li>\n<li><p>OOJ-面向对象的JAVASCRIPT - <a href=\"http://www.cnblogs.com/taoqianbao/archive/2010/05/31/OOJ.html\" target=\"_blank\" rel=\"noopener\">PeterZhu</a></p>\n</li>\n</ol>\n"},{"title":"OOJ-面向对象的JAVASCRIPT（二）","p":"javascript/OOJ-TWO","date":"2010-05-31T12:52:05.000Z","_content":"\n本文继上篇文章介绍javascript 匿名函数以及闭包的特性\n----------------\n\n## 1、什么叫匿名函数？\n\n　　匿名函数：就是没有函数名的函数。\n\n　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。\n\n1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式\n\n第一种：这也是最常规的一种\n\n``` JS\nfunction double( x ){\n\n    return 2 * x;  \n\n}\n``` \n\n第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。\n``` JS\nvar double = new Function( 'x'  , ' return 2 * x;');\n``` \n\n第三种：\n``` JS\nvar double = function( x ) { return 2* x; }\n``` \n\n注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。\n\n2、匿名函数的创建\n\n第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。\n\n第二种方式：\n``` JS\n(function( x , y){\n\n    alert( x + y); \n\n})(2 ,3 );//函数的自调用的形式，直接可以得出结果。\n```\n这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。\n\n## 2、闭包\n闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。\n\n闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。\n\n示例一：\n``` JS\nfunction checkClosure(){\n\n    var str = 'rain-man';\n\n    setTimeout(\n\n        function(){ alert( str ); } //这是一个匿名函数\n\n    , 2000);\n\n}//这个函数要求延迟2秒执行。\n\ncheckClosure();\n```\n这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。\n\n``` JS\n//示例二：优化代码\n\nfunction forTimeout( x, y){\n\n    alert( x + y );\n\n}\n\nfunction delay( x , y  , time ){\n    setTimeout( 'forTimeout(' +  x + ',' +  y + ')' , time );   \n}\n\n/**\n *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰\n\nfunction delay( x , y , time ){\n\n    setTimeout(\n\n        function(){\n\n            forTimeout( x , y )\n\n        }         \n\n    , time );  \n\n}\n*/\n```\n\n举例\n\n匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。\n\n``` JS\n//示例三：\nvar oEvent = {};\n(function(){\nvar addEvent = function(){ /*代码的实现省略了*/ };\nfunction removeEvent(){}\noEvent.addEvent = addEvent;\noEvent.removeEvent = removeEvent;\n})();\n```\n\n在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。\n\n我们要想使用此段代码：\n``` JS\noEvent.addEvent( document.getElementById('box') , 'click' , function(){} );\n```\n\n``` JS\n//示例四：\n\nvar rainman = (function( x , y ){\n    return x + y;\n})( 2 , 3 );\n/**\n *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。\nvar rainman = function( x , y ){\n    return x + y;\n}( 2 , 3 );\n*/\n```\n\n在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。\n\n``` JS\n示例五：\n\nvar outer = null;\n(function(){\nvar one = 1;\nfunction inner (){\n    one += 1;\n    alert( one );\n}\nouter = inner;\n})();\nouter();    //2\nouter();    //3\nouter();    //4\n\n```\n\n这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。\n\n注意\n\n一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。\n\n``` JS\n示例六：\n\n/**\n<body>\n<ul>\n    <li>one</li>\n    <li>two</li>\n    <li>three</li>\n    <li>one</li>\n</ul>\n*/\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].onmouseover = function(){\n        alert( i );       };\n}\n```\n\n你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。\n\n``` JS\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。\n\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n解决方法一：\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    (function( index ){\n        lists[ index ].onmouseover = function(){\n            alert( index );   \n        };                   \n    })( i );//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。\n}\n\n解决方法二：\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].$$index = i;    //通过在Dom元素上绑定$$index属性记录下标\n    lists[ i ].onmouseover = function(){\n        alert( this.$$index );   \n    };\n}\n\n解决方法三：\n\nfunction eventListener( list , index ){\n    list.onmouseover = function(){\n        alert(index);\n    };\n}\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    eventListener( lists[ i ] , i );\n}\n```","source":"_posts/javascript/OOJ-TWO.md","raw":"---\ntitle: OOJ-面向对象的JAVASCRIPT（二）\np: javascript/OOJ-TWO\ndate: 2010-05-31 20:52:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n本文继上篇文章介绍javascript 匿名函数以及闭包的特性\n----------------\n\n## 1、什么叫匿名函数？\n\n　　匿名函数：就是没有函数名的函数。\n\n　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。\n\n1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式\n\n第一种：这也是最常规的一种\n\n``` JS\nfunction double( x ){\n\n    return 2 * x;  \n\n}\n``` \n\n第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。\n``` JS\nvar double = new Function( 'x'  , ' return 2 * x;');\n``` \n\n第三种：\n``` JS\nvar double = function( x ) { return 2* x; }\n``` \n\n注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。\n\n2、匿名函数的创建\n\n第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。\n\n第二种方式：\n``` JS\n(function( x , y){\n\n    alert( x + y); \n\n})(2 ,3 );//函数的自调用的形式，直接可以得出结果。\n```\n这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。\n\n## 2、闭包\n闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。\n\n闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。\n\n示例一：\n``` JS\nfunction checkClosure(){\n\n    var str = 'rain-man';\n\n    setTimeout(\n\n        function(){ alert( str ); } //这是一个匿名函数\n\n    , 2000);\n\n}//这个函数要求延迟2秒执行。\n\ncheckClosure();\n```\n这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。\n\n``` JS\n//示例二：优化代码\n\nfunction forTimeout( x, y){\n\n    alert( x + y );\n\n}\n\nfunction delay( x , y  , time ){\n    setTimeout( 'forTimeout(' +  x + ',' +  y + ')' , time );   \n}\n\n/**\n *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰\n\nfunction delay( x , y , time ){\n\n    setTimeout(\n\n        function(){\n\n            forTimeout( x , y )\n\n        }         \n\n    , time );  \n\n}\n*/\n```\n\n举例\n\n匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。\n\n``` JS\n//示例三：\nvar oEvent = {};\n(function(){\nvar addEvent = function(){ /*代码的实现省略了*/ };\nfunction removeEvent(){}\noEvent.addEvent = addEvent;\noEvent.removeEvent = removeEvent;\n})();\n```\n\n在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。\n\n我们要想使用此段代码：\n``` JS\noEvent.addEvent( document.getElementById('box') , 'click' , function(){} );\n```\n\n``` JS\n//示例四：\n\nvar rainman = (function( x , y ){\n    return x + y;\n})( 2 , 3 );\n/**\n *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。\nvar rainman = function( x , y ){\n    return x + y;\n}( 2 , 3 );\n*/\n```\n\n在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。\n\n``` JS\n示例五：\n\nvar outer = null;\n(function(){\nvar one = 1;\nfunction inner (){\n    one += 1;\n    alert( one );\n}\nouter = inner;\n})();\nouter();    //2\nouter();    //3\nouter();    //4\n\n```\n\n这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。\n\n注意\n\n一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。\n\n``` JS\n示例六：\n\n/**\n<body>\n<ul>\n    <li>one</li>\n    <li>two</li>\n    <li>three</li>\n    <li>one</li>\n</ul>\n*/\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].onmouseover = function(){\n        alert( i );       };\n}\n```\n\n你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。\n\n``` JS\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。\n\n＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃\n\n解决方法一：\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    (function( index ){\n        lists[ index ].onmouseover = function(){\n            alert( index );   \n        };                   \n    })( i );//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。\n}\n\n解决方法二：\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    lists[ i ].$$index = i;    //通过在Dom元素上绑定$$index属性记录下标\n    lists[ i ].onmouseover = function(){\n        alert( this.$$index );   \n    };\n}\n\n解决方法三：\n\nfunction eventListener( list , index ){\n    list.onmouseover = function(){\n        alert(index);\n    };\n}\n\nvar lists = document.getElementsByTagName('li');\nfor(var i = 0 , len = lists.length ; i < len ; i++ ){\n    eventListener( lists[ i ] , i );\n}\n```","slug":"javascript/OOJ-TWO","published":1,"updated":"2017-12-27T06:07:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4wf0006h2e350lc3spn","content":"<h2 id=\"本文继上篇文章介绍javascript-匿名函数以及闭包的特性\"><a href=\"#本文继上篇文章介绍javascript-匿名函数以及闭包的特性\" class=\"headerlink\" title=\"本文继上篇文章介绍javascript 匿名函数以及闭包的特性\"></a>本文继上篇文章介绍javascript 匿名函数以及闭包的特性</h2><h2 id=\"1、什么叫匿名函数？\"><a href=\"#1、什么叫匿名函数？\" class=\"headerlink\" title=\"1、什么叫匿名函数？\"></a>1、什么叫匿名函数？</h2><p>　　匿名函数：就是没有函数名的函数。</p>\n<p>　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。</p>\n<p>1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式</p>\n<p>第一种：这也是最常规的一种</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\"> x </span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * x;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>( <span class=\"string\">'x'</span>  , <span class=\"string\">' return 2 * x;'</span>);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第三种：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x </span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>* x; &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2、匿名函数的创建</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种方式：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y); </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span> ,<span class=\"number\">3</span> );<span class=\"comment\">//函数的自调用的形式，直接可以得出结果。</span></span><br></pre></td></tr></table></figure>\n<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。</p>\n<h2 id=\"2、闭包\"><a href=\"#2、闭包\" class=\"headerlink\" title=\"2、闭包\"></a>2、闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p>\n<p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p>\n<p>示例一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkClosure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'rain-man'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; alert( str ); &#125; <span class=\"comment\">//这是一个匿名函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    , <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">//这个函数要求延迟2秒执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">checkClosure();</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例二：优化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forTimeout</span>(<span class=\"params\"> x, y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\"> x , y  , time </span>)</span>&#123;</span><br><span class=\"line\">    setTimeout( <span class=\"string\">'forTimeout('</span> +  x + <span class=\"string\">','</span> +  y + <span class=\"string\">')'</span> , time );   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">function delay( x , y , time )&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    setTimeout(</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        function()&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">            forTimeout( x , y )</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        &#125;         </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    , time );  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>举例</p>\n<p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例三：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oEvent = &#123;&#125;;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/*代码的实现省略了*/</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeEvent</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">oEvent.addEvent = addEvent;</span><br><span class=\"line\">oEvent.removeEvent = removeEvent;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>\n<p>我们要想使用此段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oEvent.addEvent( <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>) , <span class=\"string\">'click'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; );</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例四：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainman = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;)( <span class=\"number\">2</span> , <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。</span></span><br><span class=\"line\"><span class=\"comment\">var rainman = function( x , y )&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return x + y;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;( 2 , 3 );</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例五：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    one += <span class=\"number\">1</span>;</span><br><span class=\"line\">    alert( one );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer = inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">outer();    <span class=\"comment\">//2</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//3</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。</p>\n<p>注意</p>\n<p>一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例六：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;two&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;three&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( i );       &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</li></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。</span><br><span class=\"line\"></span><br><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法一：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> index </span>)</span>&#123;</span><br><span class=\"line\">        lists[ index ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert( index );   </span><br><span class=\"line\">        &#125;;                   </span><br><span class=\"line\">    &#125;)( i );<span class=\"comment\">//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法二：</span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].$$index = i;    <span class=\"comment\">//通过在Dom元素上绑定$$index属性记录下标</span></span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( <span class=\"keyword\">this</span>.$$index );   </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法三：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventListener</span>(<span class=\"params\"> list , index </span>)</span>&#123;</span><br><span class=\"line\">    list.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    eventListener( lists[ i ] , i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"本文继上篇文章介绍javascript-匿名函数以及闭包的特性\"><a href=\"#本文继上篇文章介绍javascript-匿名函数以及闭包的特性\" class=\"headerlink\" title=\"本文继上篇文章介绍javascript 匿名函数以及闭包的特性\"></a>本文继上篇文章介绍javascript 匿名函数以及闭包的特性</h2><h2 id=\"1、什么叫匿名函数？\"><a href=\"#1、什么叫匿名函数？\" class=\"headerlink\" title=\"1、什么叫匿名函数？\"></a>1、什么叫匿名函数？</h2><p>　　匿名函数：就是没有函数名的函数。</p>\n<p>　　函数是JavaScript中最灵活的一种对象，这里只是讲解其匿名函数的用途。</p>\n<p>1、函数的定义，首先简单介绍一下函数的定义，大致可分为三种方式</p>\n<p>第一种：这也是最常规的一种</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\"> x </span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> * x;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种：这种方法使用了Function构造函数，把参数列表和函数体都作为字符串，很不方便，不建议使用。</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>( <span class=\"string\">'x'</span>  , <span class=\"string\">' return 2 * x;'</span>);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第三种：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\"><span class=\"keyword\">var</span> double = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x </span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>* x; &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">注意 '='右边的函数就是一个匿名函数，创造完毕函数后，又将该函数赋给了变量double。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2、匿名函数的创建</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第一种方式：就是上面所讲的定义square函数，这也是最常用的方式之一。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">第二种方式：</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> JS</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y); </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(<span class=\"number\">2</span> ,<span class=\"number\">3</span> );<span class=\"comment\">//函数的自调用的形式，直接可以得出结果。</span></span><br></pre></td></tr></table></figure>\n<p>这里创建了一个匿名函数(在第一个括号内)，第二个括号用于调用该匿名函数，并传入参数。</p>\n<h2 id=\"2、闭包\"><a href=\"#2、闭包\" class=\"headerlink\" title=\"2、闭包\"></a>2、闭包</h2><p>闭包的英文单词是closure，这是JavaScript中非常重要的一部分知识，因为使用闭包可以大大减少我们的代码量，使我们的代码看上去更加清晰等等，总之功能十分强大。</p>\n<p>闭包的含义：闭包说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕（这点涉及JavaScript作用域链）。</p>\n<p>示例一：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkClosure</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = <span class=\"string\">'rain-man'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeout(</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; alert( str ); &#125; <span class=\"comment\">//这是一个匿名函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    , <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"comment\">//这个函数要求延迟2秒执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">checkClosure();</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看上去十分的简单，仔细分析下它的执行过程还是有许多知识点的：checkClosure函数的执行是瞬间的（也许用时只是0.00001毫秒），在checkClosure的函数体内创建了一个变量str，在checkClosure执行完毕之后str并没有被释放，这是因为setTimeout内的匿名函数存在这对str的引用。待到2秒后函数体内的匿名函数被执行完毕,str才被释放。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例二：优化代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">forTimeout</span>(<span class=\"params\"> x, y</span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    alert( x + y );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delay</span>(<span class=\"params\"> x , y  , time </span>)</span>&#123;</span><br><span class=\"line\">    setTimeout( <span class=\"string\">'forTimeout('</span> +  x + <span class=\"string\">','</span> +  y + <span class=\"string\">')'</span> , time );   </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *上面的delay函数十分难以阅读，也不容易编写，但如果使用闭包就可以让代码更加清晰</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">function delay( x , y , time )&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    setTimeout(</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        function()&#123;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">            forTimeout( x , y )</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">        &#125;         </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    , time );  </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>举例</p>\n<p>匿名函数最大的用途是创建闭包（这是JavaScript语言的特性之一），并且还可以构建命名空间，以减少全局变量的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例三：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> oEvent = &#123;&#125;;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> addEvent = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">/*代码的实现省略了*/</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeEvent</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">oEvent.addEvent = addEvent;</span><br><span class=\"line\">oEvent.removeEvent = removeEvent;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>在这段代码中函数addEvent和removeEvent都是局部变量，但我们可以通过全局变量oEvent使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p>\n<p>我们要想使用此段代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">oEvent.addEvent( <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'box'</span>) , <span class=\"string\">'click'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; );</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//示例四：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> rainman = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> x , y </span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;)( <span class=\"number\">2</span> , <span class=\"number\">3</span> );</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *也可以写成下面的形式，因为第一个括号只是帮助我们阅读，但是不推荐使用下面这种书写格式。</span></span><br><span class=\"line\"><span class=\"comment\">var rainman = function( x , y )&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    return x + y;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;( 2 , 3 );</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>在这里我们创建了一个变量rainman，并通过直接调用匿名函数初始化为5，这种小技巧有时十分实用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例五：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> one = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inner</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    one += <span class=\"number\">1</span>;</span><br><span class=\"line\">    alert( one );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">outer = inner;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">outer();    <span class=\"comment\">//2</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//3</span></span><br><span class=\"line\">outer();    <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<p>这段代码中的变量one是一个局部变量（因为它被定义在一个函数之内），因此外部是不可以访问的。但是这里我们创建了inner函数，inner函数是可以访问变量one的；又将全局变量outer引用了inner，所以三次调用outer会弹出递增的结果。</p>\n<p>注意</p>\n<p>一：闭包允许内层函数引用父函数中的变量，但是该变量是最终值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例六：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;two&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;three&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;li&gt;one&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( i );       &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你会发现当鼠标移过每一个<li>元素时，总是弹出4，而不是我们期待的元素下标。这是为什么呢？注意事项里已经讲了（最终值）。显然这种解释过于简单，当mouseover事件调用监听函数时，首先在匿名函数（ function(){ alert(i); }）内部查找是否定义了 i，结果是没有定义；因此它会向上查找，查找结果是已经定义了，并且i的值是4（循环后的i值）；所以，最终每次弹出的都是4。</li></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">推荐第一个解决方法，因为第一种解决方法完全利用了闭包的优点，运用匿名函数的自调用技术。</span><br><span class=\"line\"></span><br><span class=\"line\">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法一：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> index </span>)</span>&#123;</span><br><span class=\"line\">        lists[ index ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert( index );   </span><br><span class=\"line\">        &#125;;                   </span><br><span class=\"line\">    &#125;)( i );<span class=\"comment\">//利用闭包的函数自调用的特性，当i的值传到匿名函数之后，匿名函数就可以自己调用，然后得出结果。</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法二：</span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    lists[ i ].$$index = i;    <span class=\"comment\">//通过在Dom元素上绑定$$index属性记录下标</span></span><br><span class=\"line\">    lists[ i ].onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert( <span class=\"keyword\">this</span>.$$index );   </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法三：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventListener</span>(<span class=\"params\"> list , index </span>)</span>&#123;</span><br><span class=\"line\">    list.onmouseover = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(index);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lists = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span> , len = lists.length ; i &lt; len ; i++ )&#123;</span><br><span class=\"line\">    eventListener( lists[ i ] , i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Hello JS","p":"javascript/hello-js","date":"2017-12-26T08:48:39.000Z","_content":"","source":"_posts/javascript/hello-js.md","raw":"---\ntitle: Hello JS\np: javascript/hello-js\ndate: 2017-12-26 16:48:39\ntags: [JS,Javascript]\ncategories: Javascript\n---\n","slug":"javascript/hello-js","published":1,"updated":"2017-12-26T09:34:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4wk0009h2e37ivabc8d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"OOJ-面向对象编程的三大特点-封装，继承，多态分析与实例","p":"javascript/OOJ-THREE","date":"2010-06-01T02:19:05.000Z","_content":"\n今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。\n\njavascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。\n\n### 首先：封装\n\n在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。\n\n今天我们重新温习加强理解下实现的要点与注意事项：\n\njavascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：\n\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function myInfo(){\n    var name =\"Hello\",age =27;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"years old\";\n    function showInfo(){\n      alert(myInfo);\n    }\n    return showInfo;\n  }\n  var oldFish = myInfo();\n  oldFish();\n// ]]>\n</script>\n```\n\n上面的代码段其实就是一个简单的闭包应用。 \n简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。 \n总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ \n\n如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：\n\n``` JS\n\n  var ioldFish = function(name,age){\n    var name = name,age = age;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"\">years old\";\n    return {\n      showInfo: function(){\n        alert(myInfo);  \n      } \n    }\n  }\n  ioldFish(\"Hello\",27).showInfo();\n```\n上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！ \n上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！ \n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n    var ioldFish = function(name,age){\n      return ioldFish.func.init(name,age);  \n    };\n    ioldFish.func = ioldFish.prototype ={\n        init:function(name,age){\n            this.name = name;\n            this.age = age;\n            return this;\n        },\n        showInfo:function(){\n            var info = \"my name is\" + this.name +\"i am \" +this.age+\"years old\";\n            alert(info);\n        }\n    };\n    ioldFish.func.init.prototype = ioldFish.func;\n    ioldFish(\"Hello\",27).showInfo();\n    //var oldFish = new ioldFish(\"Hello\",27);\n    //alert(oldFish.name);\n// ]]>\n</script>\n```\n两种模式各有特点，大家看情况随机使用。\n\n## 其次：继承\n\n与闭包封装有点冲突，闭包封装不利于子类派生。\n\n在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 \n\n*A.类式继承*：这个是现在主流框架中常用的继承方式，看下例：\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  var Name = function(name){\n    this.name = name;\n  };\n  Name.prototype.getName = function(){\n    alert(this.name);\n  };\n  var Fish = function(name,age){\n    Name.call(this,name);\n    this.age = age;\n  };\n  Fish.prototype = new Name();\n  Fish.prototype.constructor = Fish;\n  Fish.prototype.showInfo = function(){\n   alert(this.age);\n  }\n  var ioldFish = new Fish(\"Hello\",27);\n  ioldFish.getName();\n// ]]>\n</script>\n```\n\n上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 \n\n*B.原型继承*，从内存性能上看优于类式继承。\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function clone(object){\n    var F = function(){};\n    F.prototype = object;\n    return new F();\n  };\n  var Name = {\n    name:\"who's name\",\n    showInfo:function(){\n      alert(this.name);\n    }\n  };\n  var Fish = clone(Name);\n  //Fish.name = \"Hello\";\n  Fish.showInfo();\n// ]]>\n</script>\n```\n\n很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.\n\n*C.掺元类*：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 \n\n``` JS\n  function agument(receveClass,giveClass){\n    if(arguments[2]){\n      var len = arguments.length;\n      for(i=2;i<len;i++){\n        receveClass.prototype[arguments[i]] = giveClass.prototype[arguments[i]];\n      }\n    }\n    else{\n      for(method in giveClass.prototype){\n        if(!receveClass.prototype[method]){\n          receveClass.prototype[method] = giveClass.prototype[method];\n        }\n      }\n    }\n  };\n  var Name = function(){};\n  Name.prototype ={\n    sayLike:function(){\n      alert(\"i like oldfish\");\n    },\n    sayLove:function(){\n      alert(\"i love oldfish\");\n    }\n  }\n  var Fish = function(){};\n  var ioldFish = new Fish();\n  agument(Fish,Name,\"sayLove\");\n  ioldFish.sayLove();\n  ioldFish.sayLike();\n\n```\n\n多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。\n\n重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。\n\n覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！\n\n最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：\n``` JS\n\n var Name = function(name) {\n    this.name = name;\n    this.getName = function () {\n        alert(this.name);\n    }\n };\n   var ioldFish = new Name(\"Hello\"),\n   btn = document.getElementById('btn');\n   btn.onclick = ioldFish.getName;\n   //btn.onclick = function(){ioldFish.getName.call(ioldFish)};\n```\n上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。\n\n当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……\n\n``` JS\nFunction.prototype.bind = function(obj) {\n    var method = this,\n    temp = function() {\n        return method.apply(obj, arguments);\n    };\n}\n```\n循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。\n\n\n感谢老鱼的文章：本文引自：http://ued.alipay.com/2009/03/javascript-orient-object/  ","source":"_posts/javascript/OOJ-THREE.md","raw":"---\ntitle: OOJ-面向对象编程的三大特点-封装，继承，多态分析与实例\np: javascript/OOJ-THREE\ndate: 2010-06-01 10:19:05\ntags:\n    -   JS\n    -   Javascript\n    -   OOP\n    -   OOJ\n    -   H5\n    -   WEB\ncategories: Javascript\n---\n\n今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。\n\njavascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。\n\n### 首先：封装\n\n在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。\n\n今天我们重新温习加强理解下实现的要点与注意事项：\n\njavascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：\n\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function myInfo(){\n    var name =\"Hello\",age =27;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"years old\";\n    function showInfo(){\n      alert(myInfo);\n    }\n    return showInfo;\n  }\n  var oldFish = myInfo();\n  oldFish();\n// ]]>\n</script>\n```\n\n上面的代码段其实就是一个简单的闭包应用。 \n简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。 \n总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ \n\n如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：\n\n``` JS\n\n  var ioldFish = function(name,age){\n    var name = name,age = age;\n    var myInfo = \"my name is\" + name + \"i am\" + age +\"\">years old\";\n    return {\n      showInfo: function(){\n        alert(myInfo);  \n      } \n    }\n  }\n  ioldFish(\"Hello\",27).showInfo();\n```\n上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！ \n上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！ \n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n    var ioldFish = function(name,age){\n      return ioldFish.func.init(name,age);  \n    };\n    ioldFish.func = ioldFish.prototype ={\n        init:function(name,age){\n            this.name = name;\n            this.age = age;\n            return this;\n        },\n        showInfo:function(){\n            var info = \"my name is\" + this.name +\"i am \" +this.age+\"years old\";\n            alert(info);\n        }\n    };\n    ioldFish.func.init.prototype = ioldFish.func;\n    ioldFish(\"Hello\",27).showInfo();\n    //var oldFish = new ioldFish(\"Hello\",27);\n    //alert(oldFish.name);\n// ]]>\n</script>\n```\n两种模式各有特点，大家看情况随机使用。\n\n## 其次：继承\n\n与闭包封装有点冲突，闭包封装不利于子类派生。\n\n在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 \n\n*A.类式继承*：这个是现在主流框架中常用的继承方式，看下例：\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  var Name = function(name){\n    this.name = name;\n  };\n  Name.prototype.getName = function(){\n    alert(this.name);\n  };\n  var Fish = function(name,age){\n    Name.call(this,name);\n    this.age = age;\n  };\n  Fish.prototype = new Name();\n  Fish.prototype.constructor = Fish;\n  Fish.prototype.showInfo = function(){\n   alert(this.age);\n  }\n  var ioldFish = new Fish(\"Hello\",27);\n  ioldFish.getName();\n// ]]>\n</script>\n```\n\n上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 \n\n*B.原型继承*，从内存性能上看优于类式继承。\n``` JS\n<script type=\"text/javascript\">\n// <![CDATA[\n  function clone(object){\n    var F = function(){};\n    F.prototype = object;\n    return new F();\n  };\n  var Name = {\n    name:\"who's name\",\n    showInfo:function(){\n      alert(this.name);\n    }\n  };\n  var Fish = clone(Name);\n  //Fish.name = \"Hello\";\n  Fish.showInfo();\n// ]]>\n</script>\n```\n\n很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.\n\n*C.掺元类*：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 \n\n``` JS\n  function agument(receveClass,giveClass){\n    if(arguments[2]){\n      var len = arguments.length;\n      for(i=2;i<len;i++){\n        receveClass.prototype[arguments[i]] = giveClass.prototype[arguments[i]];\n      }\n    }\n    else{\n      for(method in giveClass.prototype){\n        if(!receveClass.prototype[method]){\n          receveClass.prototype[method] = giveClass.prototype[method];\n        }\n      }\n    }\n  };\n  var Name = function(){};\n  Name.prototype ={\n    sayLike:function(){\n      alert(\"i like oldfish\");\n    },\n    sayLove:function(){\n      alert(\"i love oldfish\");\n    }\n  }\n  var Fish = function(){};\n  var ioldFish = new Fish();\n  agument(Fish,Name,\"sayLove\");\n  ioldFish.sayLove();\n  ioldFish.sayLike();\n\n```\n\n多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。\n\n重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。\n\n覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！\n\n最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：\n``` JS\n\n var Name = function(name) {\n    this.name = name;\n    this.getName = function () {\n        alert(this.name);\n    }\n };\n   var ioldFish = new Name(\"Hello\"),\n   btn = document.getElementById('btn');\n   btn.onclick = ioldFish.getName;\n   //btn.onclick = function(){ioldFish.getName.call(ioldFish)};\n```\n上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。\n\n当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……\n\n``` JS\nFunction.prototype.bind = function(obj) {\n    var method = this,\n    temp = function() {\n        return method.apply(obj, arguments);\n    };\n}\n```\n循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。\n\n\n感谢老鱼的文章：本文引自：http://ued.alipay.com/2009/03/javascript-orient-object/  ","slug":"javascript/OOJ-THREE","published":1,"updated":"2017-12-27T06:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbood4wl000ah2e3489eyz16","content":"<p>今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。</p>\n<p>javascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。</p>\n<h3 id=\"首先：封装\"><a href=\"#首先：封装\" class=\"headerlink\" title=\"首先：封装\"></a>首先：封装</h3><p>在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。</p>\n<p>今天我们重新温习加强理解下实现的要点与注意事项：</p>\n<p>javascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">\"Hello\"</span>,age =<span class=\"number\">27</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(myInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> showInfo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oldFish = myInfo();</span><br><span class=\"line\">  oldFish();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码段其实就是一个简单的闭包应用。<br>简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。<br>总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ </p>\n<p>如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name,age = age;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"\"</span>&gt;years old<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">  return &#123;</span></span><br><span class=\"line\"><span class=\"string\">    showInfo: function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">      alert(myInfo);  </span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">ioldFish(\"</span>Hello<span class=\"string\">\",27).showInfo();</span></span><br></pre></td></tr></table></figure>\n<p>上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！<br>上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ioldFish.func.init(name,age);  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func = ioldFish.prototype =&#123;</span><br><span class=\"line\">        init:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> info = <span class=\"string\">\"my name is\"</span> + <span class=\"keyword\">this</span>.name +<span class=\"string\">\"i am \"</span> +<span class=\"keyword\">this</span>.age+<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">            alert(info);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func.init.prototype = ioldFish.func;</span><br><span class=\"line\">    ioldFish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>).showInfo();</span><br><span class=\"line\">    <span class=\"comment\">//var oldFish = new ioldFish(\"Hello\",27);</span></span><br><span class=\"line\">    <span class=\"comment\">//alert(oldFish.name);</span></span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>两种模式各有特点，大家看情况随机使用。</p>\n<h2 id=\"其次：继承\"><a href=\"#其次：继承\" class=\"headerlink\" title=\"其次：继承\"></a>其次：继承</h2><p>与闭包封装有点冲突，闭包封装不利于子类派生。</p>\n<p>在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 </p>\n<p><em>A.类式继承</em>：这个是现在主流框架中常用的继承方式，看下例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Name.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Name.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Fish.prototype = <span class=\"keyword\">new</span> Name();</span><br><span class=\"line\">  Fish.prototype.constructor = Fish;</span><br><span class=\"line\">  Fish.prototype.showInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>);</span><br><span class=\"line\">  ioldFish.getName();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 </p>\n<p><em>B.原型继承</em>，从内存性能上看优于类式继承。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">object</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = object;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">\"who's name\"</span>,</span><br><span class=\"line\">    showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = clone(Name);</span><br><span class=\"line\">  <span class=\"comment\">//Fish.name = \"Hello\";</span></span><br><span class=\"line\">  Fish.showInfo();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.</p>\n<p><em>C.掺元类</em>：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agument</span>(<span class=\"params\">receveClass,giveClass</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">      receveClass.prototype[<span class=\"built_in\">arguments</span>[i]] = giveClass.prototype[<span class=\"built_in\">arguments</span>[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(method <span class=\"keyword\">in</span> giveClass.prototype)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!receveClass.prototype[method])&#123;</span><br><span class=\"line\">        receveClass.prototype[method] = giveClass.prototype[method];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Name.prototype =&#123;</span><br><span class=\"line\">  sayLike:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i like oldfish\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sayLove:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love oldfish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">agument(Fish,Name,<span class=\"string\">\"sayLove\"</span>);</span><br><span class=\"line\">ioldFish.sayLove();</span><br><span class=\"line\">ioldFish.sayLike();</span><br></pre></td></tr></table></figure>\n<p>多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。</p>\n<p>重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。</p>\n<p>覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！</p>\n<p>最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Name(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\">  btn.onclick = ioldFish.getName;</span><br><span class=\"line\">  <span class=\"comment\">//btn.onclick = function()&#123;ioldFish.getName.call(ioldFish)&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。</p>\n<p>当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">    temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。</p>\n<p>感谢老鱼的文章：本文引自：<a href=\"http://ued.alipay.com/2009/03/javascript-orient-object/\" target=\"_blank\" rel=\"noopener\">http://ued.alipay.com/2009/03/javascript-orient-object/</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天谈谈面向对象编程的三个主要的关键词：封装、继承、多态。</p>\n<p>javascript面向对象编程，既然是面向对象编程不得不提到面向对象的几大关键字：封装，继承，多态。</p>\n<h3 id=\"首先：封装\"><a href=\"#首先：封装\" class=\"headerlink\" title=\"首先：封装\"></a>首先：封装</h3><p>在前几篇的文章中我们已经了解到JAVASCRIPT需要通过模拟实现一些类似C++,C#语言面向对象的特征。</p>\n<p>今天我们重新温习加强理解下实现的要点与注意事项：</p>\n<p>javascript中创建对象的模式中，一般认为通过闭包才算的上是真正意义上的封装，所以首先我们先来简单介绍一下闭包，看下面这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">\"Hello\"</span>,age =<span class=\"number\">27</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showInfo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(myInfo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> showInfo;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> oldFish = myInfo();</span><br><span class=\"line\">  oldFish();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码段其实就是一个简单的闭包应用。<br>简单解释一下：上面的函数myInfo中定义的变量，在它的内嵌函数showInfo中是可访问的（这个很好理解），但是当我们把这个内嵌函数的返回引用赋值给一个变量oldFish，这个时候函数showInfo是在myInfo函数体外被调用，但是同样可以访问到定义在函数体内的变量。<br>总结一下闭包的原理吧：函数是运行在定义他们的作用域中而不是调用他们的作用域中。其实返回一个内嵌函数也是创建闭包最常用的一种方法！ </p>\n<p>如果觉得上面的解释太抽象的话，那么我们一起重塑上面的函数，看看这样是否层次鲜明一些：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name,age = age;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myInfo = <span class=\"string\">\"my name is\"</span> + name + <span class=\"string\">\"i am\"</span> + age +<span class=\"string\">\"\"</span>&gt;years old<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\">  return &#123;</span></span><br><span class=\"line\"><span class=\"string\">    showInfo: function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">      alert(myInfo);  </span></span><br><span class=\"line\"><span class=\"string\">    &#125; </span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">ioldFish(\"</span>Hello<span class=\"string\">\",27).showInfo();</span></span><br></pre></td></tr></table></figure>\n<p>上例中的编码风格是ext yui中比较常见的，公私分明，一目了然。通过闭包，我们可以很方便的把一些不希望被外部直接访问到的东西隐藏起来，你要访问函数内定义的变量，只能通过特定的方法才可以访问的到，直接从外部访问是访问不到的，写的挺累，饶了一圈终于转回来了，封装嘛，不就是把不希望被别人看到的东西隐藏起来嘛！<br>上例如果转换成JQ的风格的话，应该如下例所写， 这样的封装模式属于门户大开型模式，里面定义的变量是可以被外部访问到的（下面的例子如果你先实例化一个对象，然后在函数外部访问对象的name或者age属性都是可以读取到的）当然这种模式下我们可以设置一些”潜规则”，让团队开发成员明白哪些变量是私用的，通常我们人为的在私有变量和方法前加下划线”_”，标识警戒讯号！从而实现”封装”！<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ioldFish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ioldFish.func.init(name,age);  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func = ioldFish.prototype =&#123;</span><br><span class=\"line\">        init:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> info = <span class=\"string\">\"my name is\"</span> + <span class=\"keyword\">this</span>.name +<span class=\"string\">\"i am \"</span> +<span class=\"keyword\">this</span>.age+<span class=\"string\">\"years old\"</span>;</span><br><span class=\"line\">            alert(info);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ioldFish.func.init.prototype = ioldFish.func;</span><br><span class=\"line\">    ioldFish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>).showInfo();</span><br><span class=\"line\">    <span class=\"comment\">//var oldFish = new ioldFish(\"Hello\",27);</span></span><br><span class=\"line\">    <span class=\"comment\">//alert(oldFish.name);</span></span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>两种模式各有特点，大家看情况随机使用。</p>\n<h2 id=\"其次：继承\"><a href=\"#其次：继承\" class=\"headerlink\" title=\"其次：继承\"></a>其次：继承</h2><p>与闭包封装有点冲突，闭包封装不利于子类派生。</p>\n<p>在javascript中继承一般分为三种方式：”类式继承”，”原型继承”,”掺元类”。下面简单的介绍一下三类继承方式的原理。 </p>\n<p><em>A.类式继承</em>：这个是现在主流框架中常用的继承方式，看下例：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Name.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    Name.call(<span class=\"keyword\">this</span>,name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  Fish.prototype = <span class=\"keyword\">new</span> Name();</span><br><span class=\"line\">  Fish.prototype.constructor = Fish;</span><br><span class=\"line\">  Fish.prototype.showInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish(<span class=\"string\">\"Hello\"</span>,<span class=\"number\">27</span>);</span><br><span class=\"line\">  ioldFish.getName();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述子类Fish中并没定义getName方法，但是子类Fish的实例对象ioldFish依然调用到了该方法，这是因为子类Fish继承了父类Name中定义的getName方法。解释一下，这里子类Fish的prototype指到了父类的一个实例，在子类Fish中虽然没有申明getName方法，但是根据原型链原理，会向prototype指向的上一级对象中去查找是否有该方法，如果没找到该方法，会一直搜索到最初的原型对象。这其实也就是继承的原理了。这里特别说明一下，Fish.prototype.constructor = Fish;这句，由于默认子类的prototype应该是指向本身的，但是之前把prototype指向到了超类的实例对象，所以在这里要把它设置回来。当然这里可以把相关代码通过一个函数来组织起来，起到伪装extend的作用，这里不再阐述。 </p>\n<p><em>B.原型继承</em>，从内存性能上看优于类式继承。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;![CDATA[</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">object</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">    F.prototype = object;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Name = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">\"who's name\"</span>,</span><br><span class=\"line\">    showInfo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> Fish = clone(Name);</span><br><span class=\"line\">  <span class=\"comment\">//Fish.name = \"Hello\";</span></span><br><span class=\"line\">  Fish.showInfo();</span><br><span class=\"line\"><span class=\"comment\">// ]]&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>很明显，原型继承核心就是这个clone函数，同样是原型链的原理，不同的是它直接克隆超类，这样的话子类就继承了超类的所有属性和方法.特别说一下，这类继承并不需要创建构造函数，只需要创建一个对象字变量，定义相应的属性和方法，然后在子类中只需要通过圆点”.”符号来引用属性和方法就可以了.</p>\n<p><em>C.掺元类</em>：把一些常用通用性比较大的方法统一封装在一个函数中，然后通过下面这个函数分派给要用到这些方法的类．还可以针对不同的类，选择性的传递需要的方法。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">agument</span>(<span class=\"params\">receveClass,giveClass</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>])&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = <span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">2</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">      receveClass.prototype[<span class=\"built_in\">arguments</span>[i]] = giveClass.prototype[<span class=\"built_in\">arguments</span>[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(method <span class=\"keyword\">in</span> giveClass.prototype)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!receveClass.prototype[method])&#123;</span><br><span class=\"line\">        receveClass.prototype[method] = giveClass.prototype[method];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">Name.prototype =&#123;</span><br><span class=\"line\">  sayLike:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i like oldfish\"</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sayLove:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"i love oldfish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Fish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Fish();</span><br><span class=\"line\">agument(Fish,Name,<span class=\"string\">\"sayLove\"</span>);</span><br><span class=\"line\">ioldFish.sayLove();</span><br><span class=\"line\">ioldFish.sayLike();</span><br></pre></td></tr></table></figure>\n<p>多态：个人觉得这个比较抽象，很难言传，所以下面就从重载和覆盖两个方面来简单阐述一下。</p>\n<p>重载：上面这个例子中agument函数初始带了两个参数，但是在后面的调用中，agument(Fish,Name,”sayLove”)同样可以带入任意多个参数，javascript的重载，是在函数中由用户自己通过操作arguments这个属性来实现的。</p>\n<p>覆盖：这个很简单，就是子类中定义的方法如果与从超类中继承过来的的方法同名，就覆盖这个方法（这里并不是覆盖超类中的方法，注意一下），这里就不累赘了！</p>\n<p>最后重点着墨说一下this和执行上下文，在前面举的封装例子中，this都是表示this所在的类的实例化对象本身，但是并不是千篇一律的，打个比方，通过HTML属性定义的事件处理代码，见如下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ioldFish = <span class=\"keyword\">new</span> Name(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  btn = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'btn'</span>);</span><br><span class=\"line\">  btn.onclick = ioldFish.getName;</span><br><span class=\"line\">  <span class=\"comment\">//btn.onclick = function()&#123;ioldFish.getName.call(ioldFish)&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>上例中点了按钮以后弹出框里并没有显示出实例对象的属性，这是因为this的执行上下文已经改变了，他现在所在的上下文应该是input这个HTML标签，但是该标签又不存在getName这个属性，所以自然无法输出这个属性的属性值了！从这个例子我们不难看出：执行上下文是在执行时才确定的，它随时可以变。</p>\n<p>当然你可以去掉上面我注释掉的那段代码，通过call改变this的执行上下文，从而获取getName方法。apply方法同样可以实现改变执行上下文的功能，不过在prototype框架中发现了一个更为优美的实现方法bind。看一下这个方法的实现吧，不得不感叹先人的伟大……</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> method = <span class=\"keyword\">this</span>,</span><br><span class=\"line\">    temp = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> method.apply(obj, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>循序渐进,日有所学。学习语言基本靠实践。只要不断的写才能得到提高。</p>\n<p>感谢老鱼的文章：本文引自：<a href=\"http://ued.alipay.com/2009/03/javascript-orient-object/\" target=\"_blank\" rel=\"noopener\">http://ued.alipay.com/2009/03/javascript-orient-object/</a>  </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbood4vz0002h2e36jxb095s","category_id":"cjbood4w00003h2e3pdgtvfxv","_id":"cjbood4w30004h2e35somycw5"},{"post_id":"cjbood4wl000ah2e3489eyz16","category_id":"cjbood4wj0007h2e3bxyxgidp","_id":"cjbood4wp000dh2e3izbckdbm"},{"post_id":"cjbood4wa0005h2e3qsj96zja","category_id":"cjbood4wj0007h2e3bxyxgidp","_id":"cjbood4wq000gh2e3491nb2qs"},{"post_id":"cjbood4wf0006h2e350lc3spn","category_id":"cjbood4wj0007h2e3bxyxgidp","_id":"cjbood4wq000hh2e3b4q1glel"},{"post_id":"cjbood4wk0009h2e37ivabc8d","category_id":"cjbood4wj0007h2e3bxyxgidp","_id":"cjbood4wq000jh2e3xr6kse13"}],"PostTag":[{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wj0008h2e3hsebedxx","_id":"cjbood4wt000nh2e3hv28r699"},{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wm000ch2e32pxlkdw4","_id":"cjbood4wt000oh2e35fh7ks28"},{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wq000fh2e309oprffp","_id":"cjbood4wu000qh2e3e0r91xa1"},{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wq000ih2e337onniyi","_id":"cjbood4wv000rh2e3vift6i6u"},{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wr000kh2e3rsfvnt9m","_id":"cjbood4wv000th2e3n3k0lkmt"},{"post_id":"cjbood4wa0005h2e3qsj96zja","tag_id":"cjbood4wr000lh2e3avh84j4a","_id":"cjbood4wv000uh2e3uo076yga"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wj0008h2e3hsebedxx","_id":"cjbood4wx000zh2e3fbz9xj52"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wm000ch2e32pxlkdw4","_id":"cjbood4wx0010h2e34nm7beu9"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wq000fh2e309oprffp","_id":"cjbood4wx0012h2e32r9i3tm1"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wq000ih2e337onniyi","_id":"cjbood4wx0013h2e3ltn3om4t"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wr000kh2e3rsfvnt9m","_id":"cjbood4wy0015h2e30m8eerpg"},{"post_id":"cjbood4wf0006h2e350lc3spn","tag_id":"cjbood4wr000lh2e3avh84j4a","_id":"cjbood4wy0016h2e3j6djlcto"},{"post_id":"cjbood4wk0009h2e37ivabc8d","tag_id":"cjbood4wj0008h2e3hsebedxx","_id":"cjbood4wy0018h2e3e9qoi6d1"},{"post_id":"cjbood4wk0009h2e37ivabc8d","tag_id":"cjbood4wm000ch2e32pxlkdw4","_id":"cjbood4wy0019h2e367qn59c2"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wj0008h2e3hsebedxx","_id":"cjbood4x0001dh2e37iyfzfpm"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wm000ch2e32pxlkdw4","_id":"cjbood4x0001eh2e39wm0hqgy"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wq000fh2e309oprffp","_id":"cjbood4x0001fh2e30xzjllpt"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wq000ih2e337onniyi","_id":"cjbood4x0001gh2e3rm5trerl"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wr000kh2e3rsfvnt9m","_id":"cjbood4x0001hh2e3kmd8imjm"},{"post_id":"cjbood4wl000ah2e3489eyz16","tag_id":"cjbood4wr000lh2e3avh84j4a","_id":"cjbood4x0001ih2e3y8frcd9a"}],"Tag":[{"name":"JS","_id":"cjbood4wj0008h2e3hsebedxx"},{"name":"Javascript","_id":"cjbood4wm000ch2e32pxlkdw4"},{"name":"OOP","_id":"cjbood4wq000fh2e309oprffp"},{"name":"OOJ","_id":"cjbood4wq000ih2e337onniyi"},{"name":"H5","_id":"cjbood4wr000kh2e3rsfvnt9m"},{"name":"WEB","_id":"cjbood4wr000lh2e3avh84j4a"}]}}